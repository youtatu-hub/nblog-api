/*
 Navicat Premium Dump SQL

 Source Server         : mysql
 Source Server Type    : MySQL
 Source Server Version : 80039 (8.0.39)
 Source Host           : localhost:3306
 Source Schema         : nblog

 Target Server Type    : MySQL
 Target Server Version : 80039 (8.0.39)
 File Encoding         : 65001

 Date: 20/03/2025 15:16:19
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for about
-- ----------------------------
DROP TABLE IF EXISTS `about`;
CREATE TABLE `about`  (
  `id` bigint NOT NULL,
  `name_en` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `name_zh` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `value` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of about
-- ----------------------------
INSERT INTO `about` VALUES (1, 'title', '标题', '关于帅气的 Youta');
INSERT INTO `about` VALUES (2, 'musicId', '网易云歌曲ID', '423015580');
INSERT INTO `about` VALUES (3, 'content', '正文Markdown', '');
INSERT INTO `about` VALUES (4, 'commentEnabled', '评论开关', 'true');

-- ----------------------------
-- Table structure for blog
-- ----------------------------
DROP TABLE IF EXISTS `blog`;
CREATE TABLE `blog`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '文章标题',
  `first_picture` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '文章首图，用于随机文章展示',
  `content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '文章正文',
  `description` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '描述',
  `is_published` bit(1) NOT NULL COMMENT '公开或私密',
  `is_recommend` bit(1) NOT NULL COMMENT '推荐开关',
  `is_appreciation` bit(1) NOT NULL COMMENT '赞赏开关',
  `is_comment_enabled` bit(1) NOT NULL COMMENT '评论开关',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NOT NULL COMMENT '更新时间',
  `views` int NOT NULL COMMENT '浏览次数',
  `words` int NOT NULL COMMENT '文章字数',
  `read_time` int NOT NULL COMMENT '阅读时长(分钟)',
  `category_id` bigint NOT NULL COMMENT '文章分类',
  `is_top` bit(1) NOT NULL COMMENT '是否置顶',
  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '密码保护',
  `user_id` bigint NULL DEFAULT NULL COMMENT '文章作者',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `type_id`(`category_id` ASC) USING BTREE,
  INDEX `user_id`(`user_id` ASC) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 18 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of blog
-- ----------------------------
INSERT INTO `blog` VALUES (5, 'JVM 垃圾收集器', 'https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/713d65b0-96a9-11ea-949b-db7ff35aaabb.png', '**1.简述 Java 垃圾回收机制**\n\n在 java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在 JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。\n\n**2. GC 是什么？为什么要 GC**\n\nGC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存 回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动 回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。\n\n**3. 垃圾回收的优点和原理。并考虑 2 种回收机制**\n\nJava 语言最显著的特点就是引入了垃圾回收机制，它使 java 程序员在编写程序时不再考虑内存管理的问题。 由于有这个垃圾回收机制，java 中的对象不再有“作用域”的概念，只有引用的对象才有“作用域”。 垃圾回收机制有效的防止了内存泄露，可以有效的使用可使用的内存。 垃圾回收器通常作为一个单独的低级别的线程运行，在不可预知的情况下对内存堆中已经死亡的或很长时间没有用过的对象进行清除和回收。 程序员不能实时的对某个对象或所有对象调用垃圾回收器进行垃圾回收。 垃圾回收有分代复制垃圾回收、标记垃圾回收、增量垃圾回收。\n\n**4. 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？**\n\n对于 GC 来说，当程序员创建对象时，GC 就开始监控这个对象的地址、大小以及使用情况。 通常，GC 采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当 GC 确定一些对象为”不可达”时，GC 就有责任回收这些内存空间。 可以。程序员可以手动执行 System.gc()，通知 GC 运行，但是 Java 语言规范并不保证 GC 一定会执行。\n\n**5. Java 中都有哪些引用类型？**\n\n强引用：发生 gc 的时候不会被回收。 软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。 弱引用：有用但不是必须的对象，在下一次 GC 时会被回收。 虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。\n\n**6. 怎么判断对象是否可以被回收？**\n\n垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收的，哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收。\n\n一般有两种方法来判断： 引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题； 可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。\n\n**7. 在 Java 中，对象什么时候可以被垃圾回收?**\n\n当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。 垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免 Full GC 是非常重要的原因。\n\n**8. JVM 中的永久代中会发生垃圾回收吗?**\n\n垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免 Full GC 是非常重要的原因。请参考下 Java8：从永久代到元数据区 (译者注：Java8 中已经移除了永久代，新加了一个叫做元数据区的 native 内存区)\n\n**9. 说一下 JVM 有哪些垃圾回收算法？**\n\n标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。 复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。 标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。 分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。\n\n**标记-清除算法**\n\n标记无用对象，然后进行清除回收。 标记-清除算法（Mark-Sweep）是一种常见的基础垃圾收集算法，它将垃圾收集分为两个阶段： 标记阶段：标记出可以回收的对象。 清除阶段：回收被标记的对象所占用的空间。 标记-清除算法之所以是基础的，是因为后面讲到的垃圾收集算法都是在此算法的基础上进行改进的。 优点：实现简单，不需要对象进行移动。 缺点：标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的频率。 标记-清除算法的执行的过程如下图所示\n\n![复制算法](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/713d65b0-96a9-11ea-949b-db7ff35aaabb.png)\n\n为了解决标记-清除算法的效率不高的问题，产生了复制算法。它把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾收集时，遍历当前使用的区域，把存活对象复制到另外一个区域中，最后将当前使用的区域的可回收的对象进行回收。 优点：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。 缺点：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。\n\n复制算法的执行过程如下图所示\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/7f74c560-96a9-11ea-b0a6-ebd9ebfac77b.png)\n\n**标记-整理算法**\n\n在新生代中可以使用复制算法，但是在老年代就不能选择复制算法了，因为老年代的对象存活率会较高，这样会有较多的复制操作，导致效率变低。标记-清除算法可以应用在老年代中，但是它效率不高，在内存回收后容易产生大量内存碎片。因此就出现了一种标记-整理算法（Mark-Compact）算法，与标记-整理算法不同的是，在标记可回收的对象后将所有存活的对象压缩到内存的一端，使他们紧凑的排列在一起，然后对端边界以外的内存进行回收。回收后，已用和未用的内存都各自一边。 优点：解决了标记-清理算法存在的内存碎片问题。 缺点：仍需要进行局部对象移动，一定程度上降低了效率。 标记-整理算法的执行过程如下图所示\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/9e21b4f0-96a9-11ea-958b-6d75f69bc560.png)\n\n**分代收集算法**\n\n当前商业虚拟机都采用分代收集的垃圾收集算法。分代收集算法，顾名思义是根据对象的存活周期将内存划分为几块。一般包括年轻代、老年代 和 永久代，如图所示：\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/925e1460-96a9-11ea-958b-6d75f69bc560.png)\n\n**10. 说一下 JVM 有哪些垃圾回收器？**\n\n如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。下图展示了 7 种作用于不同分代的收集器，其中用于回收新生代的收集器包括 Serial、PraNew、Parallel Scavenge，回收老年代的收集器包括 Serial Old、Parallel Old、CMS，还有用于回收整个 Java 堆的 G1 收集器。不同收集器之间的连线表示它们可以搭配使用。\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/cb814eb0-96a9-11ea-bcac-1f458c1b219e.png)\n\nSerial 收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效； ParNew 收集器 (复制算法): 新生代收并行集器，实际上是 Serial 收集器的多线程版本，在多核 CPU 环境下有着比 Serial 更好的表现； Parallel Scavenge 收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC 线程时间)，高吞吐量可以高效率的利用 CPU 时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景； Serial Old 收集器 (标记-整理算法): 老年代单线程收集器，Serial 收集器的老年代版本； Parallel Old 收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge 收集器的老年代版本； CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短 GC 回收停顿时间。 G1(Garbage First)收集器 (标记-整理算法)： Java 堆并行收集器，G1 收集器是 JDK1.7 提供的一个新收集器，G1 收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1 收集器不同于之前的收集器的一个重要特点是：G1 回收的范围是整个 Java 堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。\n\n**11. 详细介绍一下 CMS 垃圾回收器？**\n\nCMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。 CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。\n\n**12. 新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？**\n\n新生代回收器：Serial、ParNew、Parallel Scavenge 老年代回收器：Serial Old、Parallel Old、CMS 整堆回收器：G1\n\n新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。\n\n**13. 简述分代垃圾回收器是怎么工作的？**\n\n分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。 新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：\n\n- 把 Eden + From Survivor 存活的对象放入 To Survivor 区；\n- 清空 Eden 和 From Survivor 分区；\n- From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。\n\n每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。 老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。', '![JVM 垃圾收集器](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/713d65b0-96a9-11ea-949b-db7ff35aaabb.png)', b'1', b'1', b'0', b'1', '2024-12-20 15:20:45', '2024-12-23 10:05:32', 22, 3614, 18, 10, b'1', '', 1);
INSERT INTO `blog` VALUES (6, 'ElasticSearch 小白从入门到精通', 'https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.png', '### 什么是 ElasticSearch\n\nElasticSearch 简称为 ES，网址为：\n\n> https://www.elastic.co/\n\nES 是一个分布式的开源搜索和分析引擎，适用于文本、数字、地理空间、结构化数据、非结构化数据等数据的搜索。ES 是在 Apache Lucene 的基础上完成开发。由 Elastic 于 2010 年发布。ES 通过其简单的 REST 风格的 API、分布式特性、速度和可扩容闻名世界。是 Elastic Stack 的核心组件。Elastic Stack 是一套用于数据采集、扩充、保存、分析、可视化的开源工具。Elastic Stack 称之为 ELK。目前 ELK 包含一系列丰富的轻量数据采集代理，这些代理被称之为 Beats。\n\n#### ES 的用途\n\n主要有以下的用途：\n\n- 应用程序搜索\n- 网站搜索\n- 企业搜索\n- 日志处理\n- 基础设施指标和容器监测\n- 应用程序性能监测\n- 地理空间数据分析和可视化\n- 安全分析\n- 业务分析\n\n#### 工作原理\n\n从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，在 Kibana 中，用户可以创建数据可视化面板，并对 ELK 进行管理。\n\n#### 索引\n\nES 索引是指相互关联的文档集合。ES 是会以 JSON 文档的形式保存数据，每个文档都会在一组键值对中建立联系。\n\nES 使用的是一种倒排序索引的数据结构。这个结构可以允许十分快速的进行全文本的搜索。\n\n在索引的过程中，ES 会保存文档并构建倒排序索引，这样用户就可以实时的对文档数据进行搜索。索引是在添加过程中就启动的。\n\n#### Logstash\n\nLogstash 是 ELK 的核心菜品，可以对数据进行聚合和处理。并将数据发送到 ES 中。Logstash 是一个开源的服务器端数据处理管道。\n\n#### Kibana\n\nKibana 是一款 ES 的数据可视化和管理工具，可以提供直方图，线形图，饼状图，地图。Kibana 还包含 Canvas 和 Elastic Maps 等应用程序。Canvas 可以基于用户创建动态信息。Elastic Maps 可以对空间数据进行可视化处理。\n\n#### 为什么要使用 ES\n\n- **ES 很快**：ES 是在 Lucene 基础上构建，所以全文本搜索相当的出色。ES 还是一个实时搜索平台。文档索引操作到文档变为可搜索之间速度很快。\n- **ES 具有分布式的特征**：ES 中保存的文档分布在不同的容器中，这些容器为分片，可以对分片进行复制并形成冗余副本。ES 可以扩充到数百台，并处理 PB 级别的数据。\n- **ES 包含一系列广泛的功能**：ES 拥有大量的内置功能，方便用户管理数据。\n- **ES 简化了数据采集，可视化报告的过程**：通过与 Beats 和 Logstash 集成，用户可以在 ES 中索引数据并处理数据，\n\n### ES 搭建\n\n安装镜像：\n\n```bash\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.2\n```\n\n启动容器：\n\n```bash\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" docker.elastic.co/elasticsearch/elasticsearch:7.3.2\n```\n\n修改配置：\n\n```bash\n#进入 docker 容器内部\n\ndocker exec -it es /bin/bash\n\n#打开配置文件\n\nvim config/elasticsearch.yml\n\n### 加入跨域配置\n\nhttp.cors.enabled: true\n\nhttp.cors.allow-origin: \"*\"\n```\n\n进入容器，安装分词器：\n\n```bash\ndocker exec -it es /bin/bash\n./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.3.2/elasticsearch-analysis-ik-7.3.2.zip\n```\n\n重启 ES：\n\n```bash\ndocker restart es\n```\n\n测试：\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.png)\n\n查看分词器是否安装上：\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/25ebc030-cee2-11eb-ac3e-190fba44d759.png)\n\n### ES 查询\n\n#### 空查询\n\n空查询将会返回一个索引库中所有文档：\n\n```bash\ncurl -X GET \"localhost:9200/_search?pretty\" -H \'Content-Type: application/json\' -d\'\n{}\n\'\n```\n\n在一个或者多个索引库或者所有的 _type 中查询：\n\n```bash\nGET /index_2014*/type1,type2/_search\n{}\n```\n\n使用分页：\n\n```bash\nGET /_search\n{\n  \"from\": 30,\n  \"size\": 10\n}\n```\n\n#### 查询表达式\n\n只需要在查询上，将语句传递给 queue 参数：\n\n```bash\nGET /_search\n{\n    \"query\": YOUR_QUERY_HERE\n}\n```\n\n##### 查询语句的结构\n\n一个查询的典型结构：\n\n```json\n{\n    QUERY_NAME: {\n        ARGUMENT: VALUE,\n        ARGUMENT: VALUE,...\n    }\n}\n```\n\n针对某个字段：\n\n```json\n{\n    QUERY_NAME: {\n        FIELD_NAME: {\n            ARGUMENT: VALUE,\n            ARGUMENT: VALUE,...\n        }\n    }\n}\n```\n\n如果想要使用 match 查询 tewwt 字段中包含 elasticsesh 的内容。\n\n```bash\ncurl -X GET \"localhost:9200/_search?pretty\" -H \'Content-Type: application/json\' -d\'\n{\n    \"query\": {\n        \"match\": {\n            \"tweet\": \"elasticsearch\"\n        }\n    }\n}\n\'\n```\n\n##### 合并查询\n\n分为叶子语句，被用于将查询字符串和字段进行对比，复合语句用于合并其他查询语句。\n\n例如下面语句：找出信件正文包含 business opportunity 的星标邮件，或者在邮件正文包含 business opportunity 的非垃圾邮件：\n\n```json\n{\n    \"bool\": {\n        \"must\": { \"match\":   { \"email\": \"business opportunity\" }},\n        \"should\": [\n            { \"match\":       { \"starred\": true }},\n            { \"bool\": {\n                \"must\":      { \"match\": { \"folder\": \"inbox\" }},\n                \"must_not\":  { \"match\": { \"spam\": true }}\n            }}\n        ],\n        \"minimum_should_match\": 1\n    }\n}\n```\n\n#### 常用查询\n\n##### match_all 查询\n\n该查询匹配所有文档：\n\n```json\n{ \"match_all\": {}}\n```\n\n##### match 查询\n\n用于使用分词器进行查询：\n\n```json\n{ \"match\": { \"tweet\": \"About Search\" }}\n```\n\n##### multi_match 查询\n\n用于在多个字段上执行相同更多 match 查询：\n\n```json\n{\n    \"multi_match\": {\n        \"query\":    \"full text search\",\n        \"fields\":   [ \"title\", \"body\" ]\n    }\n}\n```\n\n##### range 查询\n\n用于找出在指定区间内的数字或者时间：\n\n```json\n{\n    \"range\": {\n        \"age\": {\n            \"gte\":  20,\n            \"lt\":   30\n        }\n    }\n}\n```\n\n##### term 查询\n\n用于进行精确匹配：\n\n```json\n{ \"term\": { \"age\":    26           }}\n{ \"term\": { \"date\":   \"2014-09-01\" }}\n{ \"term\": { \"public\": true         }}\n{ \"term\": { \"tag\":    \"full_text\"  }}\n```\n\n##### terms 查询\n\n用于进行多值匹配：\n\n```json\n{ \"terms\": { \"tag\": [ \"search\", \"full_text\", \"nosql\" ] }}\n```\n\n##### exists 查询和 missing 查询\n\n用于查询在指定字段中有值或者无值的文档：\n\n```json\n{\n    \"exists\":   {\n        \"field\":    \"title\"\n    }\n}\n```\n\n### ES 索引\n\n#### 创建一个索引\n\n```bash\nPUT /my_index\n{\n    \"settings\": { ... any settings ... },\n    \"mappings\": {\n        \"type_one\": { ... any mappings ... },\n        \"type_two\": { ... any mappings ... },\n        ...\n    }\n}\n```\n\n此刻，ES 会自动创建一个索引。\n\n#### 删除一个索引\n\n```bash\nDELETE /my_index\n```\n\n#### 索引设置\n\n- number_of_shards：每个索引的主分片数\n- number_of_replicas：每个主分片的副本数\n\n创建只有 一个主分片，没有副本的小索引：\n\n```bash\nPUT /my_temp_index\n{\n    \"settings\": {\n        \"number_of_shards\" :   1,\n        \"number_of_replicas\" : 0\n    }\n}\n```\n\n#### 配置分析器\n\nstandard 分析器是用于全文字段的默认分析器，包含以下部分：\n\n- standard 分词器，通过单词边界分割输入的文本。\n- standard 语汇单元过滤器，目的是整理分词器触发的语汇单元（但是目前什么都没做）。\n- lowercase 语汇单元过滤器，转换所有的语汇单元为小写。\n- stop 语汇单元过滤器，删除停用词—对搜索相关性影响不大的常用词，如 a、the、and、is。\n\n在下面的例子中，创建了一个新的分析器 es_std，并使用预定义的西班牙语停用词列表。\n\n```bash\nPUT /spanish_docs\n{\n    \"settings\": {\n        \"analysis\": {\n            \"analyzer\": {\n                \"es_std\": {\n                    \"type\":      \"standard\",\n                    \"stopwords\": \"_spanish_\"\n                }\n            }\n        }\n    }\n}\n```\n\n进行测试：\n\n```bash\ncurl -X GET \"localhost:9200/spanish_docs/_analyze?analyzer=es_std&pretty\" -H \'Content-Type: application/json\' -d\'\nEl veloz zorro marrón\n\'\n```\n\n通过结果进行查看：\n\n```json\n{\n  \"tokens\" : [\n    { \"token\" :    \"veloz\",   \"position\" : 2 },\n    { \"token\" :    \"zorro\",   \"position\" : 3 },\n    { \"token\" :    \"marrón\",  \"position\" : 4 }\n  ]\n}\n```\n\n#### 自定义分析器\n\n在 analysis 下的相应位置设置字符过滤器，分词过滤器，词单元过滤器。\n\n```bash\nPUT /my_index\n{\n    \"settings\": {\n        \"analysis\": {\n            \"char_filter\": { ... custom character filters ... },\n            \"tokenizer\":   { ...    custom tokenizers     ... },\n            \"filter\":      { ...   custom token filters   ... },\n            \"analyzer\":    { ...    custom analyzers      ... }\n        }\n    }\n}\n```\n\n接着创建一个自定义分析器，用于清楚 html 部分，将 & 映射为 and：\n\n```json\n\"char_filter\": {\n    \"&_to_and\": {\n        \"type\":       \"mapping\",\n        \"mappings\": [ \"&=> and \"]\n    }\n}\n```\n\n使用标准分词器讽刺，小写词条使用小写过滤，使用自定义停止词过滤器移除自定义的停止词列表中包含的词。\n\n```json\n\"filter\": {\n    \"my_stopwords\": {\n        \"type\":        \"stop\",\n        \"stopwords\": [ \"the\", \"a\" ]\n    }\n}\n```\n\n最后使用分析器，自定义组合过滤器和分词器。\n\n```json\n\"analyzer\": {\n    \"my_analyzer\": {\n        \"type\":           \"custom\",\n        \"char_filter\":  [ \"html_strip\", \"&_to_and\" ],\n        \"tokenizer\":      \"standard\",\n        \"filter\":       [ \"lowercase\", \"my_stopwords\" ]\n    }\n}\n```\n\n总和如下所示：\n\n```bash\ncurl -X PUT \"localhost:9200/my_index?pretty\" -H \'Content-Type: application/json\' -d\'\n{\n    \"settings\": {\n        \"analysis\": {\n            \"char_filter\": {\n                \"&_to_and\": {\n                    \"type\":       \"mapping\",\n                    \"mappings\": [ \"&=> and \"]\n            }},\n            \"filter\": {\n                \"my_stopwords\": {\n                    \"type\":       \"stop\",\n                    \"stopwords\": [ \"the\", \"a\" ]\n            }},\n            \"analyzer\": {\n                \"my_analyzer\": {\n                    \"type\":         \"custom\",\n                    \"char_filter\":  [ \"html_strip\", \"&_to_and\" ],\n                    \"tokenizer\":    \"standard\",\n                    \"filter\":       [ \"lowercase\", \"my_stopwords\" ]\n            }}\n}}}\n\'\n```\n\n测试一下：\n\n```bash\ncurl -X GET \"localhost:9200/my_index/_analyze?analyzer=my_analyzer&pretty\" -H \'Content-Type: application/json\' -d\'\nThe quick & brown fox\n\'\n```\n\n可以看到结果如下所示：\n\n```json\n{\n  \"tokens\" : [\n      { \"token\" :   \"quick\",    \"position\" : 2 },\n      { \"token\" :   \"and\",      \"position\" : 3 },\n      { \"token\" :   \"brown\",    \"position\" : 4 },\n      { \"token\" :   \"fox\",      \"position\" : 5 }\n    ]\n}\n```\n\n最后，把这个分词器用在 string 字段上：\n\n```bash\ncurl -X PUT \"localhost:9200/my_index/_mapping/my_type?pretty\" -H \'Content-Type: application/json\' -d\'\n{\n    \"properties\": {\n        \"title\": {\n            \"type\":      \"string\",\n            \"analyzer\":  \"my_analyzer\"\n        }\n    }\n}\n\'\n```\n\n#### 类型和映射\n\n##### Lucene 如何处理文档\n\n在 Lucene 中一个文档由键值对组成。在索引文档的时候，每个字段的值都会添加到相关字段的倒排序中。\n\n##### 类型如何实现\n\n每个文档的类型名称将会保存在 _type 字段上，当要检索字段的时候，ES 会自动在 _type 字段上检索。\n\n例如在 User 类型中，name 字段会映射声明为 string 类型，并索引到 name 的倒排序中，需要使用 whitespace 分词器分析。\n\n```json\n\"name\": {\n    \"type\":     \"string\",\n    \"analyzer\": \"whitespace\"\n}\n```\n\n##### Lucene 索引的每个字段都包含一个单一的扁平的模式\n\n在 Lucene 中，一个特定的字段可以映射到 string 类型或者是 number 类型，但是不能两者兼具。因为 ES 添加的优于 lucene 的额外机制（以元数据 _type 字段的形式。）在 ES 中所有类型都最终共享相同的映射。\n\n```json\n{\n   \"data\": {\n      \"mappings\": {\n         \"people\": {\n            \"properties\": {\n               \"name\": {\n                  \"type\": \"string\",\n               },\n               \"address\": {\n                  \"type\": \"string\"\n               }\n            }\n         },\n         \"transactions\": {\n            \"properties\": {\n               \"timestamp\": {\n                  \"type\": \"date\",\n                  \"format\": \"strict_date_optional_time\"\n               },\n               \"message\": {\n                  \"type\": \"string\"\n               }\n            }\n         }\n      }\n   }\n}\n```\n\n在上方中，`\"name\"/\"address\"` 和 `\"timestamp\"/\"message\"` 虽然是独立的，但是在 Lucene 中是一个映射。\n\n```json\n{\n   \"data\": {\n      \"mappings\": {\n        \"_type\": {\n          \"type\": \"string\",\n          \"index\": \"not_analyzed\"\n        },\n        \"name\": {\n          \"type\": \"string\"\n        }\n        \"address\": {\n          \"type\": \"string\"\n        }\n        \"timestamp\": {\n          \"type\": \"long\"\n        }\n        \"message\": {\n          \"type\": \"string\"\n        }\n      }\n   }\n}\n```\n\n对于整个索引，映射在本质上被 扁平化 成一个单一的、全局的模式。\n\n### Java 连接 ES\n\n添加依赖：\n\n```xml\n<!-- TransportClient 依赖包-->\n        <dependency>\n            <groupId>org.elasticsearch.client</groupId>\n            <artifactId>transport</artifactId>\n            <version>6.2.2</version>\n        </dependency>\n\n        <!-- 测试包，与 JAVA 连接 ES 无关 -->\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n            <scope>test</scope>\n        </dependency>\n```\n\n创建 ES 集群：\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/f8f185b0-cee6-11eb-81e7-cb4b73a5fa4f.png)\n\n连接 ES：\n\n```java\npackage cn.zsm.es;\n\nimport org.elasticsearch.client.transport.TransportClient;\nimport org.elasticsearch.common.settings.Settings;\nimport org.elasticsearch.common.transport.TransportAddress;\nimport org.elasticsearch.transport.client.PreBuiltTransportClient;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class JavaEsTest {\n\n    private String IP;\n    private int PORT;\n\n    @Before\n    public void init(){\n        this.IP = \"192.168.？.？\";\n        this.PORT = 9300;\n    }\n\n    @Test\n    public void esClient(){\n        try {\n            Settings settings = Settings.builder().put(\"cluster.name\", \"my-application\").build();\n            TransportClient client = new PreBuiltTransportClient(settings)\n                    .addTransportAddresses(new TransportAddress(InetAddress.getByName(IP), PORT));\n            System.out.println(client.toString());\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n```\n\n测试结果：\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/1053b2a0-cee7-11eb-a372-c3e5da0127b2.png)\n\n### 总结\n\n在本场 Chat 中介绍了什么是 ES，以及 ES 的查询、ES 的索引，最后通过 Java 语言连接了 ES。', '![ElasticSearch 小白从入门到精通](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.png)', b'1', b'1', b'0', b'1', '2024-12-20 16:55:01', '2024-12-23 10:04:43', 8, 2643, 13, 10, b'1', '', 1);
INSERT INTO `blog` VALUES (7, 'Docker 镜像构建原理及源码分析', 'https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/engine-components-flow.png', '### Docker 架构\n\n这里我们先从宏观上对 `Docker` 有个大概的认识，就像我[之前]提到的它整体上是个 C/S 架构；我们平时使用的 `docker` 命令就是它的 CLI 客户端，而它的服务端是 `dockerd` 在 Linux 系统中，通常我们是使用 `systemd` 进行管理，所以我们可以使用 `systemctl start docker` 来启动服务。（但是请注意，`dockerd` 是否能运行与 `systemd` 并无任何关系，你可以像平时执行一个普通的二进制程序一样，直接通过 `dockerd` 来启动服务，注意需要 root 权限）\n\n实际上也就是\n\n![Docker 架构](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/engine-components-flow.png)\n\n(图片来源：docker overview)\n\n`docker` CLI 与 `dockerd` 的交互是通过 rest API 来完成的，当我们执行 `docker version` 的时候过滤 API 可以看到如下输出：\n\n```yaml\n# docker version  |grep API\n API version:       1.40\n API version:      1.40 (minimum version 1.12)\n```\n\n上面一行是 `docker` CLI 的 API 版本，下面则代表了 `dockerd` 的 API 版本，它的后面还有个括号，是因为 Docker 具备了很良好的兼容性，这里表示它最小可兼容的 API 版本是 1.12 。\n\n对于我们进行 C/S 架构的项目开发而言，一般都是 API 先行, 所以我们先来看下 API 的部分。\n\n当然，本次 Chat 的主体是构建系统相关的，所以我们就直接来看构建相关的 API 即可。\n\n接下来会说 CLI，代码以 v19.03.0-rc2-4-ga63faebc 为准。\n\n最后说服务端 Dockerd 。\n\n### API\n\nDocker 官方在每个版本正式发布之后，都会将 API 文档发布出来，在线地址是  但由于现在 19.03 还未发布，所以 1.40 版本的 API 文档也尚未正式发布。\n\n1.39 和 1.40 中，关于镜像构建部分的 API 其实没太大变化，所以直接参考 1.39 版本的 API 文档看也可以。或者我们也可以自行构建 API 文档。\n\n首先 clone Docker 的源代码仓库, 进入项目仓库内执行 `make swagger-docs` 即可在启动一个容器同时将端口暴露至本地的 `9000` 端口， 你可以直接通过  访问本地的 API 文档。\n\n```bash\n(MoeLove) ➜  git clone https://github.com/docker/engine.git docker\n(MoeLove) ➜  cd docker\n(MoeLove) ➜  docker git:(master) git checkout -b v19.03.0-rc2 v19.03.0-rc2\n(MoeLove) ➜  docker git:(v19.03.0-rc2) make swagger-docs\nAPI docs preview will be running at http://localhost:9000\n```\n\n打开  这个地址就可以看到 1.40 版本的构建镜像所需的 API 了。我们对此 API 进行下分析。\n\n#### 请求地址和方法\n\n接口地址是 `/v1.40/build` 方法是 `POST`\n\n我们可以使用一个较新版本的 `curl` 工具来验证下此接口（需要使用 `--unix-socket` 连接 Docker 监听的 UNIX Domain Socket ）\n\n`/var/run/docker.sock` 这是默认情况下 `dockerd` 所监听的地址，当然你也可以给 `dockerd` 传递 `--host` 参数用于监听 HTTP 端口或者其他路径的 unix socket .\n\n```bash\n/ # curl -X POST --unix-socket /var/run/docker.sock  localhost/v1.40/build \n{\"message\":\"Cannot locate specified Dockerfile: Dockerfile\"}\n```\n\n从上面的输出我们可以看到，我们确实访问到了该接口，同时该接口的响应是提示需要 `Dockerfile` .\n\n#### 请求体\n\n> A tar archive compressed with one of the following algorithms: identity (no compression), gzip, bzip2, xz. string\n\n请求体是一个 `tar` 归档文件，可选择无压缩、`gzip`、`bzip2`、`xz` 压缩等形式。关于这几种压缩格式就不再展开介绍了，但值得注意的是 **如果使用了压缩，则传输体积会变小，即网络消耗会相应减少。但压缩/解压缩需要耗费 CPU 等计算资源** 这在我们对大规模镜像构建做优化时是个值得权衡的点。\n\n#### 请求头\n\n因为要发送的是个 `tar` 归档文件，`Content-type` 默认是 `application/x-tar` 。\n\n另一个会发送的头是 `X-Registry-Config`，这是一个由 Base64 编码后的 Docker Registry 的配置信息，内容与 `$HOME/.docker/config.json` 中的 `auths` 内的信息一致。\n\n这些配置信息，在你执行 `docker login` 后会自动写入到 `$HOME/.docker/config.json` 文件内的。这些信息被传输到 `dockerd` 在构建过程中作为拉取镜像的认证信息使用。\n\n### 请求参数\n\n最后就是请求参数了，参数有很多，通过 `docker build --help` 基本都可以看到对应含义的，这里不再一一展开了，后面会有一些关键参数的介绍。\n\n#### 小结\n\n上面我们介绍了 `Docker` 构建镜像相关的 API，我们可以通过在线地址  访问旧版本的 API，待新版本发布后，就可以访问新版本 API 文档了。或者通过源码仓库，自己来构建一个本地的 API 文档服务，使用浏览器进行访问。\n\n通过 API 我们也知道了该接口所需的请求体是一个 `tar` 归档文件（可选择压缩算法进行压缩），同时它的请求头中会携带用户在镜像仓库中的认证信息。\n\n这提醒我们， **如果在使用远程 Dockerd 构建时，请注意安全，尽量使用 tls 进行加密，以免数据泄漏。**\n\n### CLI\n\nAPI 已经介绍完了，我们来看下 `docker` CLI，在我们前两次的 Chat中，我们聊过现在 Docker 中有两个构建系统，一个是 v1 版本的 `builder` 另一个是 v2 版本的即 `buildkit` 我们来分别深入源码来看看在构建镜像时，他们各自的行为吧。\n\n#### 准备代码\n\nCLI 的代码仓库在  本次 Chat 的代码以 `v19.03.0-rc2-4-ga63faebc` 为准。\n\n通过以下步骤使用此版本的代码：\n\n```bash\n(MoeLove) ➜  git clone https://github.com/docker/cli.git\n(MoeLove) ➜  cd cli\n(MoeLove) ➜  cli git:(master) git checkout -b v19.03 v19.03.0-rc2-4-ga63faebc\n```\n\n#### 逐步分解\n\n`docker` 是我们所使用的客户端工具，用于与 `dockerd` 进行交互。关于构建相关的部分， 我们所熟知的便是 `docker build` 或者是 `docker image build`，在 19.03 中新增的是 `docker builder build` ，但其实他们都是同一个只是做了个 alias 罢了：\n\n```go\n// cmd/docker/docker.go#L231\n\nif v, ok := aliasMap[\"builder\"]; ok {\n    aliases = append(aliases,\n        [2][]string{{\"build\"}, {v, \"build\"}},\n        [2][]string{{\"image\", \"build\"}, {v, \"build\"}},\n    )\n}\n```\n\n真正的入口函数其实在 `cli/command/image/build.go` ；区分如何调用的逻辑如下：\n\n```go\nfunc runBuild(dockerCli command.Cli, options buildOptions) error {\n    buildkitEnabled, err := command.BuildKitEnabled(dockerCli.ServerInfo())\n    if err != nil {\n        return err\n    }\n    if buildkitEnabled {\n        return runBuildBuildKit(dockerCli, options)\n    }\n    // 省略掉了对于 builder 的实际逻辑\n}\n```\n\n这里就是判断下是否支持 `buildkit`\n\n```go\n// cli/command/cli.go#L151\nfunc BuildKitEnabled(si ServerInfo) (bool, error) {\n    buildkitEnabled := si.BuildkitVersion == types.BuilderBuildKit\n    if buildkitEnv := os.Getenv(\"DOCKER_BUILDKIT\"); buildkitEnv != \"\" {\n        var err error\n        buildkitEnabled, err = strconv.ParseBool(buildkitEnv)\n        if err != nil {\n            return false, errors.Wrap(err, \"DOCKER_BUILDKIT environment variable expects boolean value\")\n        }\n    }\n    return buildkitEnabled, nil\n}\n```\n\n当然，从这里可以得到两个信息：\n\n- 通过`dockerd`的配置可开启`buildkit`。在`/etc/docker/daemon.json`中添加如下内容，并重启`dockerd`即可：\n\n```json\n{\n  \"features\": {\n    \"buildkit\": true\n  }\n}\n```\n\n- 在`docker`CLI 上也可开启`buildkit`的支持，并且 CLI 的配置可覆盖服务端配置:\n\n通过 `export DOCKER_BUILDKIT=1` 即可开启 `buildkit` 的支持，设置为 0 则关闭（0/false/f/F 之类的也都是相同的结果）\n\n从上面的介绍也看到了，对于原本默认的 builder 而言， 入口逻辑在 `runBuild` 中， 而对于使用 buildkit 的则是 `runBuildBuildKit` 接下来，我们对两者进行逐步分解。\n\n### builder v1\n\n在 `runBuild` 函数中，大致经历了以下阶段：\n\n#### 参数处理\n\n最开始的部分是一些对参数的处理和校验。\n\n- **stream 和 compress 不可同时使用。**\n\n因为如果我们指定了 `compress` 的话，则 CLI 会使用 `gzip` 将构建上下文进行压缩，这样也就没法很好的通过 `stream` 的模式来处理构建的上下文了。\n\n当然你也可能会想，从技术上来讲，压缩和流式没有什么必然的冲突，是可实现的。事实的确如此，如果从技术的角度上来讲两者并非完全不能一起存在，无非就是增加解压缩的动作。但是当开启 `stream` 模式，对每个文件都进行压缩和解压的操作那将会是很大的资源浪费，同时也增加了其复杂度，所以在 CLI 中便直接进行了限制，不允许同时使用 `compress` 和 `stream`\n\n- **不可同时使用 stdin 读取 Dockerfile 和 build context。**\n\n在进行构建时，如果我们将 `Dockerfile` 的名字传递为 `-` 时，表示从 `stdin` 读取其内容。\n\n例如，某个目录下有三个文件 `foo` `bar` 和 `Dockerfile`，通过管道将 `Dockerfile` 的内容通过 `stdin` 传递给 `docker build`\n\n```bash\n(MoeLove) ➜  x ls\nbar  Dockerfile  foo\n(MoeLove) ➜  x cat Dockerfile | DOCKER_BUILDKIT=0 docker build -f - .\nSending build context to Docker daemon  15.41kB\nStep 1/3 : FROM scratch\n ---> \nStep 2/3 : COPY foo foo\n ---> a2af45d66bb5\nStep 3/3 : COPY bar bar\n ---> cc803c675dd2\nSuccessfully built cc803c675dd2\n```\n\n可以看到通过 `stdin` 传递 `Dockerfile` 的方式能成功的构建镜像。接下来我们尝试通过 `stdin` 将 `build context` 传递进去。\n\n```bash\n(MoeLove) ➜  x tar -cvf x.tar foo bar Dockerfile \nfoo                                                     \nbar                         \nDockerfile\n(MoeLove) ➜  x cat x.tar| DOCKER_BUILDKIT=0 docker build -f Dockerfile -\nSending build context to Docker daemon  10.24kB\nStep 1/3 : FROM scratch\n ---> \nStep 2/3 : COPY foo foo\n ---> 09319712e220\nStep 3/3 : COPY bar bar\n ---> ce88644a7395\nSuccessfully built ce88644a7395\n```\n\n可以看到通过 `stdin` 传递 `build context` 的方式也可以成功构建镜像。\n\n但如果 `Dockerfile` 的名称与构建的上下文都指定为 `-` 即 `docker build -f - -` 时，会发生什么呢？\n\n```bash\n(MoeLove) ➜  x DOCKER_BUILDKIT=0 docker build -f - -             \ninvalid argument: can\'t use stdin for both build context and dockerfile\n```\n\n就会报错了。所以， **不能同时使用 stdin 读取 Dockerfile 和 build context** 。\n\n- **build context 支持四种行为。**\n\n```go\nswitch {\ncase options.contextFromStdin():\n    // 省略\ncase isLocalDir(specifiedContext):\n    // 省略\ncase urlutil.IsGitURL(specifiedContext):\n    // 省略\ncase urlutil.IsURL(specifiedContext):\n    // 省略\ndefault:\n    return errors.Errorf(\"unable to prepare context: path %q not found\", specifiedContext)\n}\n```\n\n从 `stdin` 传入，上文已经演示过了，传递给 `stdin` 的是 `tar` 归档文件；\n\n当然也可以是指定一个具体的 `PATH`，我们通常使用的 `docker build .` 便是这种用法；\n\n或者可以指定一个 `git` 仓库的地址，CLI 会调用 `git` 命令将仓库 `clone` 至一个临时目录，进行使用；\n\n最后一种是，给定一个 `URL` 地址，该地址可以是 **一个具体的 Dockerfile 文件地址** 或者是 **一个 tar 归档文件的下载地址** 。\n\n这几种基本就是字面上的区别，至于 CLI 的行为差异，主要是最后一种，当 `URL` 地址是一个具体的 `Dockerfile` 文件地址，在这种情况下 `build context` 相当于只有 `Dockerfile` 自身，所以并不能使用 `COPY` 之类的指定，至于 `ADD` 也只能使用可访问的外部地址。\n\n- **可使用 .dockerignore 忽略不需要的文件**\n\n我在之前的 Chat [高效构建 Docker 镜像的最佳实践] 中有分享过相关的内容。这里我们看看它的实现逻辑。\n\n```go\n// cli/command/image/build/dockerignore.go#L13\nfunc ReadDockerignore(contextDir string) ([]string, error) {\n    var excludes []string\n\n    f, err := os.Open(filepath.Join(contextDir, \".dockerignore\"))\n    switch {\n    case os.IsNotExist(err):\n        return excludes, nil\n    case err != nil:\n        return nil, err\n    }\n    defer f.Close()\n\n    return dockerignore.ReadAll(f)\n}\n```\n\n- `.dockerignore`是一个固定的文件名，并且需要放在`build context`的根目录下。类似前面提到的，使用一个`Dockerfile`文件的 URL 地址作为`build context`传入的方式，便无法使用`.dockerignore`。\n- `.dockerignore`文件可以不存在，但在读取的时候如果遇到错误，便会抛出错误。\n- 通过`.dockerignore`将会过滤掉不希望加入到镜像内，或者过滤掉与镜像无关的内容。\n\n最后 CLI 会将 `build context` 中的内容经过 `.dockerignore` 过滤后，打包成为真正的 `build context` 即真正的构建上下文。这也是为什么有时候你发现自己明明在 `Dockerfile` 里面写了 `COPY xx xx` 但是最后没有发现该文件的情况。 很可能就是被 `.dockerignore` 给忽略掉了。\n\n这样有利于优化 CLI 与 `dockerd` 之间的传输压力之类的。\n\n- `docker`CLI 还会去读取`~/.docker/config.json`中的内容。\n\n这与前面 API 部分所描述的内容基本是一致的。将认证信息通过 `X-Registry-Config` 头传递给 `dockerd` 用于在需要拉取镜像时进行身份校验。\n\n- **调用 API 进行实际构建任务**\n\n当一切所需的校验和信息都准备就绪之后，则开始调用 `dockerCli.Client` 封装的 API 接口，将请求发送至 `dockerd`，进行实际的构建任务。\n\n```go\nresponse, err := dockerCli.Client().ImageBuild(ctx, body, buildOptions)\nif err != nil {\n    if options.quiet {\n        fmt.Fprintf(dockerCli.Err(), \"%s\", progBuff)\n    }\n    cancel()\n    return err\n}\ndefer response.Body.Close()\n```\n\n到这里其实一次构建的过程中 CLI 所处理的流程就基本结束了，之后便是按照传递的参数进行进度的输出或是将镜像 ID 写入到文件之类的。 这部分就不进行展开了。\n\n#### 小结\n\n整个过程大致如下图：\n\n![docker builder 处理流程](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/6a69dde0-933a-11e9-8825-e7da71af5ddb.png)\n\n从入口函数 `runBuild` 开始，经过判断是否支持 `buildkit` ，如果不支持 `buildkit` 则继续使用 v1 的 `builder`。接下来读取各类参数，按照不同的参数执行各类不同的处理逻辑。这里需要注意的就是 `Dockerfile` 及 `build context` 都可支持从文件或者 `stdin` 等读入，具体使用时，需要注意。\n\n另外 `.dockerignore` 文件可过滤掉 `build context` 中的一些文件，在使用时，可通过此方法进行构建效率的优化，当然也需要注意，在通过 URL 获取 `Dockerfile` 的时候，是不存在 `build context` 的，所以类似 `COPY` 这样的命令也就无法使用了。\n\n当所有的 `build context` 和参数都准备就绪后，接下来调用封装好的客户端，将这些请求按照本文开始之初介绍的 API 发送给 `dockerd` ，由其进行真正的构建逻辑。\n\n最后当构建结束后，CLI 根据参数决定是否要显示构建进度或者结果。\n\n### buildkit\n\n接下来我们来看看 `buildkit` 如何来执行构建，方法入口与 `builder` 一致，但是在 `buildkitEnabled` 处，由于开启了 `buildkit` 支持，所以跳转到了 `runBuildBuildKit`。\n\n```go\nfunc runBuild(dockerCli command.Cli, options buildOptions) error {\n    buildkitEnabled, err := command.BuildKitEnabled(dockerCli.ServerInfo())\n    if err != nil {\n        return err\n    }\n    if buildkitEnabled {\n        return runBuildBuildKit(dockerCli, options)\n    }\n    // 省略掉了对于 builder 的实际逻辑\n}\n```\n\n#### 创建会话\n\n但是与 `builder` 不同的是，这里先执行了一次 `trySession` 函数。\n\n```go\n// cli/command/image/build_buildkit.go#L48\ns, err := trySession(dockerCli, options.context, false)\nif err != nil {\n    return err\n}\nif s == nil {\n    return errors.Errorf(\"buildkit not supported by daemon\")\n}\n```\n\n这个函数是用来做什么的呢？我们来找到该函数所在的文件 `cli/command/image/build_session.go`\n\n```go\n// cli/command/image/build_session.go#L37\nfunc trySession(dockerCli command.Cli, contextDir string, forStream bool) (*session.Session, error) {\n    var s *session.Session\n    if isSessionSupported(dockerCli, forStream) {\n        sharedKey, err := getBuildSharedKey(contextDir)\n        if err != nil {\n            return nil, errors.Wrap(err, \"failed to get build shared key\")\n        }\n        s, err = session.NewSession(context.Background(), filepath.Base(contextDir), sharedKey)\n        if err != nil {\n            return nil, errors.Wrap(err, \"failed to create session\")\n        }\n    }\n    return s, nil\n}\n```\n\n当然还包括它其中最主要的 `isSessionSupported` 函数：\n\n```go\n// cli/command/image/build_session.go#L30\nfunc isSessionSupported(dockerCli command.Cli, forStream bool) bool {\n    if !forStream && versions.GreaterThanOrEqualTo(dockerCli.Client().ClientVersion(), \"1.39\") {\n        return true\n    }\n    return dockerCli.ServerInfo().HasExperimental && versions.GreaterThanOrEqualTo(dockerCli.Client().ClientVersion(), \"1.31\")\n}\n```\n\n`isSessionSupported` 很明显是用于判断是否支持 `Session`，这里由于我们会传入 `forStream` 为 `false` ，而且当前的 API 版本是 1.40 比 1.39 大，所以此函数会返回 `true` 。其实在 `builder` 中也执行过相同的逻辑，只不过是在传递了 `--stream` 参数后，使用 `Session` 获取一个长连接以达到 `stream` 的处理能力。\n\n这也就是为什么会有下面 `dockerCli.ServerInfo().HasExperimental && versions.GreaterThanOrEqualTo(dockerCli.Client().ClientVersion(), \"1.31\")` 这个判断存在的原因了。\n\n当确认支持 `Session` 时，则会调用 `session.NewSession` 创建一个新的会话。\n\n```go\n// github.com/moby/buildkit/session/session.go#L45\nfunc NewSession(ctx context.Context, name, sharedKey string) (*Session, error) {\n    id := identity.NewID()\n\n    serverOpts := []grpc.ServerOption{}\n    if span := opentracing.SpanFromContext(ctx); span != nil {\n        tracer := span.Tracer()\n        serverOpts = []grpc.ServerOption{\n            grpc.StreamInterceptor(otgrpc.OpenTracingStreamServerInterceptor(span.Tracer(), traceFilter())),\n            grpc.UnaryInterceptor(otgrpc.OpenTracingServerInterceptor(tracer, traceFilter())),\n        }\n    }\n\n    s := &Session{\n        id:         id,\n        name:       name,\n        sharedKey:  sharedKey,\n        grpcServer: grpc.NewServer(serverOpts...),\n    }\n\n    grpc_health_v1.RegisterHealthServer(s.grpcServer, health.NewServer())\n\n    return s, nil\n}\n```\n\n它创建了一个长连接会话，接下来的操作也都会基于这个会话来做。\n\n接下来的操作与 `builder` 大体一致，先判断 `context` 是以哪种形式提供的；当然它也与 `builder` 一样，是不允许同时从 `stdin` 获取 `Dockerfile` 和 `build context` 。\n\n```go\nswitch {\ncase options.contextFromStdin():\n    // 省略处理逻辑\ncase isLocalDir(options.context):\n    // 省略处理逻辑\ncase urlutil.IsGitURL(options.context):\n    // 省略处理逻辑\ncase urlutil.IsURL(options.context):\n    // 省略处理逻辑\ndefault:\n    return errors.Errorf(\"unable to prepare context: path %q not found\", options.context)\n}\n```\n\n这里的处理逻辑与 v1 `builder` 保持一致的原因，主要在于用户体验上，当前的 CLI 的功能已经基本稳定，用户也已经习惯，所以即使是增加了 `buildkit` 也并没有对主体的操作逻辑造成多大改变。\n\n#### 选择输出模式\n\n`buildkit` 支持了三种不同的输出模式 `local` `tar` 和正常模式（即存储在 `dockerd` 中）， 格式为 `-o type=local,dest=path` 如果需要将构建的镜像进行分发，或是需要进行镜像内文件浏览的话，使用这个方式也是很方便的。\n\n```go\noutputs, err := parseOutputs(options.outputs)\nif err != nil {\n    return errors.Wrapf(err, \"failed to parse outputs\")\n}\n\nfor _, out := range outputs {\n    switch out.Type {\n    case \"local\":\n        // 省略\n    case \"tar\":\n        // 省略\n    }\n}\n```\n\n**其实它支持的模式还有第 4 种， 名为 cacheonly 但它并不会像前面提到的三种模式一样，有个很直观的输出，而且用的人可能会很少，所以就没有单独写了。**\n\n#### 读取认证信息\n\n```go\ns.Allow(authprovider.NewDockerAuthProvider(os.Stderr))\n```\n\n这里的行为与上面提到的 `builder` 的行为基本一致，这里主要有两个需要注意的点：\n\n- Allow() 函数\n\n```go\nfunc (s *Session) Allow(a Attachable) {\n    a.Register(s.grpcServer)\n}\n```\n\n这个 `Allow` 函数就是允许通过上面提到的 grpc 会话访问给定的服务。\n\n- `authprovider`\n\n`authprovider` 是 `buildkit` 提供的一组抽象接口集合，通过它们可以访问到机器上的配置文件，进而拿到认证信息，行为与 `builder` 基本一致。\n\n#### 高阶特性：secrets 和 ssh\n\n在前一篇 Chat  我已经讲过这两种高阶特性的使用了，本篇中就不再多使用进行过多说明了，只来大体看下该部分的原理和逻辑。\n\n`secretsprovider` 和 `sshprovider` 都是 `buildkit` 在提供的，利用这两种特性可以在 Docker 镜像进行构建时更加安全，且更加灵活。\n\n```go\nfunc parseSecretSpecs(sl []string) (session.Attachable, error) {\n    fs := make([]secretsprovider.FileSource, 0, len(sl))\n    for _, v := range sl {\n        s, err := parseSecret(v)\n        if err != nil {\n            return nil, err\n        }\n        fs = append(fs, *s)\n    }\n    store, err := secretsprovider.NewFileStore(fs)\n    if err != nil {\n        return nil, err\n    }\n    return secretsprovider.NewSecretProvider(store), nil\n}\n```\n\n关于 `secrets` 方面，最终的 `parseSecret` 会完成格式相关的校验之类的；\n\n```go\nfunc parseSSHSpecs(sl []string) (session.Attachable, error) {\n    configs := make([]sshprovider.AgentConfig, 0, len(sl))\n    for _, v := range sl {\n        c, err := parseSSH(v)\n        if err != nil {\n            return nil, err\n        }\n        configs = append(configs, *c)\n    }\n    return sshprovider.NewSSHAgentProvider(configs)\n}\n```\n\n而关于 `ssh` 方面，则与上方的 `secrets` 基本一致，通过 `sshprovider` 允许进行 ssh 转发之类的，这里不再深入展开了。\n\n#### 调用 API 发送构建请求\n\n这里主要有两种情况。\n\n- 当`build context`是从`stdin`读，并且是一个`tar`文件时\n\n```go\nbuildID := stringid.GenerateRandomID()\nif body != nil {\n    eg.Go(func() error {\n        buildOptions := types.ImageBuildOptions{\n            Version: types.BuilderBuildKit,\n            BuildID: uploadRequestRemote + \":\" + buildID,\n        }\n\n        response, err := dockerCli.Client().ImageBuild(context.Background(), body, buildOptions)\n        if err != nil {\n            return err\n        }\n        defer response.Body.Close()\n        return nil\n    })\n}\n```\n\n它会执行这部分逻辑，但同时也要注意，这是使用的是 Golang 的 `goroutine`，到这里也并不是结束，这部分代码之后的代码也同样会被执行。这就说到了另一种情况了(通常情况)。\n\n- 使用`doBuild`完成逻辑\n\n```go\neg.Go(func() error {\n    defer func() {\n        s.Close()\n    }()\n\n    buildOptions := imageBuildOptions(dockerCli, options)\n    buildOptions.Version = types.BuilderBuildKit\n    buildOptions.Dockerfile = dockerfileName\n    buildOptions.RemoteContext = remote\n    buildOptions.SessionID = s.ID()\n    buildOptions.BuildID = buildID\n    buildOptions.Outputs = outputs\n    return doBuild(ctx, eg, dockerCli, stdoutUsed, options, buildOptions)\n})\n```\n\n那 `doBuild` 会做些什么呢？它同样也调用了 API 向 `dockerd` 发起了构建请求。\n\n```go\nfunc doBuild(ctx context.Context, eg *errgroup.Group, dockerCli command.Cli, stdoutUsed bool, options buildOptions, buildOptions types.ImageBuildOptions) (finalErr error) {\n    response, err := dockerCli.Client().ImageBuild(context.Background(), nil, buildOptions)\n    if err != nil {\n        return err\n    }\n    // 省略\n}\n```\n\n从以上的介绍我们可以先做个小的总结。 **当 build context 从 stdin 读，并且是个 tar 归档时，实际会向 dockerd 发起两次 /build 请求** 而一般情况下只会发送一次请求。\n\n那这里会有什么差别呢？此处先不展开，我们留到下面讲 `dockerd` 后端的时候再来解释。\n\n#### 小结\n\n这里我们对开启了 `buildkit` 支持的 CLI 构建镜像的过程进行了分析，大致过程如下：\n\n从入口函数 `runBuild` 开始，判断是否支持 `buildkit` ，如果支持 `buildkit` 则调用 `runBuildBuildKit`。与 v1 的 `builder` 不同的是，开启了 `buildkit` 后，会首先创建一个长连接的会话，并一直保持。\n\n其次，与 `builder` 相同，判断 `build context` 的来源，格式之类的，校验参数等。当然，`buildkit` 支持三种不同的输出格式 `tar`, `local` 或正常的存储于 Docker 的目录中。\n\n另外是在 `buildkit` 中新增的高阶特性，可以配置 `secrets` 和 `ssh` 密钥等功能。\n\n最后，再调用 API 与 `dockerd` 交互完成镜像的构建。\n\n### 服务端：dockerd\n\n上面分别介绍了 API， CLI 的 v1 `builder` 和 `buildkit` ，接下来我们看看服务端的具体原理和逻辑。\n\n#### Client 函数\n\n还记得上面部分中最后通过 API 与服务端交互的 `ImageBuild` 函数吗？在开始 `dockerd` 的介绍前，我们来看下这个客户端接口的具体内容。\n\n```go\n// github.com/docker/docker/client/image_build.go#L21\nfunc (cli *Client) ImageBuild(ctx context.Context, buildContext io.Reader, options types.ImageBuildOptions) (types.ImageBuildResponse, error) {\n    query, err := cli.imageBuildOptionsToQuery(options)\n    if err != nil {\n        return types.ImageBuildResponse{}, err\n    }\n\n    headers := http.Header(make(map[string][]string))\n    buf, err := json.Marshal(options.AuthConfigs)\n    if err != nil {\n        return types.ImageBuildResponse{}, err\n    }\n    headers.Add(\"X-Registry-Config\", base64.URLEncoding.EncodeToString(buf))\n\n    headers.Set(\"Content-Type\", \"application/x-tar\")\n\n    serverResp, err := cli.postRaw(ctx, \"/build\", query, buildContext, headers)\n    if err != nil {\n        return types.ImageBuildResponse{}, err\n    }\n\n    osType := getDockerOS(serverResp.header.Get(\"Server\"))\n\n    return types.ImageBuildResponse{\n        Body:   serverResp.body,\n        OSType: osType,\n    }, nil\n}\n```\n\n没有什么太特别的地方，行为与 API 一致。 通过这里我们确认它确实访问的 `/build` 接口，所以，我们来看看 `dockerd` 的 `/build` 接口，看看它在构建镜像的时候做了什么。\n\n#### dockerd\n\n由于本次 Chat 集中讨论的是构建系统相关的部分，所以也就不再过多赘述与构建无关的内容了，我们直接来看，当 CLI 通过 `/build` 接口发送请求后，会发生什么。\n\n先来看该 API 的入口：\n\n```go\n// api/server/router/build/build.go#L32\nfunc (r *buildRouter) initRoutes() {\n    r.routes = []router.Route{\n        router.NewPostRoute(\"/build\", r.postBuild),\n        router.NewPostRoute(\"/build/prune\", r.postPrune),\n        router.NewPostRoute(\"/build/cancel\", r.postCancel),\n    }\n}\n```\n\n`dockerd` 提供了一套类 RESTful 的后端接口服务，处理逻辑的入口便是上面的 `postBuild` 函数。\n\n该函数的内容较多，我们来分解下它的主要步骤。\n\n```go\nbuildOptions, err := newImageBuildOptions(ctx, r)\nif err != nil {\n    return errf(err)\n}\n```\n\n**newImageBuildOptions 函数就是构造构建参数的，将通过 API 提交过来的参数转换为构建动作实际需要的参数形式。**\n\n```go\nbuildOptions.AuthConfigs = getAuthConfigs(r.Header)\n```\n\n**getAuthConfigs 函数用于从请求头拿到认证信息**\n\n```go\nimgID, err := br.backend.Build(ctx, backend.BuildConfig{\n    Source:         body,\n    Options:        buildOptions,\n    ProgressWriter: buildProgressWriter(out, wantAux, createProgressReader),\n})\nif err != nil {\n    return errf(err)\n}\n```\n\n这里就需要注意了: 真正的构建过程要开始了。**使用 backend 的 Build 函数来完成真正的构建过程**\n\n```go\n// api/server/backend/build/backend.go#L52\nfunc (b *Backend) Build(ctx context.Context, config backend.BuildConfig) (string, error) {\n    options := config.Options\n    useBuildKit := options.Version == types.BuilderBuildKit\n\n    tagger, err := NewTagger(b.imageComponent, config.ProgressWriter.StdoutFormatter, options.Tags)\n    if err != nil {\n        return \"\", err\n    }\n\n    var build *builder.Result\n    if useBuildKit {\n        build, err = b.buildkit.Build(ctx, config)\n        if err != nil {\n            return \"\", err\n        }\n    } else {\n        build, err = b.builder.Build(ctx, config)\n        if err != nil {\n            return \"\", err\n        }\n    }\n\n    if build == nil {\n        return \"\", nil\n    }\n\n    var imageID = build.ImageID\n    if options.Squash {\n        if imageID, err = squashBuild(build, b.imageComponent); err != nil {\n            return \"\", err\n        }\n        if config.ProgressWriter.AuxFormatter != nil {\n            if err = config.ProgressWriter.AuxFormatter.Emit(\"moby.image.id\", types.BuildResult{ID: imageID}); err != nil {\n                return \"\", err\n            }\n        }\n    }\n\n    if !useBuildKit {\n        stdout := config.ProgressWriter.StdoutFormatter\n        fmt.Fprintf(stdout, \"Successfully built %s\\n\", stringid.TruncateID(imageID))\n    }\n    if imageID != \"\" {\n        err = tagger.TagImages(image.ID(imageID))\n    }\n    return imageID, err\n}\n```\n\n这个函数看着比较长，但主要功能就以下三点：\n\n- `NewTagger`是用于给镜像打标签，也就是我们的`-t`参数相关的内容，这里不做展开。\n- 通过判断是否使用了`buildkit`来调用不同的构建后端。\n\n```go\nuseBuildKit := options.Version == types.BuilderBuildKit\n\nvar build *builder.Result\nif useBuildKit {\n    build, err = b.buildkit.Build(ctx, config)\n    if err != nil {\n        return \"\", err\n    }\n} else {\n    build, err = b.builder.Build(ctx, config)\n    if err != nil {\n        return \"\", err\n    }\n}\n```\n\n- 处理构建完成后的动作。\n\n到这个函数之后，就分别是 v1 `builder` 与 `buildkit` 对 `Dockerfile` 的解析，以及对 `build context` 的操作了。\n\n这里涉及到的内容与之前的 Chat  镜像的内部关联比较大，此处就不再进行展开了。\n\n### 总结\n\n本次 Chat 首先介绍了 Docker 的 C/S 架构，介绍了构建镜像所用的 API , API 文档可以在线查看或者本地构建。\n\n之后深入到 Docker CLI 的源码中，逐步分解 v1 `builder` 与 `buildkit` 在构建镜像时执行的过程的差异。\n\n最后，我们深入到 `dockerd` 的源码中，了解到了对不同构建后端的调用。至此，Docker 构建镜像的原理及主体代码就介绍完毕。\n\n但这还并不是结束，下一场 Chat  中，我将与你分享容器镜像的前世今生，OCI 镜像与 Docker 镜像的异同，以及介绍下一代无 Docker 依赖的镜像构建工具，相信通过下一次的 Chat 你会对容器镜像的生态体系有更加深入的理解。', '![Docker 镜像构建原理及源码分析](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/engine-components-flow.png)', b'1', b'1', b'0', b'1', '2024-12-20 17:16:19', '2024-12-23 10:56:40', 9, 2643, 13, 10, b'1', '', 1);
INSERT INTO `blog` VALUES (8, 'JVM 面试的 30 个知识点', 'https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/c5238280-5a00-11ea-aae6-17c0629b6dc0.jpg', '# 1.什么是 Java 虚拟机？为什么 Java 被称作是“平台无关的编程语言”？\n\nJava 虚拟机是一个可以执行 Java 字节码的虚拟机进程。Java 源文件被编译成能被 Java 虚拟机执行的字节码文件。Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。\n\n# 2.Java 内存结构？\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/c5238280-5a00-11ea-aae6-17c0629b6dc0.png)\n\n方法区和对是所有线程共享的内存区域；而 java 栈、本地方法栈和程序员计数器是运行是线程私有的内存区域。\n\n# 3.内存模型以及分区，需要详细到每个区放什么？\n\nJVM 分为堆区和栈区，还有方法区，初始化的对象放在堆里面，引用放在栈里面，class 类信息常量池（static 常量和 static 变量）等放在方法区。 new:\n\n- 方法区：主要是存储类信息，常量池（static 常量和 static 变量），编译后的代码（字节码）等数据\n- 堆：初始化的对象，成员变量 （那种非 static 的变量），所有的对象实例和数组都要在堆上分配\n- 栈：栈的结构是栈帧组成的，调用一个方法就压入一帧，帧上面存储局部变量表，操作数栈，方法出口等信息，局部变量表存放的是 8 大基础类型加上一个应用类型，所以还是一个指向地址的指针\n- 本地方法栈：主要为 Native 方法服务\n- 程序计数器：记录当前线程执行的行号\n\n# 4.堆里面的分区：Eden，survival （from+ to），老年代，各自的特点？\n\n堆里面分为新生代和老生代（java8 取消了永久代，采用了 Metaspace），新生代包含 Eden+Survivor 区，survivor 区里面分为 from 和 to 区，内存回收时，如果用的是复制算法，从 from 复制到 to，当经过一次或者多次 GC 之后，存活下来的对象会被移动到老年区，当 JVM 内存不够用的时候，会触发 Full GC，清理 JVM 老年区当新生区满了之后会触发 YGC,先把存活的对象放到其中一个 Survice 区，然后进行垃圾清理。\n\n因为如果仅仅清理需要删除的对象，这样会导致内存碎片，因此一般会把 Eden 进行完全的清理，然后整理内存。\n\n那么下次 GC 的时候，就会使用下一个 Survive，这样循环使用。\n\n如果有特别大的对象，新生代放不下，就会使用老年代的担保，直接放到老年代里面。\n因为 JVM 认为，一般大对象的存活时间一般比较久远。\n\n# 5 .解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法\n\n通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用 JVM 中的栈空间；而通过 new 关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为 Eden、Survivor（又可分为 From Survivor 和 To Survivor）、Tenured；方法区和堆都是各个线程共享的内存区域，用于存储已经被 JVM 加载的类信息、常量、静态变量、JIT 编译器编译后的代码等数据；程序中的字面量（literal）如直接书写的 100、”hello”和常量都是放在常量池中，常量池是方法区的一部分，。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过 JVM 的启动参数来进行调整，栈空间用光了会引发 StackOverflowError，而堆和常量池空间不足则会引发 OutOfMemoryError。\n\n```java\nString str = new String(\"hello\");\n```\n\n上面的语句中变量 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而”hello”这个字面量是放在方法区的。\n\n补充 1：较新版本的 Java（从 Java 6 的某个更新开始）中，由于 JIT 编译器的发展和”逃逸分析”技术的逐渐成熟，栈上分配、标量替换等优化技术使得对象一定分配在堆上这件事情已经变得不那么绝对了。\n\n补充 2：运行时常量池相当于 Class 文件常量池具有动态性，Java 语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String 类的 intern()方法就是这样的。看看下面代码的执行结果是什么并且比较一下 Java 7 以前和以后的运行结果是否一致。\n\n```java\nString s1 = new StringBuilder(\"go\")\n    .append(\"od\").toString();\nSystem.out.println(s1.intern() == s1);\nString s2 = new StringBuilder(\"ja\")\n    .append(\"va\").toString();\nSystem.out.println(s2.intern() == s2);\n```\n\n# 6.GC 的两种判定方法?\n\n引用计数法：指的是如果某个地方引用了这个对象就+1，如果失效了就-1，当为 0 就 会回收但是 JVM 没有用这种方式，因为无法判定相互循环引用（A 引用 B,B 引用 A） 的情况。\n引用链法：通过一种 GC ROOT 的对象（方法区中静态变量引用的对象等-static 变 量）来判断，如果有一条链能够到达 GC ROOT 就说明，不能到达 GC ROOT 就说明 可以回收\n\n# 7.SafePoint 是什么?\n\n比如 GC 的时候必须要等到 Java 线程都进入到 safepoint 的时候 VMThread 才能开始执行 GC\n1.循环的末尾 (防止大循环的时候一直不进入 safepoint，而其他线程在等待它进入 safepoint)\n2.方法返回前\n3.调用方法的 call 之后\n4.抛出异常的位置\n\n# 8.GC 的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？\n\n先标记，标记完毕之后再清除，效率不高，会产生碎片\n复制算法：分为 8：1 的 Eden 区和 survivor 区，就是上面谈到的 YGC\n标记整理：标记完毕之后，让所有存活的对象向一端移动\n\n# 9.GC 收集器有哪些？CMS 收集器与 G1 收集器的特点？\n\n并行收集器：串行收集器使用一个单独的线程进行收集，GC 时服务有停顿时间\n串行收集器：次要回收中使用多线程来执行\nCMS 收集器是基于“标记—清除”算法实现的，经过多次标记才会被清除\nG1 从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的\n\n# 10.Minor GC 与 Full GC 分别在什么时候发生？\n\n新生代内存不够用时候发生 MGC 也叫 YGC，JVM 内存不够的时候发生 FGC\n\n# 11. 几种常用的内存调试工具：jmap、jstack、jconsole、jhat？\n\njstack 可以看当前栈的情况，jmap 查看内存，jhat 进行 dump 堆的信息 mat（eclipse 的也要了解一下）\n\n# 12.什么是类的加载\n\n类的加载指的是将类的.class 文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class 对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的 Class 对象，Class 对象封装了类在方法区内的数据结构，并且向 Java 程序员提供了访问方法区内的数据结构的接口。\n\n# 13.类加载器\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/a3cc3370-5a00-11ea-8155-9d6d04886d5b.png)\n\n- 启动类加载器：Bootstrap ClassLoader，负责加载存放在 JDK\\jre\\lib(JDK 代表 JDK 的安装目录，下同)下，或被-Xbootclasspath 参数指定的路径中的，并且能被虚拟机识别的类库\n- 扩展类加载：Extension ClassLoader，该加载器由 sun.misc.Launcher$ExtClassLoader 实现，它负责加载 DK\\jre\\lib\\ext 目录中，或者由 java.ext.dirs 系统变量指定的路径中的所有类库（如 javax.*开头的类），开发者可以直接使用扩展类加载器。\n- 应用程序类加载器：Application ClassLoader，该类加载器由 sun.misc.Launcher$AppClassLoader 来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器\n\n# 14.描述一下 JVM 加载 class 文件的原理机制？\n\nJVM 中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java 中的类加载器是一个重要的 Java 运行时系统组件，它负责在运行时查找和装入类文件中的类。\n\n由于 Java 的跨平台性，经过编译的 Java 源程序并不是一个可执行程序，而是一个或多个类文件。当 Java 程序需要使用某个类时，JVM 会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class 文件中的数据读入到内存中，通常是创建一个字节数组读入.class 文件，然后产生与所加载类对应的 Class 对象。加载完成后，Class 对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后 JVM 对类进行初始化，包括：\n\n- 1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；\n- 2)如果类中存在初始化语句，就依次执行这些初始化语句。\n\n类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader 的子类）。\n\n从 Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM 更好的保证了 Java 平台的安全性，在该机制中，JVM 自带的 Bootstrap 是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM 不会向 Java 程序提供对 Bootstrap 的引用。下面是关于几个类加载器的说明：\n\n- Bootstrap：一般用本地代码实现，负责加载 JVM 基础核心类库（rt.jar）；\n- Extension：从 java.ext.dirs 系统属性所指定的目录中加载类库，它的父加载器是 Bootstrap；\n- System：又叫应用类加载器，其父类是 Extension。它是应用最广泛的类加载器。它从环境变量 classpath 或者系统属性 java.class.path 所指定的目录中记载类，是用户自定义加载器的默认父加载器。\n\n# 15.Java 对象创建过程\n\n1.JVM 遇到一条新建对象的指令时首先去检查这个指令的参数是否能在常量池中定义到一个类的符号引用。然后加载这个类（类加载过程在后边讲）\n\n2.为对象分配内存。一种办法“指针碰撞”、一种办法“空闲列表”，最终常用的办法“本地线程缓冲分配(TLAB)”\n\n3.将除对象头外的对象内存空间初始化为 0\n\n4.对对象头进行必要设置\n\n# 16.类的生命周期\n\n类的生命周期包括这几个部分，加载、连接、初始化、使用和卸载，其中前三部是类的加载的过程,如下图；\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/d2940fc0-5a00-11ea-a695-8f4c079b036d.png)\n\njava 类加载需要经历以下 几个过程：\n\n- 加载\n\n加载时类加载的第一个过程，在这个阶段，将完成以下三件事情：\n\n1.通过一个类的全限定名获取该类的二进制流。\n\n2.将该二进制流中的静态存储结构转化为方法去运行时数据结构。\n\n3.在内存中生成该类的 Class 对象，作为该类的数据访问入口。\n\n- 验证\n\n验证的目的是为了确保 Class 文件的字节流中的信息不回危害到虚拟机.在该阶段主要完成以下四钟验证:\n\n文件格式验证：验证字节流是否符合 Class 文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型.\n\n元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。\n\n字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。 如： 方法中的类型转换是否正确，跳转指令是否正确等。\n\n符号引用验证： 这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。\n\n- 准备\n\n准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。\n\n```java\npublic static int value=123;\n// 在准备阶段 value 初始值为 0 。\n// 在初始化阶段才会变为 123。\n```\n\n- 解析\n\n该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。\n\n- 初始化\n\n初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。 到了初始化阶段，才真正开始执行类中定义的 Java 程序。\n\n# 17.简述 java 类加载机制?\n\n虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的 java 类型。\n\n# 18.Java 对象结构\n\nJava 对象由三个部分组成：对象头、实例数据、对齐填充。\n\n对象头由两部分组成，第一部分存储对象自身的运行时数据：哈希码、GC 分代年龄、锁标识状态、线程持有的锁、偏向线程 ID（一般占 ⁄ bit）。\n\n第二部分是指针类型，指向对象的类元数据类型（即对象代表哪个类）。如果是数组对象，则对象头中还有一部分用来记录数组长度。\n\n实例数据用来存储对象真正的有效信息（包括父类继承下来的和自己定义的）\n\n对齐填充：JVM 要求对象起始地址必须是 8 字节的整数倍（8 字节对齐）\n\n# 19.Java 对象的定位方式\n\n句柄池、直接指针。\n\n# 20.如和判断一个对象是否存活?(或者 GC 对象的判定方法)\n\n判断一个对象是否存活有两种方法:\n\n1.引用计数法\n\n所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收。 引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象 A 引用对象 B，对象 B 又引用者对象 A，那么此时 A,B 对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。\n\n2.可达性算法(引用链法)\n\n该算法的思想是：从一个被称为 GC Roots 的对象开始向下搜索，如果一个对象到 GC Roots 没有任何引用链相连时，则说明此对象不可用。\n在 java 中可以作为 GC Roots 的对象有以下几种：\n虚拟机栈中引用的对象\n\n方法区类静态属性引用的对象\n\n方法区常量池引用的对象\n\n本地方法栈 JNI 引用的对象\n\n虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比不一定会被回收。当一个对象不可达 GC Root 时，这个对象并不会立马被回收，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记如果对象在可达性分析中没有与 GC Root 的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行 finalize()方法。当对象没有覆盖 finalize()方法或者已被虚拟机调用过，那么就认为是没必要的。\n\n如果该对象有必要执行 finalize()方法，那么这个对象将会放在一个称为 F-Queue 的对队列中，虚拟机会触发一个 Finalize()线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果 finalize()执行缓慢或者发生了死锁，那么就会造成 FQueue 队列一直等待，造成了内存回收系统的崩溃。 GC 对处于 F-Queue 中的对象进行第二次被标记，这时，该对象将被移除”即将回收”集合，等待回收。\n\n# 21.JVM 的永久代中会发生垃圾回收么？\n\n垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免 Full GC 是非常重要的原因。请参考下 Java8：从永久代到元数据区 (注：Java8 中已经移除了永久代，新加了一个叫做元数据区的 native 内存区)\n\n# 22.简述 java 内存分配与回收策率以及 Minor GC 和 Major GC？\n\n1.对象优先在堆的 Eden 区分配。\n\n2.大对象直接进入老年代.\n\n3.长期存活的对象将直接进入老年代.，当 Eden 区没有足够的空间进行分配时，虚拟机会执行一次 Minor GC.Minor Gc 通常发生在新生代的 Eden 区，在这个区的对象生存期短，往往发生 Gc 的频率较高， 回收速度比较快;Full Gc/Major GC 发生在老年代，一般情况下，触发老年代 GC 的时候不会触发 Minor GC,但是通过配置，可以在 Full GC 之前进行一次 MinorGC 这样可以加快老年代的回收速度。\n\n# 23.判断一个对象应该被回收\n\n该对象没有与 GC Roots 相连\n\n该对象没有重写 finalize()方法或 finalize()已经被执行过则直接回收（第一次标记）、否则将对象加入到 F-Queue 队列中（优先级很低的队列）在这里 finalize()方法被执行，之后进行第二次标记，如果对象仍然应该被 GC 则 GC，否则移除队列。（在 finalize 方法中，对象很可能和其他 GC Roots 中的某一个对象建立了关联，finalize 方法只会被调用一次，且不推荐使用 finalize 方法）\n\n# 24.回收方法区\n\n方法区回收价值很低，主要回收废弃的常量和无用的类。\n\n如何判断无用的类：\n\n该类所有实例都被回收（Java 堆中没有该类的对象）\n\n加载该类的 ClassLoader 已经被回收\n\n该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方利用反射访问该类\n\n# 25.垃圾收集算法\n\nGC 最基础的算法有三种：标记 -清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法。\n\n- 标记 -清除算法，“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。\n- 复制算法，“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。\n- 标记-压缩算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存\n- 分代收集算法，“分代收集”（Generational Collection）算法，把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。\n\n# 26.垃圾回收器\n\nSerial 收集器，串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。\n\nParNew 收集器，ParNew 收集器其实就是 Serial 收集器的多线程版本。\n\nParallel 收集器，Parallel Scavenge 收集器类似 ParNew 收集器，Parallel 收集器更关注系统的吞吐量。\n\nParallel Old 收集器，Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和“标记－整理”算法\n\nCMS 收集器，CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。\n\nG1 收集器，G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征\n\n# 27.GC 日志分析\n\n摘录 GC 日志一部分（前部分为年轻代 gc 回收；后部分为 full gc 回收）：\n\n```log\n2016-07-05T10:43:18.093+0800: 25.395: [GC [PSYoungGen: 274931K->10738K(274944K)] 371093K->147186K(450048K), 0.0668480 secs] [Times: user=0.17 sys=0.08, real=0.07 secs]\n2016-07-05T10:43:18.160+0800: 25.462: [Full GC [PSYoungGen: 10738K->0K(274944K)] [ParOldGen: 136447K->140379K(302592K)] 147186K->140379K(577536K) [PSPermGen: 85411K->85376K(171008K)], 0.6763541 secs] [Times: user=1.75 sys=0.02, real=0.68 secs]\n```\n\n通过上面日志分析得出，PSYoungGen、ParOldGen、PSPermGen 属于 Parallel 收集器。其中 PSYoungGen 表示 gc 回收前后年轻代的内存变化；ParOldGen 表示 gc 回收前后老年代的内存变化；PSPermGen 表示 gc 回收前后永久区的内存变化。young gc 主要是针对年轻代进行内存回收比较频繁，耗时短；full gc 会对整个堆内存进行回城，耗时长，因此一般尽量减少 full gc 的次数\n\n# 28.调优命令\n\nSun JDK 监控和故障处理命令有 jps jstat jmap jhat jstack jinfo\n\n- jps，JVM Process Status Tool,显示指定系统内所有的 HotSpot 虚拟机进程。\n- jstat，JVM statistics Monitoring 是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT 编译等运行数据。\n- jmap，JVM Memory Map 命令用于生成 heap dump 文件\n- jhat，JVM Heap Analysis Tool 命令是与 jmap 搭配使用，用来分析 jmap 生成的 dump，jhat 内置了一个微型的 HTTP/HTML 服务器，生成 dump 的分析结果后，可以在浏览器中查看\n- jstack，用于生成 java 虚拟机当前时刻的线程快照。\n- jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。\n\n# 29.调优工具\n\n常用调优工具分为两类,jdk 自带监控工具：jconsole 和 jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto。\n\njconsole，Java Monitoring and Management Console 是从 java5 开始，在 JDK 中自带的 java 监控和管理控制台，用于对 JVM 中内存，线程和类等的监控\n\njvisualvm，jdk 自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC 变化等。\n\nMAT，Memory Analyzer Tool，一个基于 Eclipse 的内存分析工具，是一个快速、功能丰富的 Java heap 分析工具，它可以帮助我们查找内存泄漏和减少内存消耗\n\nGChisto，一款专业分析 gc 日志的工具\n\n# 30.Minor GC 与 Full GC 分别在什么时候发生？\n\n新生代内存不够用时候发生 MGC 也叫 YGC，JVM 内存不够的时候发生 FGC', '![JVM 面试的 30 个知识点](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/c5238280-5a00-11ea-aae6-17c0629b6dc0.png)', b'1', b'1', b'0', b'1', '2024-12-23 10:45:12', '2024-12-23 10:45:12', 0, 6744, 34, 10, b'0', '', 1);
INSERT INTO `blog` VALUES (9, 'Java IO 体系、线程模型大总结', 'https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/8e7d3c50-93c3-11eb-987a-1fa99aac0083.png', 'Java 中的 I/O 按照其发展历程，可以划分为传统 IO（阻塞式 I/O）和新 IO（非阻塞式 I/O）。\n\n### 传统 I/O\n\n传统 IO 也称为 BIO（Blocking IO），是面向字节流或字符流编程的 I/O 方式。\n\n一个典型的基于 BIO 的文件复制程序，字节流方式：\n\n```java\npublic class FileCopy01 {\n    public static void main(String[] args) {\n        //使用 jdk7 引入的自动关闭资源的 try 语句（该资源类要实现 AutoCloseable 或 Closeable 接口）\n        try (FileInputStream fis = new FileInputStream(\"D:\\\\file01.txt\");\n             FileOutputStream fos = new FileOutputStream(\"D:\\\\file01_copy.txt\")) {\n            byte[] buf = new byte[126];\n            int hasRead = 0;\n            while ((hasRead = fis.read(buf)) > 0) {\n                //每次读取多少就写多少\n                fos.write(buf, 0, hasRead);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n字符流方式：\n\n```java\npublic class FileCopy02 {\n    public static void main(String[] args) {\n        //使用 jdk7 引入的自动关闭资源的 try 语句\n        try (FileReader fr = new FileReader(\"D:\\\\file01.txt\");\n             FileWriter fw = new FileWriter(\"D:\\\\file01_copy2.txt\")) {\n            char[] buf = new char[2];\n            int hasRead = 0;\n            while ((hasRead = fr.read(buf)) > 0) {\n                //每次读取多少就写多少\n                fw.write(buf, 0, hasRead);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n字符缓冲，按行读取：\n\n```java\npublic class FileCopy02_2 {\n    public static void main(String[] args) {\n        //使用普通的 Reader 不方便整行读取,可以使用 BufferReader 包装,资源变量要定义在 try()中,否则不会自动关闭\n        try (FileReader fr = new FileReader(\"D:\\\\file01.txt\");\n             FileWriter fw = new FileWriter(\"D:\\\\file01_copy2_2.txt\");\n             BufferedReader bufferedReader = new BufferedReader(fr);\n             BufferedWriter bufferedWriter = new BufferedWriter(fw)) {\n            String line;\n            while ((line = bufferedReader.readLine()) != null) {\n                //每次读取一行、写入一行\n                bufferedWriter.write(line);\n                bufferedWriter.newLine();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n随机读写（RandomAccessFile）：\n\n```java\npublic class FileCopy03 {\n    public static void main(String[] args) {\n        try (RandomAccessFile in = new RandomAccessFile(\"D:\\\\file01.txt\",\"rw\");\n             RandomAccessFile out = new RandomAccessFile(\"D:\\\\file01_copy3.txt\",\"rw\")) {\n            byte[] buf = new byte[2];\n            int hasRead = 0;\n            while ((hasRead = in.read(buf)) > 0) {\n                //每次读取多少就写多少\n                out.write(buf, 0, hasRead);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n通常进行输入输出的内容是文本内容，应该考虑使用字符流；如果是二进制内容，则应考虑使用字节流；RandomAccessFile 支持自由访问文件的任意位置。如果需要访问文件的部分内容，而不是从头读到尾，可以优先考虑 RandomAccessFile，比如文件断点续传。\n\n### Java NIO\n\nNIO 也称新 IO 或者非阻塞 IO（Non-Blocking IO）。传统 IO 是面向输入/输出流编程的，而 NIO 是面向通道编程的。\n\nNIO 的 3 个核心概念：Channel、Buffer、Selector。我们先来谈谈其中的两个。\n\n#### Channel（通道）\n\nChannel 是对 IO 输入/输出系统的抽象，是 IO 源与目标之间的连接通道，NIO 的通道类似于传统 IO 中的各种“流”。与 InputStream 和 OutputStream 不同的是，Channel 是双向的，既可以读，也可以写，且支持异步操作。这契合了操作系统的特性，比如 linux 底层通道就是双向的。此外 Channel 还提供了 map() 方法，通过该方法可以将“一块”数据直接映射到内存中。因此也有人说，NIO 是面向块处理的，而传统 I/O 是面向流处理的。\n\n程序不能直接访问 Channel 中的数据，必须通过 Buffer（缓冲区）作为中介。Channel 可以直接将文件的部分或者全部映射成 Buffer。Channel 是一个接口，有多种实现类，比较常用的是 FileChannel、SocketChannel、ServerSocketChannel、DatagramChannel，分别用于文件读写，TCP 客户端、服务端网络通信、UDP 通信。\n\nChannel 通常都不是通过构造器来创建的，而是通过传统的输入/输出流的 getChannel() 来返回。通过不同类型的 Stream 获得的 Channel 也不同。比如常见的几个 Channel 的获取方式如下：\n\n- FileChannel：由文件流 FileInputStream、FileOutputStream 的 getChannel() 方法返回。\n- ServerSocketChannel：由 ServerSocketChannel 的静态方法 open() 返回。\n- SocketChannel：由 SocketChannel 的静态方法 open() 返回。\n\nChannel 中读写数据对应的方法分别是 read(ByteBuffer) 和 write(ByteBuffer) 方法。一些 Channel 还提供了 map() 方法将 Channel 对应的部分或全部数据映射为 ByteBuffer（实际的实现类为 MappedByteBuffer）。如果 Channel 对应的数据过大，使用 map() 方法一次性映射到内存会引起性能下降，此时还得用”多次重复取水”的方式处理。\n\n#### Buffer（缓冲）\n\nBuffer 本质上就是一个容器，其底层持有了一个具体类型的数组来存放具体数据。从 Channel 中取数据或者向 Channel 中写数据都需要通过 Buffer。在 Java 中 Buffer 是一个抽象类，除 boolean 之外的基本数据类型都提供了对应的 Buffer 实现类。比较常用的是 ByteBuffer 和 CharBuffer。\n\n通常 Buffer 的实现类中都没有提供 public 的构造方法，而是提供了静态方法 allocate(int capacity) 用来创建自身对应的 Buffer 对象。使用 get、put 方法来读取、写入数据到 Buffer 中。ByteBuffer 还支持直接缓冲区，即 ByteBuffer 还提供了 allocateDirect(int capacity) 方法来创建直接缓冲区，能与当前操作系统更好地耦合，进一步提高 I/O 的性能。但是分配直接缓冲区的系统开销较大，只适合缓冲区较大且需要长期驻留的情况。\n\nBuffer 中还有两个经常调用的重要方法，即 flip() 和 clear()。flip 方法为从 Buffer 中取出数据做好准备，而 clear 方法为再次向 Buffer 中写入数据做好准备。\n\n#### NIO 案例\n\n下面通过几个例子演示一下 NIO 的日常操作。\n\n文件复制：\n\n```java\npublic class FileCopy04 {\n    public static void main(String[] args) {\n        try (FileInputStream fis = new FileInputStream(\"D:\\\\file01.txt\");\n             FileOutputStream fos = new FileOutputStream(\"D:\\\\file01_copy4.txt\");\n             FileChannel inc = fis.getChannel();\n             FileChannel outc = fos.getChannel()\n        ) {\n            ByteBuffer buffer = ByteBuffer.allocate(4);\n            //多次重复\"取水\"的方式\n            while (inc.read(buffer) != -1) {\n                buffer.flip();\n                outc.write(buffer);\n                buffer.clear();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n文件复制—映射方式：\n\n```java\npublic class FileCopy05 {\n    public static void main(String[] args) {\n        File f = new File(\"D:\\\\file01.txt\");\n        try (FileInputStream fis = new FileInputStream(f);\n             FileOutputStream fos = new FileOutputStream(\"D:\\\\file01_copy5.txt\");\n             FileChannel inc = fis.getChannel();\n             FileChannel outc = fos.getChannel()\n        ) {\n            //将 FileChannel 里的全部数据映射到 ByteBuffer 中\n            MappedByteBuffer mappedByteBuffer = inc.map(FileChannel.MapMode.READ_ONLY, 0, f.length());\n            outc.write(mappedByteBuffer);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n**文件复制—零拷贝方式**\n\ntransferFrom 方式：\n\n```java\npublic class FileCopy06 {\n    public static void main(String[] args) throws IOException {\n        FileInputStream fis = new FileInputStream(\"D:\\\\file01.txt\");\n        FileOutputStream fos = new FileOutputStream(\"D:\\\\file01_copy06.txt\");\n        FileChannel srcChannel = fis.getChannel();\n        FileChannel destChannel = fos.getChannel();\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        destChannel.close();\n        srcChannel.close();\n        fis.close();\n        fos.close();\n    }\n}\n```\n\ntransferTo 方式：\n\n```java\npublic class FileCopy07 {\n    public static void main(String[] args) throws IOException {\n        FileInputStream fis = new FileInputStream(\"D:\\\\file01.txt\");\n        FileOutputStream fos = new FileOutputStream(\"D:\\\\file01_copy07.txt\");\n        FileChannel srcChannel = fis.getChannel();\n        FileChannel destChannel = fos.getChannel();\n        long size = srcChannel.size();\n        long position = 0;\n        while (size > 0) {\n            long count = srcChannel.transferTo(position, srcChannel.size(), destChannel);\n            position += count;\n            size -= count;\n        }\n\n        destChannel.close();\n        srcChannel.close();\n        fis.close();\n        fos.close();\n    }\n}\n```\n\n#### Java NIO 2.0\n\nJDK 7 对原有的 NIO 进行了改进。第一个改进是提供了全面的文件 I/O 相关 API。第二个改进是增加了异步的基于 Channel 的 IO 机制。\n\n我们说说第一个，第二个也就是通常所说的 AIO（Asynchronous IO），即异步 IO。由于实际工作中不常见，我们就不做介绍了。\n\n原来的 I/O 框架中只有一个 File 类来操作文件，新的 NIO 引入了 Path 接口，代表一个平台无关的路径。并且提供了 Paths、Files 两个强大的工具类来方便文件操作。\n\n使用新的 API 来完成文件复制代码大大简化：\n\n```java\npublic class FileCopy06 {\n    public static void main(String[] args) {\n        try (OutputStream fos = new FileOutputStream(\"D:\\\\file01_copy6.txt\")) {\n            Files.copy(Paths.get(\"D:\\\\file01.txt\"), fos);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n### Java 网络编程\n\n下文通过几个网络 IO 的例子，循序渐进地讲述 Socket 编程的流程。先讲解传统 Socket 编程（阻塞式），再讲解基于 NIO 的 Socket 编程。\n\n#### 传统 Socket 编程\n\n需求描述：实现一个简单的 C/S 架构的客户端/服务端通信程序，分别包括客户端程序和服务端程序。\n\n**版本 1：实现客户端/服务端一次性简单通信**\n\n这个例子只是简单的“一问一答”模式，极其简单地演示一下 Socket 编程的逻辑。\n\n服务端：\n\n```java\npublic class Server1 {\n    public static void main(String[] args) throws IOException {\n        //开启一个 TCP 服务端,占用一个本地端口\n        ServerSocket serverSocket = new ServerSocket(6666);\n        //服务端循环不断地接受客户端的连接\n        while (true) {\n            Socket socket = null;\n            try {\n                //与单个客户端通信的代码放在一个 try 代码块中，单个客户端发生异常（断开）时不影响服务端正常工作\n                System.out.println(\"server start...\");\n                //下面这行代码会阻塞,直到有客户端连接\n                socket = serverSocket.accept();\n                System.out.println(\"客户端\" + socket.getRemoteSocketAddress() + \"上线了\");\n                //从 Socket 中获得输入输出流,接收和发送数据\n                InputStream inputStream = socket.getInputStream();\n                OutputStream outputStream = socket.getOutputStream();\n                byte[] buf = new byte[1024];\n                int len;\n                while ((len = inputStream.read(buf)) != -1) {\n                    String msg = new String(buf, 0, len);\n                    System.out.println(\"来自客户端的消息：\" + msg);\n                    String serverResponseMsg = \"服务端收到了来自您的消息【\" + msg + \"】,并且探测到您的 IP 是：\" + socket.getRemoteSocketAddress();\n                    //向客户端回写消息\n                    outputStream.write(serverResponseMsg.getBytes(StandardCharsets.UTF_8));\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                //当与一个客户端通信结束后，需要关闭对应的 socket\n                if (socket != null) {\n                    try {\n                        socket.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n客户端\n\n```java\npublic class Client1 {\n    public static void main(String[] args) {\n        Socket socket = new Socket();\n        SocketAddress address = new InetSocketAddress(\"127.0.0.1\", 6666);\n        try {\n            socket.connect(address, 2000);\n            OutputStream outputStream = socket.getOutputStream();\n            String clientMsg = \"服务端你好！我是客户端！你的 IP 是：\" + socket.getRemoteSocketAddress();\n            outputStream.write(clientMsg.getBytes(StandardCharsets.UTF_8));\n\n            InputStream inputStream = socket.getInputStream();\n            byte[] buf = new byte[1024];\n            int len;\n            while ((len = inputStream.read(buf)) != -1) {\n                String msgFromServer = new String(buf, 0, len);\n                System.out.println(\"来自服务端的消息:\" + msgFromServer);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (socket != null) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n**版本 2：实现客户端可以不断接收用户输入**\n\n版本 1 演示了最简单的 Socket 编程，只能实现一次性通信。现在要求客户端能够不断地接收用户输入，多次与服务端通信。服务端代码不变，客户端改造如下：\n\n```java\npublic class Client2 {\n    public static void main(String[] args) {\n        Socket socket = new Socket();\n        SocketAddress address = new InetSocketAddress(\"127.0.0.1\", 6666);\n        try {\n            socket.connect(address, 2000);\n            OutputStream outputStream = socket.getOutputStream();\n            InputStream inputStream = socket.getInputStream();\n\n            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n            String clientMsg;\n            System.out.println(\"请输入消息:\");\n            while ((clientMsg = bufferedReader.readLine()) != null) {\n                outputStream.write(clientMsg.getBytes(StandardCharsets.UTF_8));\n                byte[] buf = new byte[1024];\n                int readLen = inputStream.read(buf);\n                String msgFromServer = new String(buf, 0, readLen);\n                System.out.println(\"来自服务端的消息:\" + msgFromServer);\n                System.out.println(\"请输入消息:\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (socket != null) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n**版本 3：使用字符流包装**\n\n上面的版本是按字节方式读取数据的，缓冲字节数组大小无法权衡，太小了不足以存放一行数据时，将会读取到不完整的数据，产生乱码。我们使用字符流包装字节流，读取整行数据，改进如下。\n\n服务端：\n\n```java\npublic class Server3 {\n    public static void main(String[] args) throws IOException {\n        //开启一个 TCP 服务端,占用一个本地端口\n        ServerSocket serverSocket = new ServerSocket(6666);\n        //服务端循环不断地接受客户端的连接\n        while (true) {\n            Socket socket = null;\n            try {\n                //与单个客户端通信的代码放在一个 try 代码块中，单个客户端发生异常（断开）时不影响服务端正常工作\n                System.out.println(\"server start...\");\n                //下面这行代码会阻塞,直到有客户端连接\n                socket = serverSocket.accept();\n                System.out.println(\"客户端\" + socket.getRemoteSocketAddress() + \"上线了\");\n                //从 Socket 中获得输入输出流,接收和发送数据\n                PrintWriter socketPrintWriter = new PrintWriter(socket.getOutputStream(), true);\n                BufferedReader socketBufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                String msg;\n                while ((msg = socketBufferedReader.readLine()) != null) {\n                    System.out.println(\"来自客户端的消息：\" + msg);\n                    String serverResponseMsg = \"服务端收到了来自您的消息【\" + msg + \"】,并且探测到您的 IP 是：\" + socket.getRemoteSocketAddress();\n                    socketPrintWriter.println(serverResponseMsg);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                //当与一个客户端通信结束后，需要关闭对应的 socket\n                if (socket != null) {\n                    try {\n                        socket.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n客户端：\n\n```java\npublic class Client3 {\n    public static void main(String[] args) {\n        Socket socket = new Socket();\n        SocketAddress address = new InetSocketAddress(\"127.0.0.1\", 6666);\n        try {\n            socket.connect(address, 2000);\n            PrintWriter socketPrintWriter = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader socketBufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            BufferedReader bufferedInputReader = new BufferedReader(new InputStreamReader(System.in));\n            String clientMsg;\n            System.out.println(\"请输入消息:\");\n            while ((clientMsg = bufferedInputReader.readLine()) != null) {\n                socketPrintWriter.println(clientMsg);\n                String msgFromServer = socketBufferedReader.readLine();\n                System.out.println(\"来自服务端的消息:\" + msgFromServer);\n                System.out.println(\"请输入消息:\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (socket != null) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n**版本 4：实现多客户端与服务器通信**\n\n上面的例子中，只能实现一个客户端和服务端的通信。假如有多个客户端连接服务端，就只能等上一个客户端处理完毕，服务端重新通过 accept() 方法从队列中取出连接请求时才能处理。可以使用多线程的方式实现一个服务器同时响应多个客户端。\n\n和上一个版本相比，客户端代码没有改动，服务端改进如下：\n\n```java\npublic class Server4 {\n    public static void main(String[] args) throws IOException {\n        //开启一个 TCP 服务端,占用一个本地端口\n        ServerSocket serverSocket = new ServerSocket(6666);\n        //服务端循环不断地接受客户端的连接\n        System.out.println(\"server start...\");\n        while (true) {\n            Socket socket;\n            try {\n                socket = serverSocket.accept();\n                System.out.println(\"客户端\" + socket.getRemoteSocketAddress() + \"上线了\");\n                //为每一个客户端分配一个线程\n                Thread workThread = new Thread(new Handler(socket));\n                workThread.start();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\nclass Handler implements Runnable {\n    private Socket socket;\n\n    public Handler(Socket socket) {\n        this.socket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            //从 Socket 中获得输入输出流,接收和发送数据\n            PrintWriter socketPrintWriter = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader socketBufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            String msg;\n            while ((msg = socketBufferedReader.readLine()) != null) {\n                System.out.println(\"来自客户端\" + socket.getRemoteSocketAddress() + \"的消息：\" + msg);\n                String serverResponseMsg = \"服务端收到了来自您的消息【\" + msg + \"】,并且探测到您的 IP 是：\" + socket.getRemoteSocketAddress();\n                socketPrintWriter.println(serverResponseMsg);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            //当与一个客户端通信结束后，需要关闭对应的 socket\n            if (socket != null) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n**版本 5：实现一个简单的网络聊天室**\n\n一个服务端支持多个客户端同时连接，每个客户端都能不断读取用户键入的消息，发送给服务器并由服务器广播到所有连到服务器的客户端，实现群聊的功能。\n\n客户端：\n\n```java\npublic class Client5 {\n    public static void main(String[] args) {\n        Socket socket = new Socket();\n        SocketAddress address = new InetSocketAddress(\"127.0.0.1\", 6666);\n        try {\n            socket.connect(address, 2000);\n            new Thread(new ClientHandler(socket)).start();\n            PrintWriter socketPrintWriter = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader bufferedInputReader = new BufferedReader(new InputStreamReader(System.in));\n            String clientMsg;\n            System.out.println(\"请输入消息:\");\n            while ((clientMsg = bufferedInputReader.readLine()) != null) {\n                socketPrintWriter.println(clientMsg);\n                System.out.println(\"请输入消息:\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (socket != null) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n\nclass ClientHandler implements Runnable {\n    private Socket socket;\n\n    public ClientHandler(Socket socket) {\n        this.socket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            BufferedReader socketBufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            String msgFromServer;\n            while ((msgFromServer = socketBufferedReader.readLine()) != null) {\n                System.out.println(\"收到来自服务端的消息:\" + msgFromServer);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n上述客户端单独开启了一个线程来读取服务器响应的数据。主线程只负责接收客户端用户输入的数据，并发送给服务器。\n\n服务端：\n\n```java\npublic class Server5 {\n    public static List<Socket> socketList = new ArrayList<>();\n\n    public static void main(String[] args) throws IOException {\n        //开启一个 TCP 服务端,占用一个本地端口\n        ServerSocket serverSocket = new ServerSocket(6666);\n        //服务端循环不断地接受客户端的连接\n        System.out.println(\"server start...\");\n        while (true) {\n            Socket socket;\n            try {\n                socket = serverSocket.accept();\n                socketList.add(socket);\n                System.out.println(\"客户端\" + socket.getRemoteSocketAddress() + \"上线了\");\n                //为每一个客户端分配一个线程\n                Thread workThread = new Thread(new ServerHandler(socket));\n                workThread.start();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\nclass ServerHandler implements Runnable {\n    private Socket socket;\n    private BufferedReader socketBufferedReader;\n\n    public ServerHandler(Socket socket) throws IOException {\n        this.socket = socket;\n        this.socketBufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n    }\n\n    @Override\n    public void run() {\n        try {\n            //从 Socket 中获得输入输出流,接收和发送数据\n            String msg;\n            while ((msg = readMsgFromClient()) != null) {\n                System.out.println(\"收到来自客户端\" + socket.getRemoteSocketAddress() + \"的消息：\" + msg);\n                String massMsg = \"客户端【\" + socket.getRemoteSocketAddress() + \"】说：\" + msg;\n                for (Socket socket : Server5.socketList) {\n                    PrintWriter socketPrintWriter = new PrintWriter(socket.getOutputStream(), true);\n                    socketPrintWriter.println(massMsg);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            //当与一个客户端通信结束后，需要关闭对应的 socket\n            if (socket != null) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private String readMsgFromClient() {\n        try {\n            return socketBufferedReader.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n            //如果捕获到异常，则将该客户端对应的 socket 删除\n            Server5.socketList.remove(socket);\n        }\n        return null;\n    }\n}\n```\n\n上面的代码粗略地实现了一个网络聊天室的功能。使用传统的 IO 编程，比如 BufferedReader 的 readLine() 方法读取数据时，方法成功返回之前线程会被阻塞，因此要能同时处理多个客户端请求的话，服务端需要为每个客户端的 Socket 连接启动一个线程单独处理与单个客户端的通信。同样的，客户端在读取服务端数据时同样会被阻塞，因此需要单独启动一个线程从流中去读取服务端的数据。\n\n**版本 6：实现一对一聊天**\n\n上一个版本中，聊天室的客户端信息都是群发的，包括发送者也会收到服务器广播的消息。这里再次改进，发送者自己无需收到自己发出去的消息；并且发送者可以指定接受者的名称，实现一对一私聊。实现上述功能的关键就是在 Server 端记录每个客户端的信息。\n\n消息格式约定：\n\n- 客户端发送的消息用冒号分割消息体。比如“消息类型 : 消息接收人(用户名) : 消息内容”。\n- 消息类型有两种，login、chat，分别表示登录消息和普通聊天消息；消息接收人可以是 all 或者具体的用户名，分别表示群聊消息和私聊对象。\n\n**客户端**\n\n客户端连上服务端后先发送登录消息，再发送聊天消息，控制台输入示例如下：\n\n```log\n请输入消息:\nlogin:zhou\n收到来自服务端的消息:用户【zhou】登录成功！\n请输入消息:\nchat:all:大家好哈\n请输入消息:\nchat:laowang:老王你好哈\n```\n\n代码：\n\n```java\npublic class Client6 {\n    public static void main(String[] args) {\n        Socket socket = new Socket();\n        SocketAddress address = new InetSocketAddress(\"127.0.0.1\", 6666);\n        try {\n            socket.connect(address, 2000);\n            new Thread(new ClientHandler6(socket)).start();\n            PrintWriter socketPrintWriter = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader bufferedInputReader = new BufferedReader(new InputStreamReader(System.in));\n            String clientMsg;\n            System.out.println(\"请输入消息:\");\n            while ((clientMsg = bufferedInputReader.readLine()) != null) {\n                socketPrintWriter.println(clientMsg);\n                System.out.println(\"请输入消息:\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (socket != null) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n\nclass ClientHandler6 implements Runnable {\n    private Socket socket;\n\n    public ClientHandler6(Socket socket) {\n        this.socket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            BufferedReader socketBufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            String msgFromServer;\n            while ((msgFromServer = socketBufferedReader.readLine()) != null) {\n                System.out.println(\"收到来自服务端的消息:\" + msgFromServer);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n服务端：\n\n```java\npublic class Server6 {\n    public static Map<String, Socket> userConnectionInfo = new HashMap<>();\n\n    public static void main(String[] args) throws IOException {\n        //开启一个 TCP 服务端,占用一个本地端口\n        ServerSocket serverSocket = new ServerSocket(6666);\n        //服务端循环不断地接受客户端的连接\n        System.out.println(\"server start...\");\n        while (true) {\n            Socket socket;\n            try {\n                socket = serverSocket.accept();\n                System.out.println(\"客户端\" + socket.getRemoteSocketAddress() + \"上线了\");\n                //为每一个客户端分配一个线程\n                Thread workThread = new Thread(new ServerHandler6(socket));\n                workThread.start();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\nclass ServerHandler6 implements Runnable {\n    private Socket socket;\n    private BufferedReader socketBufferedReader;\n\n    public ServerHandler6(Socket socket) throws IOException {\n        this.socket = socket;\n        this.socketBufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n    }\n\n    @Override\n    public void run() {\n        try {\n            //从 Socket 中获得输入输出流,接收和发送数据\n            String msg;\n            while ((msg = readMsgFromClient()) != null) {\n                String[] split = msg.split(\":\");\n                if ((\"login\".equals(split[0]) && split.length != 2) || (!\"login\".equals(split[0])) && (split.length != 3)) {\n                    response(\"消息格式错误,请用冒号分割,形如：消息类型:消息接收人(用户名):消息内容 ,消息类型有两种:login、chat;消息接收人可以是 all 或者具体的用户名\");\n                    continue;\n                }\n\n                String msgType = split[0];\n                String userName = split[1];\n                if (\"login\".equals(msgType)) {\n                    if (Server6.userConnectionInfo.get(userName) == null) {\n                        Server6.userConnectionInfo.put(userName, socket);\n                        response(\"用户【\" + userName + \"】登录成功！\");\n                    } else {\n                        response(\"用户【\" + userName + \"】已登录,无需重复登录\");\n                    }\n                } else if (\"chat\".equals(msgType)) {\n                    if (\"all\".equals(userName)) {\n                        String senderName = getUname();\n                        //群发消息\n                        for (Map.Entry<String, Socket> entry : Server6.userConnectionInfo.entrySet()) {\n                            Socket userSocket = entry.getValue();\n                            if (userSocket == socket) {\n                                continue;\n                            }\n                            PrintWriter socketPrintWriter = new PrintWriter(userSocket.getOutputStream(), true);\n                            String sendMsg = \"【\" + senderName + \"】对大家说：\" + split[2];\n                            socketPrintWriter.println(sendMsg);\n                        }\n                    } else {\n                        if (Server6.userConnectionInfo.get(userName) == null) {\n                            response(\"用户【\" + userName + \"】不在线\");\n                        } else {\n                            Socket userSocket = Server6.userConnectionInfo.get(userName);\n                            PrintWriter socketPrintWriter = new PrintWriter(userSocket.getOutputStream(), true);\n                            String sendMsg = \"【\" + getUname() + \"】对你说：\" + split[2];\n                            socketPrintWriter.println(sendMsg);\n                        }\n                    }\n                } else {\n                    response(\"消息类型错误，只支持 login/chat\");\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            //当与一个客户端通信结束后，需要关闭对应的 socket\n            if (socket != null) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private String getUname() {\n        String uname = \"\";\n        //找出该 socket 对应的用户名\n        for (Map.Entry<String, Socket> entry : Server6.userConnectionInfo.entrySet()) {\n            String userNameInfo = entry.getKey();\n            Socket userSocket = entry.getValue();\n            if (userSocket == socket) {\n                uname = userNameInfo;\n                break;\n            }\n        }\n        return uname;\n    }\n\n    private void response(String msg) throws IOException {\n        PrintWriter socketPrintWriter = new PrintWriter(socket.getOutputStream(), true);\n        socketPrintWriter.println(msg);\n    }\n\n    private String readMsgFromClient() {\n        try {\n            return socketBufferedReader.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n            //如果捕获到异常，则将该客户端对应的 socket 删除\n            System.out.println(\"客户端\" + socket.getRemoteSocketAddress() + \"下线了\");\n            Server6.userConnectionInfo.remove(getUname());\n        }\n        return null;\n    }\n}\n```\n\n#### 基于 NIO 的网络编程\n\n讲完了传统的 Java I/O 编程，下面我们讲解如何使用 Java NIO 的方式实现非阻塞的网络通信。\n\n之前的网络通信程序中，我们都是用的传统 I/O 方式，即阻塞式 IO，顾名思义，在程序运行过程中常常会阻塞。比如在前文的例子中，当一个线程执行到 ServerSocket 的 accept() 方法时，该线程会一直阻塞，直到有了客户端连接才从 accept() 方法返回。再比如，当某个线程执行 Socket 的 read() 方法时，如果输入流中没有数据，则该线程会一直阻塞到读入了足够的数据才从 read() 方法返回。\n\nJava NIO（New I/O）提供了非阻塞的实现方式。NIO 也可以理解为 non-blocking I/O 的简称。所谓非阻塞 I/O，就是当线程执行这些 I/O 方法时，如果某个操作还没有准备好，就立即返回，而不会因为某个操作还没就绪就进入线程阻塞状态，一直在那等。比如，当服务端的线程接收客户端连接时，如果没有客户端连接，就立即返回。再比如，当某个线程从输入流中读取数据时，如果流中还没有数据，就立即返回。或者如果输入流中没有足够的数据就直接读取现有的数据并返回。很明显，这种非阻塞的方式效率会更高。\n\n有人说，那我用多线程方式处理阻塞式通信不香么？\n\n是的，确实不香！前面我们的服务端代码演示了如何使用多线程同时处理多个客户端的连接。通常是主线程负责接收客户端的连接，每当主线程接收到一个客户端连接后，就把具体的数据交互任务交给一个单独的线程去完成，主线程继续接收下一个客户端的连接。\n\n尽管使用多线程能够满足同时相应多个客户端的要求，但是这种方式有下列局限性：\n\n- 如果服务端对于每个客户端的连接请求都单独开启一个线程来处理，那么在客户端数量庞大时，势必导致服务端开启的线程数过多。即使是使用线程池，也得设置池中放多少个线程，放多放少都是个问题。我们知道，会为每个线程分配一个，线程越多，系统开销就越大，线程的调度负担就越重，甚至会由于线程同步的复杂性导致线程死锁。\n- 负责读写数据的工作线程很多时间浪费在 I/O 阻塞中，因为要等流中的数据准备好。这就会导致 JVM 频繁转让 CPU 的使用权，让阻塞状态的线程放弃 CPU，让可运行状态的线程获得 CPU 使用权。\n\n实践经验告诉我们，工作线程并不是越多越好。保持适当的线程数，可以提高服务器的并发性能。但是当线程数到达某个阈值，超出系统负荷，反而会导致并发性能降低，增大响应时间。Java NIO 可以做到用一个线程来处理多个 I/O 操作，再也不要来一个客户端分配一个线程了，比如来 10000 个并发连接，可以只分配 1 个、50 个或者 100 个线程来处理。\n\nJava NIO 提供了支持阻塞/非阻塞 I/O 通信的类。下面介绍几个核心的类。\n\n**1. ServerSocketChannel**\n\n可以看成是 ServerSocket 的替代类，既支持非阻塞通信，也支持阻塞式通信，同时也有负责接收客户端连接的 accept() 方法。每一个 ServerSocketChannel 对象都和一个 ServerSocket 对象关联。前面提到了，ServerSocketChannel 没有 public 的构造器，只能通过它自身的静态方法 open() 来创建 ServerSocketChannel 对象。ServerSocketChannel 是 SelectableChannel 的派生类。\n\n**2. SocketChannel**\n\n可以看成是 Socket 的替代类，既支持非阻塞通信，又支持阻塞式通信。SocketChannel 具有读数据的 read(ByteBuffer dst) 方法和写数据的 write(ByteBuffer src) 方法。SocketChannel 也没有 public 类型的构造器，也是通过静态方法 open() 来创建自身的对象。每一个 SocketChannel 对象都和一个 Socket 对象关联。SocketChannel 也是 SelectableChannel 的派生类。\n\nSocketChannel 提供了发送和接收数据的方法。\n\n- read(ByteBuffer dst)：接收数据，并把接收到的数据存到指定的 ByteBuffer 中。假设 ByteBuffer 的剩余容量为 n，在阻塞模式下，read() 方法会争取读入 n 个字节，如果通道中不足 n 个字节，就会阻塞，直到读入了 n 个字节或者读到了输入流的末尾，或者出现了 I/O 异常。在非阻塞模式下，read() 方法奉行能读多少就读多少的原则。不会等待数据，而是读取之后立即返回。可能读取了不足 n 个字节的数据，也可能就是 0。如果返回 -1 则表示读到了流的末尾。\n- write(ByteBuffer src)：发送数据，即把指定的 ByteBuffer 中的数据发送出去。假设 ByteBuffer 的剩余容量为 n，在阻塞模式下，write() 方法会争取输出 n 个字节，如果底层的网络输出缓冲区不能容纳 n 个字节，就会进入阻塞状态，直到输出 n 个字节，或者出现 I/O 异常才返回。在非阻塞模式下，write() 方法奉行能输出多少就输出多少的原则，有可能不足 n 个字节，有可能是 0 个字节，总之立即返回。\n\n**3. Selector（选择器）**\n\n用一个线程就能处理多个的客户端连接的关键就在于 Selector。Selector 是 SelectableChannel 对象的多路复用器，用于判断 channle 上是否发生 IO 事件，所有希望使用非阻塞方式通信的 Channel 都需要注册到 Selector 上。Selector 可以同时监控多个 SelectableChannel 的 IO 状态，即只要 ServerSocketChannel 或者 SocketChannel 向 Selector 注册了特定的事件，Selector 就会监控这些事件是否发生。Selector 为 ServerSocketChannel 监听连接就绪的事件，为 SocketChannel 监控连接就绪、读就绪、写就绪事件。Selector 实例对象的创建通常是通过调用其静态的 open() 方法。\n\nSelector 有如下几种方法来返回 I/O 相关事件已经发生的 SelectionKey 的数目。\n\n- selectNow()：该方法使用非阻塞的方式返回相关事件已经发生的 SelectionKey 的数目，如果没有任何事件发生，立即返回 0。\n- select() 和 select(long timeout)：该方法使用阻塞的方式。如果没有一个事件发生，就进入阻塞状态。直到有事件发生或者超出 timeout 设置的等待时间，才会正常返回。\n\n使用 Selector 能够保证只在真正有读写事件发生时，才会进行读写，若通道中没有数据可用，该线程可以执行其它任务，不必阻塞。比如一个通道没有准备好数据时，可以将空闲时间用于其它通道执行 IO 操作。由于单个线程可以管理多个 Channel 的输入输出，避免了频繁的线程切换和阻塞，提升了 I/O 效率。实际上  的 I/O 线程 NioEventLoop 就是聚合了 Selector（多路复用器），因此能够处理成千上万的客户端连接。\n\n**4. SelectionKey**\n\nServerSocketChannel 或者 SocketChannel 通过 register() 方法向 Selector 注册事件时，会返回一个 SelectionKey 对象，用来跟踪注册事件。Selector 会一直监控与 SelectionKey 相关的事件。当一个 SelectionKey 对象被放到 Selector 对象的 selected-keys 集合中时，就表示与这个 SelectionKey 相关的事件发生了。\n\nServerSocketChannel 及 SocketChannel 都继承自 SelectableChannel 类，该类及其子类可以委托 Selector 来监控它们可能发生的一些事件，这种委托过程就是事件注册。比如下列代码展示了 ServerSocketChannel 向 Selector 注册接收连接事件。\n\n```java\nserverSocketChannel.register(selector, SelectionKey.OP_ACCEPT)\n```\n\nServerSocketChannel 只会发生一种事件，即 SelectionKey.OP_ACCEPT，接受连接就绪事件。该事件的发生表明至少有一个客户端连接了，服务端可以通过 accept() 去接受这个连接了。\n\nSocketChannel 可以发生下列 3 种事件。\n\n- SelectionKey.OP_CONNECT，连接就绪事件，表示客户端和服务端已经成功建立连接。\n- SelectionKey.OP_READ，读就绪事件，表示通道中已经有了可读的数据，可以执行读操作了。\n- SelectionKey.OP_WRITE，写就绪事件，表示可以向通道中写数据了。\n\n默认情况下，所有的 Channel 都是阻塞模式的，要想使用非阻塞模式，可以通过下列方式设置：\n\n```java\nserverSocketChannel.configureBlocking(false);\n```\n\n此外，前面已经介绍了 NIO 的 Buffer、Channel 相关概念，此处不再赘述。\n\n下面我们就使用 NIO 的方式来编写网络通信程序的案例。\n\n需求描述：实现客户端服务端的网络通信，客户端每发送一条消息，服务端就原样回复，并加一句前缀以示区分。\n\n**版本 1：使用 NIO 的阻塞模式，并配以线程池方式**\n\n服务端：\n\n```java\npublic class NIOServer1 {\n    private int port = 6666;\n    private ServerSocketChannel serverSocketChannel;\n    private ExecutorService executorService;\n\n    public NIOServer1() throws IOException {\n        executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() * 4);\n        serverSocketChannel = ServerSocketChannel.open();\n        //允许地址重用，即关闭了服务端程序之后，哪怕立即再启动该程序时可以顺利绑定相同的端口\n        serverSocketChannel.socket().setReuseAddress(true);\n        serverSocketChannel.socket().bind(new InetSocketAddress(port));\n        System.out.println(\"server started...\");\n    }\n\n    public static void main(String[] args) throws IOException {\n        new NIOServer1().service();\n    }\n\n    private void service() {\n        while (true) {\n            SocketChannel socketChannel;\n            try {\n                socketChannel = serverSocketChannel.accept();\n                executorService.execute(new NioHandler1(socketChannel));\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\nclass NioHandler1 implements Runnable {\n    private SocketChannel socketChannel;\n\n    public NioHandler1(SocketChannel socketChannel) {\n        this.socketChannel = socketChannel;\n    }\n\n    @Override\n    public void run() {\n        Socket socket = socketChannel.socket();\n        System.out.println(\"接受到客户端的连接，来自\" + socket.getRemoteSocketAddress());\n        try {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            PrintWriter writer = new PrintWriter(socket.getOutputStream(), true);\n            String msg;\n            while ((msg = reader.readLine()) != null) {\n                System.out.println(\"客户端【\" + socket.getInetAddress() + \":\" + socket.getPort() + \"】说：\" + msg);\n                writer.println(genResponse(msg));\n                if (\"bye\".equals(msg)) {\n                    break;\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private String genResponse(String msg) {\n        return \"服务器收到了您的消息：\" + msg;\n    }\n}\n```\n\n客户端：\n\n```java\npublic class NIOClient1 {\n    private SocketChannel socketChannel;\n\n    public NIOClient1() throws IOException {\n        socketChannel = SocketChannel.open();\n        InetAddress localHost = InetAddress.getLocalHost();\n        InetSocketAddress socketAddress = new InetSocketAddress(localHost, 6666);\n        //采用阻塞模式连接服务器\n        socketChannel.connect(socketAddress);\n        System.out.println(\"与服务端连接成功！\");\n    }\n\n    public static void main(String[] args) throws IOException {\n        new NIOClient1().chat();\n    }\n\n    public void chat() {\n        Socket socket = socketChannel.socket();\n        try {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            PrintWriter writer = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader inputReader = new BufferedReader(new InputStreamReader(System.in));\n            String msg;\n            while ((msg = inputReader.readLine()) != null) {\n                writer.println(msg);\n                System.out.println(\"【服务器】说:\" + reader.readLine());\n                //如果输入 bye，则终止聊天\n                if (\"bye\".equals(msg)) {\n                    break;\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n上述案例中，我们使用的是 ServerSocketChannel 和 SocketChannel 的默认模式，即阻塞模式。为了能同时响应多个客户端，服务端依然是使用多线程的方式，只不过这次使用的是线程池。\n\n**版本 2：使用 NIO 非阻塞模式**\n\n在非阻塞模式下，服务端只需启动一个主线程，就能同时完成 3 件事：\n\n- 接受客户端的连接\n- 接收客户端发送的数据\n- 向客户端发送响应数据\n\n服务端会委托 Selector 来监听接收连接就绪事件、读就绪事件、写就绪事件，如有特定的事件发生，就处理该事件。\n\n服务端：\n\n```java\npublic class NIOServer2 {\n    private int port = 6666;\n    private ServerSocketChannel serverSocketChannel;\n    private Selector selector;\n    private Charset charset = Charset.forName(\"UTF-8\");\n\n    public NIOServer2() throws IOException {\n        selector = Selector.open();\n        serverSocketChannel = ServerSocketChannel.open();\n        serverSocketChannel.socket().setReuseAddress(true);\n        //设置为非阻塞模式\n        serverSocketChannel.configureBlocking(false);\n        serverSocketChannel.socket().bind(new InetSocketAddress(port));\n        System.out.println(\"server started...\");\n    }\n\n    public static void main(String[] args) throws IOException {\n        new NIOServer2().service();\n    }\n\n    private void service() throws IOException {\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n        while (selector.select() > 0) {\n            Set<SelectionKey> selectionKeys = selector.selectedKeys();\n            Iterator<SelectionKey> iterator = selectionKeys.iterator();\n            while (iterator.hasNext()) {\n                SelectionKey key = null;\n                //处理每个 SelectionKey 的代码放在一个 try/catch 块中，如果出现异常，就使其失效并关闭对应的 Channel\n                try {\n                    key = iterator.next();\n                    if (key.isAcceptable()) {\n                        doAccept(key);\n                    }\n                    if (key.isWritable()) {\n                        sendMsg(key);\n                    }\n\n                    if (key.isReadable()) {\n                        receiveMsg(key);\n                    }\n                    //从 Selector 的 selected-keys 集合中删除处理过的 SelectionKey\n                    iterator.remove();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    try {\n                        //发生异常时，使这个 SelectionKey 失效，Selector 不再监控这个 SelectionKey 感兴趣的事件\n                        if (key != null) {\n                            key.cancel();\n                            //关闭这个 SelectionKey 关联的 SocketChannel\n                            key.channel().close();\n                        }\n                    } catch (Exception ex) {\n                        ex.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n\n    private void receiveMsg(SelectionKey key) throws IOException {\n        ByteBuffer buffer = (ByteBuffer) key.attachment();\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n        //创建一个 ByteBuffer 存放读取到的数据\n        ByteBuffer readBuffer = ByteBuffer.allocate(64);\n        socketChannel.read(readBuffer);\n        readBuffer.flip();\n        buffer.limit(buffer.capacity());\n        //把 readBuffer 中的数据拷贝到 buffer 中，假设 buffer 的容量足够大，不会出现溢出的情况\n        //在非阻塞模式下，socketChannel.read(readBuffer)方法一次读入多少字节的数据是不确定的，无法保证一次读入的是一整行字符串数据\n        //因此需要将其每次读取的数据放到 buffer 中，当凑到一行数据时再回复客户端\n        buffer.put(readBuffer);\n    }\n\n    private void sendMsg(SelectionKey key) throws IOException {\n        ByteBuffer buffer = (ByteBuffer) key.attachment();\n        SocketChannel socketChannel = (SocketChannel) key.channel();\n        buffer.flip();\n        String data = decode(buffer);\n        //当凑满一行数据时再回复客户端\n        if (data.indexOf(\"\\r\\n\") == -1) {\n            return;\n        }\n        //读取一行数据\n        String recvData = data.substring(0, data.indexOf(\"\\n\") + 1);\n        System.out.print(\"客户端【\" + socketChannel.socket().getInetAddress() + \":\" + socketChannel.socket().getPort() + \"】说：\" + recvData);\n        ByteBuffer outputBuffer = encode(genResponse(recvData));\n        while (outputBuffer.hasRemaining()) {\n            socketChannel.write(outputBuffer);\n        }\n\n        ByteBuffer temp = encode(recvData);\n        buffer.position(temp.limit());\n        //删除 buffer 中已经处理过的数据\n        buffer.compact();\n\n        if (\"bye\\r\\n\".equals(recvData)) {\n            key.cancel();\n            key.channel().close();\n            System.out.println(\"关闭与客户端\" + socketChannel.socket().getRemoteSocketAddress() + \"的连接\");\n        }\n    }\n\n    private ByteBuffer encode(String msg) {\n        return charset.encode(msg);//转为字节\n    }\n\n    private String decode(ByteBuffer buffer) {\n        CharBuffer charBuffer = charset.decode(buffer);//转为字符\n        return charBuffer.toString();\n    }\n\n    private void doAccept(SelectionKey key) throws IOException {\n        ServerSocketChannel ssc = (ServerSocketChannel) key.channel();\n        SocketChannel socketChannel = ssc.accept();\n        System.out.println(\"接受到客户端的连接，来自\" + socketChannel.socket().getRemoteSocketAddress());\n        //设置为非阻塞模式\n        socketChannel.configureBlocking(false);\n        //创建一个用于接收客户端数据的缓冲区\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        //向 Selector 注册读、写就绪事件,并关联一个 buffer 附件\n        socketChannel.register(selector, SelectionKey.OP_WRITE | SelectionKey.OP_READ, buffer);\n    }\n\n    private String genResponse(String msg) {\n        return \"服务器收到了您的消息：\" + msg;\n    }\n}\n```\n\n上述例子中，服务端使用一个线程就完成了连接接收、数据接收、数据发送的功能。假设有许多的客户端连接，并且每此与客户端的数据交互都很多，势必会影响服务器的响应效率。如果把接收客户端连接的操作单独由一个线程处理，把接收数据和发送数据的操作交给另外的线程完成，就可以提高服务器的并发性能。读者可以尝试自己来实现一个主从线程模式的服务端程序，欢迎在在评论区留言哦！\n\n下面再来看看客户端的实现。客户端和服务端的通信按照它们接收数据和发送数据的协调程度来区分可以分为同步通信和异步通信。比如前面我们演示的传统阻塞式 IO 案例版本 2 就是同步通信，即每次客户端发送一行消息后，必须等到收到了服务端的响应数据后才能再发送下一行数据。而异步通信指的是数据的发送操作和接收操作互不影响，各自独立进行。异步通信使用非阻塞方式更容易实现。\n\n比如下面这个 NIOClient2 类就是采用非阻塞方式来实现异步通信。在 NIOClient2 中定义了两个 ByteBuffer：recvBuf 和 sendBuf。NIOClient2 把用户从控制台输入的数据存放到 sendBuf 中，并将 sendBuf 中的数据发给服务器。把从服务器接收到的数据放在 recvBuf 中，并打印到控制台。由于接收用户控制台输入的线程和发送数据给服务器的线程都会使用 sendBuf，因此加了 synchronized 进行同步。\n\n客户端：\n\n```java\npublic class NIOClient2 {\n    private ByteBuffer recvBuf = ByteBuffer.allocate(1024);\n    private ByteBuffer sendBuf = ByteBuffer.allocate(1024);\n    private Charset charset = Charset.forName(\"UTF-8\");\n    private SocketChannel socketChannel;\n    private Selector selector;\n\n    public NIOClient2() throws IOException {\n        socketChannel = SocketChannel.open();\n        InetAddress localHost = InetAddress.getLocalHost();\n        InetSocketAddress socketAddress = new InetSocketAddress(localHost, 6666);\n        //采用阻塞模式连接服务器\n        socketChannel.connect(socketAddress);\n        //设置为非阻塞模式\n        socketChannel.configureBlocking(false);\n        System.out.println(\"与服务端连接成功！\");\n        selector = Selector.open();\n    }\n\n    public static void main(String[] args) throws IOException {\n        NIOClient2 nioClient2 = new NIOClient2();\n        Thread inputThread = new Thread() {\n            @Override\n            public void run() {\n                nioClient2.receiveInput();\n            }\n        };\n\n        inputThread.start();\n        nioClient2.chat();\n    }\n\n    private void chat() throws IOException {\n        //接收和发送数据\n        socketChannel.register(selector, SelectionKey.OP_WRITE | SelectionKey.OP_READ);\n        while (selector.select() > 0) {\n            Set<SelectionKey> selectionKeys = selector.selectedKeys();\n            Iterator<SelectionKey> iterator = selectionKeys.iterator();\n            while (iterator.hasNext()) {\n                SelectionKey key = null;\n                try {\n                    key = iterator.next();\n                    iterator.remove();\n                    if (key.isWritable()) {\n                        sendMsg(key);\n                    }\n\n                    if (key.isReadable()) {\n                        receiveMsg(key);\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    try {\n                        //发生异常时，使这个 SelectionKey 失效，Selector 不再监控这个 SelectionKey 感兴趣的事件\n                        if (key != null) {\n                            key.cancel();\n                            //关闭这个 SelectionKey 关联的 SocketChannel\n                            key.channel().close();\n                        }\n                    } catch (Exception ex) {\n                        ex.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n\n    private void receiveMsg(SelectionKey key) throws IOException {\n        //接收服务端发来的数据，放到 recvBuf 中，如满一行数据，就输出，然后从 recvBuf 中删除\n        SocketChannel channel = (SocketChannel) key.channel();\n        channel.read(recvBuf);\n        recvBuf.flip();\n        String recvMsg = decode(recvBuf);\n        if (recvMsg.indexOf(\"\\n\") == -1) {\n            return;\n        }\n        String recvMsgLine = recvMsg.substring(0, recvMsg.indexOf(\"\\n\") + 1);\n        System.out.print(\"【服务器】说:\" + recvMsgLine);\n        if (recvMsgLine.contains(\"bye\")) {\n            key.cancel();\n            socketChannel.close();\n            System.out.println(\"与服务器断开连接\");\n            selector.close();\n            System.exit(0);\n        }\n\n        ByteBuffer temp = encode(recvMsgLine);\n        recvBuf.position(temp.limit());\n        //删除已经输出的数据\n        recvBuf.compact();\n    }\n\n    private void sendMsg(SelectionKey key) throws IOException {\n        //发送 sendBuf 中的数据\n        SocketChannel channel = (SocketChannel) key.channel();\n        synchronized (sendBuf) {\n            //为取出数据做好准备\n            sendBuf.flip();\n            //将 sendBuf 中的数据写入到 Channel 中去\n            channel.write(sendBuf);\n            //删除已经发送的数据(通过压缩的方式)\n            sendBuf.compact();\n        }\n    }\n\n    private void receiveInput() {\n        try {\n            BufferedReader inputReader = new BufferedReader(new InputStreamReader(System.in));\n            String msg;\n            while ((msg = inputReader.readLine()) != null) {\n                synchronized (sendBuf) {\n                    sendBuf.put(encode(msg + \"\\r\\n\"));\n                }\n                //如果输入 bye，则终止聊天\n                if (\"bye\".equals(msg)) {\n                    break;\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private ByteBuffer encode(String msg) {\n        return charset.encode(msg);//转为字节\n    }\n\n    private String decode(ByteBuffer buffer) {\n        CharBuffer charBuffer = charset.decode(buffer);//转为字符\n        return charBuffer.toString();\n    }\n}\n```\n\n**版本 3：基于 NIO 重写网络聊天室的案例**\n\n我们对照传统 IO 方式的实现的简单网络聊天室，使用 NIO 来实现同样的功能。传统方式请参照前文的 Server5/Client5。\n\n服务端\n\n```java\npublic class NIOServer3 {\n    private int port = 6666;\n    private ServerSocketChannel serverSocketChannel;\n    private Selector selector;\n    private Charset charset = Charset.forName(\"UTF-8\");\n\n    public NIOServer3() throws IOException {\n        selector = Selector.open();\n        serverSocketChannel = ServerSocketChannel.open();\n        serverSocketChannel.socket().setReuseAddress(true);\n        //设置为非阻塞模式\n        serverSocketChannel.configureBlocking(false);\n        serverSocketChannel.socket().bind(new InetSocketAddress(port));\n        System.out.println(\"server started...\");\n    }\n\n    public static void main(String[] args) throws IOException {\n        new NIOServer3().service();\n    }\n\n    private void service() throws IOException {\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n        while (selector.select() > 0) {\n            for (SelectionKey key : selector.selectedKeys()) {\n                selector.selectedKeys().remove(key);\n                if (key.isAcceptable()) {\n                    ServerSocketChannel ssc = (ServerSocketChannel) key.channel();\n                    SocketChannel socketChannel = ssc.accept();\n                    System.out.println(\"接受到客户端的连接，来自\" + socketChannel.socket().getRemoteSocketAddress());\n                    //设置为非阻塞模式\n                    socketChannel.configureBlocking(false);\n                    socketChannel.register(selector, SelectionKey.OP_READ);\n                }\n\n                if (key.isReadable()) {\n                    SocketChannel sc = (SocketChannel) key.channel();\n                    ByteBuffer buffer = ByteBuffer.allocate(1024);\n                    String msg = \"\";\n                    try {\n                        while (sc.read(buffer) > 0) {\n                            buffer.flip();\n                            msg += charset.decode(buffer);\n                        }\n                        System.out.println(\"客户端【\" + sc.getRemoteAddress() + \"】说：\" + msg);\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                        try {\n                            //对某个 Client 对应的 Channel 读写发生异常时，使这个 SelectionKey 失效，Selector 不再监控这个 SelectionKey 感兴趣的事件\n                            if (key != null) {\n                                key.cancel();\n                                //关闭这个 SelectionKey 关联的 SocketChannel\n                                System.out.println(\"客户端【\" + ((SocketChannel) key.channel()).socket().getRemoteSocketAddress() + \"】下线了\");\n                                key.channel().close();\n                            }\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                        }\n                    }\n\n                    if (msg.length() > 0) {\n                        for (SelectionKey selectedKey : selector.keys()) {\n                            Channel channel = selectedKey.channel();\n                            //遍历 Selector 中的所有注册的 Channel，如果是客户端的 SocketChannel，则群发消息，并排除自己\n                            if (channel instanceof SocketChannel && channel != sc) {\n                                SocketChannel socketChannel = (SocketChannel) channel;\n                                socketChannel.write(charset.encode(\"用户【\" + sc.getRemoteAddress() + \"】说：\" + msg));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n客户端：\n\n```java\npublic class NIOClient3 {\n    private ByteBuffer recvBuf = ByteBuffer.allocate(1024);\n    private ByteBuffer sendBuf = ByteBuffer.allocate(1024);\n    private Charset charset = Charset.forName(\"UTF-8\");\n    private SocketChannel socketChannel;\n    private Selector selector;\n\n    public NIOClient3() throws IOException {\n        socketChannel = SocketChannel.open();\n        InetAddress localHost = InetAddress.getLocalHost();\n        InetSocketAddress socketAddress = new InetSocketAddress(localHost, 6666);\n        //采用阻塞模式连接服务器\n        socketChannel.connect(socketAddress);\n        //设置为非阻塞模式\n        socketChannel.configureBlocking(false);\n        System.out.println(\"与服务端连接成功！\");\n        selector = Selector.open();\n    }\n\n    public static void main(String[] args) throws IOException {\n        NIOClient3 nioClient3 = new NIOClient3();\n        Thread inputThread = new Thread() {\n            @Override\n            public void run() {\n                nioClient3.sendInputMsg();\n            }\n        };\n\n        inputThread.start();\n        nioClient3.receiveMsg();\n    }\n\n    private void receiveMsg() throws IOException {\n        socketChannel.register(selector, SelectionKey.OP_READ);\n        while (selector.select() > 0) {\n            for (SelectionKey key : selector.selectedKeys()) {\n                try {\n                    selector.selectedKeys().remove(key);\n                    if (key.isReadable()) {\n                        SocketChannel sc = (SocketChannel) key.channel();\n                        ByteBuffer buffer = ByteBuffer.allocate(1024);\n                        String msg = \"\";\n                        while (sc.read(buffer) > 0) {\n                            buffer.flip();\n                            msg += charset.decode(buffer);\n                        }\n                        System.out.println(msg);\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    try {\n                        //发生异常时，使这个 SelectionKey 失效，Selector 不再监控这个 SelectionKey 感兴趣的事件\n                        if (key != null) {\n                            key.cancel();\n                            //关闭这个 SelectionKey 关联的 SocketChannel\n                            key.channel().close();\n                        }\n                    } catch (Exception ex) {\n                        ex.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n\n    private void sendInputMsg() {\n        //接收键盘输入的消息并发送数据到服务器\n        try {\n            BufferedReader inputReader = new BufferedReader(new InputStreamReader(System.in));\n            String msg;\n            while ((msg = inputReader.readLine()) != null) {\n                socketChannel.write(charset.encode(msg));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n相比传统的 I/O，基于 NIO 的 socket 编程复杂度提高了很多，这也是我们学习 Netty 的原因之一——简化网络编程。\n\n上面我们以网络通信的例子展示了传统的阻塞式 IO 和新的非阻塞式 IO 的区别，相信通过多个实际的代码例子，能让大家有个直观的感受，有效复习了一下 Java 的 IO 体系。在介绍 Netty 这款封装了 Java NIO 的框架之前，我们稍安勿躁，先补充一下 。\n\n### NIO 的理论基础\n\n#### 用户空间和内核空间\n\n通俗地讲，内核空间（kernel space）是操作系统内核才能访问的区域，是受保护的内存区域，普通应用程序不能访问。而用户空间（user space）则是普通应用程序访问的内存空间。用户空间和内核空间概念的由来和 CPU 的发展有很大关系。在 CPU 的保护模式下，系统需要保护 CPU 赖以运行的资料；为了保证操作系统内核资料，需要把内存空间进行划分为 OS 内核运行的空间和普通应用程序运行的空间，两者不能越界。所谓的空间就是内存地址。操作系统为了保护自己不被普通应用程序破坏，对内核空间进行了一些约束，比如访问权限、页的换入换出，优先级等。\n\n目前的操作系统都是采用虚拟存储器。因此内核空间和用户空间都是指的虚拟空间，也就是虚拟地址。\n\n比如对于 32 位的 Linux 系统而言，用户空间和内核空间划分如下：\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/8e7d3c50-93c3-11eb-987a-1fa99aac0083.png)\n\n32 位操作系统的寻址空间（虚拟地址空间）为 4G（2 的 32 次方）。在 Linux 中，4G 虚拟地址空间中的最高的 1G 字节空间分配给内核独享使用。低地址的 3G 空间为应用程序共享，即每个应用程序都有最大 3G 的虚拟地址空间。每个进程可以通过系统调用切换进入内核，所有进程可以共享 Linux 内核。因此可以认为每个进程都有 4G 字节的虚拟空间。\n\nLinux 内部结构图如下：\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/999dbf10-93c3-11eb-9ad9-9f9d57de4e5a.png)\n\n#### Linux 的五种 I/O 模型\n\n众所周知，出于对 OS 安全性的考虑，用户进程是不能直接操作 I/O 设备的。必须通过系统调用请求操作系统内核来协助完成 I/O 动作。\n\n下图展示了 Linux I/O 的过程。\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/a31a07b0-93c3-11eb-b9e3-79badd8952b7.png)\n\n操作系统内核收到用户进程发起的请求后，从 I/O 设备读取数据到 kernel buffer 中，再将 buffer 中的数据拷贝到用户进程的地址空间，用户进程获取到数据后返回给客户端。\n\n在 I/O 过程中，对于输入操作通常有两个不同的阶段：\n\n- 等待数据准备好\n- 将数据从内核缓冲区拷贝到用户进程\n\n根据这两个阶段等待方式的不同，可以将 Linux I/O 分为 5 种模式：\n\n- blocking I/O，阻塞式 I/O\n- nonblocking I/O，非阻塞式 I/O\n- I/O multiplexing（select and poll），I/O 多路复用\n- signal driven I/O（SIGIO），信号驱动 I/O\n- asynchronous I/O（the POSIX aio_functions），异步 I/O\n\n对于 Socket 上的输入操作，第 1 步通常是等待网络上的数据到达。当数据包到达时，它被复制到内核的缓冲区中。第 2 步是从内核缓冲区复制数据到应用程序缓冲区。\n\n下面详细介绍 Linux 中的 5 种 I/O 模式。\n\n**1. Blocking I/O**\n\n默认情况下，所有的 Socket 都是阻塞式的。下图展示了一个基于 UDP 的网络数据获取流程。\n\n用户进程调用了 recvfrom 系统调用，此后一直处于等待状态，直到数据包到达并被拷贝到应用程序缓冲区，或者发生 error 才返回。整个过程从开始 recvfrom 调用到它返回一直处于阻塞状态。当 recvfrom 调用返回后，应用进程才能处理数据。\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/b7816b30-93c3-11eb-987a-1fa99aac0083.png)\n\n**2. Nonblocking I/O**\n\n可以设置 Socket 为非阻塞模式。这种设置相当于告诉内核“当 I/O 操作时，如果请求是不可能完成的，不要把进程进入睡眠状态，返回一个错误即可“。下图展示了整个流程：在前三次调用 recvfrom 系统调用时，没有就绪的数据返回，所以内核立即返回 EWOULDBLOCK 错误。第四次调用 recvfrom 时，数据报已经准备好，它被复制到应用程序缓冲区中，然后 recvfrom 成功返回。最后应用进程对数据进行处理。当应用程序在一个非阻塞描述符上循环调用 recvfrom 系统调用时，这种方式也被称为轮询。应用程序不断轮询内核，以查看是否有某些操作准备好了。很明显，这通常会浪费 CPU 时间，但这种模式偶尔也会被使用。通常在专门用于一个功能的系统上使用。\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/dead57a0-93c3-11eb-ad2b-3b3e8354e125.png)\n\n**3. I/O Multiplexing**\n\nI/O 多路复用通常使用 select 或者 poll 系统调用。这种方式下的阻塞只是被 select 或者 poll 这两个系统调用阻塞，而不会阻塞实际的 I/O 系统调用（即数据输入、输出不会被阻塞）。下图展示了整个过程。当调用 select 时，应用进程被阻塞。同时，系统内核会“监视”所有 select 负责的 Socket。只要其中有 1 个 Socket 的数据准备好了，select 调用就返回。然后调用 recvfrom 将数据报复制到应用程序缓冲区，最后返回给用户进程。\n\n乍一看，这种方式和 blocking I/O 相比似乎更差，因为整个过程产生了 2 次系统调用，select 和 recvfrom。但是使用 select 的好处是可以同时等待多个描述符准备好。换句话说可以同时“聆听”多个 Socket 通道，同时处理多个连接。select 的优势不是对于单个连接处理得更快，而是能同时处理更多的连接。这和多线程阻塞式 I/O 有点类似。只不过后者是使用多个线程（每个文件描述符对应一个线程）来处理 I/O，每个线程都可以自由地调用阻塞式系统调用，比如 recvfrom。我们知道线程多了会带来上下文切换的开销，因此未必优于 select 方式。在前面 Java NIO 的例子中，我们已经体会到了 selector 带来的性能提升。\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/ef1e2c90-93c3-11eb-bfbd-21c3c45ef49d.png)\n\nLinux 内核将所有外部设备都当成一个个文件来操作。我们对文件的读写都通过调用内核提供的系统调用；内核给我们返回一个文件描述符（file descriptor）。而对一个 Socket 的读写也会有相应的描述符，称为 socketfd。应用进程对文件的读写通过对 fd 的读写完成。\n\n**4. Signal Driven I/O**\n\n信号驱动方式就是等数据准备好后，由内核发出 SIGIO 信号通知应用进程。示意图如下：\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/fe975b10-93c3-11eb-b56e-cd09bd777412.png)\n\n应用进程通过 sigaction 系统调用建立起 SIGIO 信号处理通道，然后此系统调用就返回，不阻塞。当数据准备好后，内核会产生一个 SIGIO 信号通知到应用进程。此时既可以使用 SIGIO 信号处理器通过 recvfrom 系统调用读取数据，然后通知应用进程数据准备好了，可以处理了；也可以直接通知应用进程读取数据。不管使用何种方式，好处都是应用进程不会阻塞，可以继续执行，只要等待信号通知数据准备好被处理了、数据准备好被读取了。\n\n**5. asynchronous I/O**\n\n异步 I/O 是由 POSIX 规范定义的。和信号驱动 I/O 模型的区别是前者内核告诉我们何时可以开始一个 I/O 操作，而后者内核会告诉我们一个 I/O 操作何时完成。示意图如下：\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/078630c0-93c4-11eb-bcbc-e5059ba8d4c2.png)\n\n当用户进程发起系统调用后会立刻返回，并把所有的任务都交给内核去完成，不会被阻塞等待 I/O 完成。内核完成之后，只需返回一个信号告诉用户进程已经完成就可以了。\n\n五种 I/O 模式可以从同步、异步，阻塞、非阻塞两个维度来划分：\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/164a6720-93c4-11eb-9ad9-9f9d57de4e5a.png)\n\n#### 零拷贝（Zero-copy）\n\n在介绍零拷贝之前我们先看看传统的 Java 网络 IO 编程是怎样的。\n\n下面代码展示了一个典型的 Java 网络程序。\n\n```java\nFile file = new File(\"index.jsp\");\n        RandomAccessFile rdf = new RandomAccessFile(file, \"rw\");\n\n        byte[] arr = new byte[(int) file.length()];\n        rdf.read(arr);\n\n        Socket socket = new ServerSocket(8080).accept();\n        socket.getOutputStream().write(arr);\n```\n\n程序中调用 RandomAccessFile 的 read 方法将 index.jsp 的内容读取到字节数组中。然后调用 write 方法将字节数组中的数据写入到 Socket 对应的输出流中发送给客户端。那么 Java 应用程序中的 read、write 方法对应到 OS 底层是怎样的呢。下图展示了这个过程。\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/2757f140-93c4-11eb-bcbc-e5059ba8d4c2.png)\n\n图中上半部分记录了用户态和内核态的上下文切换。下半部分展示了数据的复制过程。上述 Java 代码对应的操作系统底层步骤：\n\n1. read 方法触发操作系统从用户态到切换到内核态。同时通过 DMA 的方式从磁盘读取文件到内核缓冲区。DMA（Direct Memory Access）是 l/O 设备与主存之间由硬件组成的直接数据通路。即不需要 CPU 拷贝数据到内存，而是直接由 DMA 引擎传输数据到内存。\n2. 紧接着发生第二次数据拷贝，即从内核缓冲区拷贝到用户缓冲区，同时发生一次内核态到用户态的上下文切换。\n3. 调用 write 方法时，触发第三次数据拷贝，即从用户缓冲区拷贝到 Socket 缓冲区。同时发生一次用户态到内核态的上下文切换。\n4. 最后数据从 Socket 缓冲区异步拷贝到网络协议引擎，这一步采用的是 DMA 方式。同时没有发生上下文切换。\n5. write 方法返回时，触发了最后一次内核态到用户态的切换。\n\n由此可见，复制的操作太频繁，共有 2 次 DMA 拷贝、2 次 CPU 拷贝、4 次上下文切换。能否优化呢？\n\n这就要介绍称之为”零拷贝”的技术。首先声明，零拷贝技术依赖底层 OS 内核提供的支持。Linux 中提供的这类支持有 mmap()，sendfile() 以及 splice() 系统调用。说白了就是减少数据在操作系统内核的缓冲区和用户应用程序地址空间的缓冲区之间进行拷贝。\n\n**mmap**\n\nmmap 通过内存映射，将文件通过 DMA 的方式映射到内核缓冲区。操作系统会把这段内核缓冲区与应用程序（用户空间）共享。这样，在进行网络传输时，就能减少内核空间到用户空间的拷贝次数。此时输出数据时只要从内核缓冲区拷贝到 Socket 缓冲区即可。可见减少了一次 CPU 拷贝，但是上下文切换次数并没有减少。整个过程共 2 次 DMA 拷贝，1 次 CPU 拷贝，4 次上下文切换。示意图如下。\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/0551d9b0-93c6-11eb-9ad9-9f9d57de4e5a.png)\n\n**sendFile**\n\nLinux 2.1 开始提供了 sendFile 函数，其基本原理是：数据根本不经过用户态，直接从 Kernel Buffer 进入到 Socket Buffer，并且由于和用户态完全无关，这就避免了一次上下文切换。下图展示了整个过程。磁盘中的数据通过 DMA 引擎从复制到内核缓冲区。调用 write 方法时从内核缓冲区拷贝到 Socket 缓冲区。由于在同一个空间，因此没有发生上下文切换。最后由 Socket 缓冲区拷贝到协议引擎。整个过程共发生了 2 次 DMA 拷贝，1 次 CPU 拷贝，3 次上下文切换。\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/40243580-93c4-11eb-8454-130424f2d76f.png)\n\n在 Linux 2.4 版本中，进一步做了优化。从 Kernel Buffer 拷贝到 Socket Buffer 的操作也省了，直接拷贝到协议栈，再次减少了 CPU 数据拷贝。下图展示了整个流程。本地文件 index.jsp 要传输到网络中，只需 2 次拷贝。第一次是 DMA 引擎从文件拷贝到内核缓冲区；第二次是从内核缓冲区将数据拷贝到网络协议栈；内核缓存区只会拷贝一些元信息，比如 offset 和 length 信息到 SocketBuffer，基本无消耗。\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/d7e0d040-93c4-11eb-b56e-cd09bd777412.png)\n\n综上所述，最后一种方式发生了 2 次 DMA 拷贝、0 次 CPU 拷贝、3 次上下文切换。这就是所谓的“零拷贝”实现。\n\n因此零拷贝通常是站在操作系统的角度看，即整个过程中，内核缓冲区之间是没有重复数据的。同时伴随着更少的上下文切换。这就带来了 IO 性能质的提升！\n\n实际开发中，mmap 和 sendFile 都有应用，可以认为是“零拷贝”的两种实现方式。它们都有各自的适用场景。mmap 更适合少量数据读写，sendFile 适合大文件传输。sendFile 可以利用 DMA 方式将内核缓冲区将数据拷贝到网络协议栈，减少 CPU 拷贝，而 mmap 则不能（必须从内核拷贝到 Socket 缓冲区）。\n\n案例：RocketMQ 在 CommitLog 和 CosumerQueue 的实现中都采用了 mmap。而 Kafka 的零拷贝实现则使用了 sendFile。\n\nRocketMQ 和 Kafka 高性能的原因之一便是顺序写入和近似顺序读取 + 零拷贝。\n\n使用 Java NIO 实现零拷贝见前文 NIO 案例。\n\n### 线程模型\n\n线程模型通常是指线程的使用方式。在 Java I/O 中，主要有 2 种线程模型，即传统的阻塞式 I/O 模型和 Reactor 模型。\n\n#### 传统的阻塞式 I/O\n\n正如我们前面写的传统 IO 通信案例版本 4。在版本 4 的例程中，为了同时处理多个客户端的请求，服务端为每一个连接都会分配一个新的线程处理。这个独立的线程完成数据的读写和业务处理。这虽然是“传统”的处理方式，但是也是最经典的 IO 线程模型。示意图如下：\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/ee0e26b0-93c4-11eb-8398-b3d8a71d8c34.png)\n\n该模型采用阻塞式 IO，连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在 read 操作，造成线程资源浪费。\n\n当并发数很大，就会创建大量的线程，占用大量系统资源。\n\n#### Reactor 模式\n\n针对传统 IO 的缺点，提出了解决方案。\n\n- 方案 1：基于 I/O 复用模型。即多个连接共用一个阻塞对象，当某个连接有新的数据准备好时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。\n- 方案 2：基于线程池复用线程资源，不需要给每个连接创建一个线程。将连接完成后的业务处理任务分配给线程池中的线程进行处理。这样一个线程可以处理到多个客户端的业务。\n\n总结一句话，I/O 多路复用 + 线程池，就是所谓的“Reactor 模式”的基本设计思想。其实我们前面 NIO 案例中的版本 1 的实现方式就有点这种味道，只不过不是严格意义上的 Reactor 模式罢了。\n\nReactor 模式中的两个核心组件：\n\n- 组件 1：Reactor。Reactor 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对 I/O 事件做出反应。\n- 组件 2：Handlers。完成实际 I/O 事件中数据的读写和要做的一系列业务处理。\n\n根据 Reactor 的数量和业务处理线程池线程数量不同，又分为 3 种具体实现：单 Reactor 单线程、单 Reactor 多线程、主从 Reactor。\n\n##### 单 Reactor 单线程\n\nReactor 对象通过 I/O 复用模型（在 Java NIO 中就是使用 Selector）监控客户端请求事件，收到事件后通过 dispatch 进行分发。如果是建立连接请求事件，则由 acceptor 通过 accept 处理连接请求，然后创建一个 Handler 对象处理连接完成后的数据**读** -> **业务处理** -> **写**。\n\n注意，上述过程都是发生在一个线程里，只不过是非阻塞方式。工作原理示意图如下：\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/ff03e310-93c4-11eb-9ad9-9f9d57de4e5a.png)\n\n这种方式，服务器端使用一个线程基于多路复用就完成了所有的 IO 操作（包括连接，读数据、业务处理、写数据等），没有多线程间通信、竞争的问题，实现简单。但是如果客户端连接数较多，将无法支撑。因为只有一个线程，不能完全发挥多核 CPU 的性能。且 Handler 在处理某个连接上的业务时，整个线程无法处理其他连接事件。如果业务处理很耗时，很容易会导致性能瓶颈。如果线程意外终止，或者进入死循环，会导致整个系统不可用。\n\n##### 单 Reactor 多线程\n\n为了克服上述模型的缺点，我们可以考虑将**非 IO** 操作从 Reactor 线程的处理中移出，来提升 Reactor 线程的性能。\n\n具体说明如下：\n\neactor 对象通过 select 监控 client 端的请求事件，收到事件后，通过 dispatch 进行分发。\n\n如果是连接建立请求，则由 acceptor 通过 accept 处理连接请求，然后分配一个 Handler 对象处理完成连接后的数据读写。\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/07d60900-93c5-11eb-9c54-0984fa5d923a)\n\n如果不是连接请求，则由 reactor 分发（dispatch）给连接对应的 Handler 来处理。Handler 和 Reactor 运行在同一个线程中。\n\nHandler 只负责响应 IO 事件，不做具体的业务处理。read 数据后，会分发给 Worker 线程池的某个线程进行业务逻辑处理。\n\nWorker 线程池会分配单独的线程完成真正的业务处理，包括编解码、逻辑计算，完成处理后将结果数据返回给 handler。\n\nHandler 收到响应后，通过 send 将数据返回给 client 端。\n\n这种模型下，Reactor 线程只负责处理所有的事件的监听和响应（数据读、写），而不参与数据的业务处理（数据编解码、逻辑处理）。业务处理的任务交给线程池中的线程处理，提高了并发性能，特别是在业务复杂的情况下。工作原理示意图如下：\n\n##### 主从 Reactor 多线程\n\n上述单 Reactor 多线程模型虽然可以充分压榨 CPU 的性能，但是由于 Reactor 是单线程运行的，所以在高并发场景下 Reactor 容易成为性能瓶颈。可以考虑让 Reactor 在多线程中运行，这就是多 Reactor 模型，也叫主从 Reactor 模型。\n\n具体说明如下：\n\nReactor 主线程 mainReactor 通过 select 监听连接事件，收到事件后，通过 acceptor 处理连接事件。\n\n当 acceptor 处理连接事件后，mainReactor 将连接分配给 subReactor。subReactor 是 Reactor 的子线程，和 mainReactor 不在一个线程中。\n\nsubReactor 将连接加入到连接队列进行监听，并负责创建 handler 进行各种事件的处理（数据的读、写）。\n\nsubReactor 也通过 select 监听，当有新事件发生时，subreactor 就会调用对应的 handler 处理。\n\nhandler 只负责数据的 I/O，针对数据的业务处理还是由 worker 线程池中的线程处理，并返回结果。\n\nhandler 收到 worker 线程的响应数据后，通过 send 将结果数据返回给 client。\n\nReactor 主线程可以对应多个 Reactor 子线程，即 MainRecator 能关联多个 SubReactor。和 worker 线程池一样，线程数都能配置。\n\n这种方式的优点非常明显，就是减轻了 mainRecator 的负担，让其只负责处理连接请求，不包含 I/O 的处理。后续的处理统统交给 SubReactor。主、从 Reactor 分别运行在不同的线程中，且线程数可以配置。业务处理还是交给 worker 线程池中的线程执行。\n\n主从 Reactor 线程模型在许多项目中都有应用，比如 Nginx 的主从 Reactor 多进程模型、Netty 的主从多线程模型等。\n\n其工作原理示意图如下（注意观察和上面一个图的区别）：\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/1409d080-93c5-11eb-8398-b3d8a71d8c34.png)\n\n### 总结\n\n本篇我们带领读者回顾了一下 Java 中 IO 相关的理论知识，并通过多个代码案例加深了理解。', '![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/8e7d3c50-93c3-11eb-987a-1fa99aac0083.png)', b'1', b'1', b'0', b'1', '2024-12-23 10:51:53', '2024-12-23 10:54:40', 1, 15578, 78, 10, b'0', '', 1);
INSERT INTO `blog` VALUES (10, 'Java NIO浅析', 'https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-f47206d5b5e64448744b85eaf568f92d_1440w.png', 'NIO（Non-blocking I/O，在Java领域，也称为New I/O），是一种同步非阻塞的I/O模型，也是I/O多路复用的基础，已经被越来越多地应用到大型应用服务器，成为解决高并发与大量连接、I/O处理问题的有效方式。\n\n那么NIO的本质是什么样的呢？它是怎样与事件模型结合来解放线程、提高系统吞吐的呢？\n\n本文会从传统的阻塞I/O和线程池模型面临的问题讲起，然后对比几种常见I/O模型，一步步分析NIO怎么利用事件模型处理I/O，解决线程池瓶颈处理海量连接，包括利用面向事件的方式编写服务端/客户端程序。最后延展到一些高级主题，如Reactor与Proactor模型的对比、Selector的唤醒、Buffer的选择等。\n\n注：本文的代码都是伪代码，主要是为了示意，不可用于生产环境。\n\n# 传统BIO模型分析\n\n让我们先回忆一下传统的服务器端同步阻塞I/O处理（也就是BIO，Blocking I/O）的经典编程模型：\n\n```java\n{\n ExecutorService executor = Excutors.newFixedThreadPollExecutor(100);//线程池\n\n ServerSocket serverSocket = new ServerSocket();\n serverSocket.bind(8088);\n while(!Thread.currentThread.isInturrupted()){//主线程死循环等待新连接到来\n Socket socket = serverSocket.accept();\n executor.submit(new ConnectIOnHandler(socket));//为新的连接创建新的线程\n}\n\nclass ConnectIOnHandler extends Thread{\n    private Socket socket;\n    public ConnectIOnHandler(Socket socket){\n       this.socket = socket;\n    }\n    public void run(){\n      while(!Thread.currentThread.isInturrupted()&&!socket.isClosed()){死循环处理读写事件\n          String someThing = socket.read()....//读取数据\n          if(someThing!=null){\n             ......//处理数据\n             socket.write()....//写数据\n          }\n\n      }\n    }\n}\n```\n\n这是一个经典的每连接每线程的模型，之所以使用多线程，主要原因在于socket.accept()、socket.read()、socket.write()三个主要函数都是同步阻塞的，当一个连接在处理I/O的时候，系统是阻塞的，如果是单线程的话必然就挂死在那里；但CPU是被释放出来的，开启多线程，就可以让CPU去处理更多的事情。其实这也是所有使用多线程的本质：\n\n1. 利用多核。\n2. 当I/O阻塞系统，但CPU空闲的时候，可以利用多线程使用CPU资源。\n\n现在的多线程一般都使用线程池，可以让线程的创建和回收成本相对较低。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的I/O并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。\n\n不过，这个模型最本质的问题在于，严重依赖于线程。但线程是很”贵”的资源，主要表现在：\n\n1. 线程的创建和销毁成本很高，在Linux这样的操作系统中，线程本质上就是一个进程。创建和销毁都是重量级的系统函数。\n2. 线程本身占用较大内存，像Java的线程栈，一般至少分配512K～1M的空间，如果系统中的线程数过千，恐怕整个JVM的内存都会被吃掉一半。\n3. 线程的切换成本是很高的。操作系统发生线程切换的时候，需要保留线程的上下文，然后执行系统调用。如果线程数过高，可能执行线程切换的时间甚至会大于线程执行的时间，这时候带来的表现往往是系统load偏高、CPU sy使用率特别高（超过20%以上)，导致系统几乎陷入不可用的状态。\n4. 容易造成锯齿状的系统负载。因为系统负载是用活动线程数或CPU核心数，一旦线程数量高但外部网络环境不是很稳定，就很容易造成大量请求的结果同时返回，激活大量阻塞线程从而使系统负载压力过大。\n\n所以，当面对十万甚至百万级连接的时候，传统的BIO模型是无能为力的。随着移动端应用的兴起和各种网络游戏的盛行，百万级长连接日趋普遍，此时，必然需要一种更高效的I/O处理模型。\n\n# NIO是怎么工作的\n\n很多刚接触NIO的人，第一眼看到的就是Java相对晦涩的API，比如：Channel，Selector，Socket什么的；然后就是一坨上百行的代码来演示NIO的服务端Demo……瞬间头大有没有？\n\n我们不管这些，抛开现象看本质，先分析下NIO是怎么工作的。\n\n## 常见I/O模型对比\n\n所有的系统I/O都分为两个阶段：等待就绪和操作。举例来说，读函数，分为等待系统可读和真正的读；同理，写函数分为等待网卡可以写和真正的写。\n\n需要说明的是等待就绪的阻塞是不使用CPU的，是在“空等”；而真正的读写操作的阻塞是使用CPU的，真正在”干活”，而且这个过程非常快，属于memory copy，带宽通常在1GB/s级别以上，可以理解为基本不耗时。\n\n下图是几种常见I/O模型的对比：\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-f47206d5b5e64448744b85eaf568f92d_1440w.png)\n\n以socket.read()为例子：\n\n传统的BIO里面socket.read()，如果TCP RecvBuffer里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据。\n\n对于NIO，如果TCP RecvBuffer有数据，就把数据从网卡读到内存，并且返回给用户；反之则直接返回0，永远不会阻塞。\n\n最新的AIO(Async I/O)里面会更进一步：不但等待就绪是非阻塞的，就连数据从网卡到内存的过程也是异步的。\n\n换句话说，BIO里用户最关心“我要读”，NIO里用户最关心”我可以读了”，在AIO模型里用户更需要关注的是“读完了”。\n\nNIO一个重要的特点是：socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，真正的I/O操作是同步阻塞的（消耗CPU但性能非常高）。\n\n## 如何结合事件模型使用NIO同步非阻塞特性\n\n回忆BIO模型，之所以需要多线程，是因为在进行I/O操作的时候，一是没有办法知道到底能不能写、能不能读，只能”傻等”，即使通过各种估算，算出来操作系统没有能力进行读写，也没法在socket.read()和socket.write()函数中返回，这两个函数无法进行有效的中断。所以除了多开线程另起炉灶，没有好的办法利用CPU。\n\nNIO的读写函数可以立刻返回，这就给了我们不开线程利用CPU的最好机会：如果一个连接不能读写（socket.read()返回0或者socket.write()返回0），我们可以把这件事记下来，记录的方式通常是在Selector上注册标记位，然后切换到其它就绪的连接（channel）继续进行读写。\n\n下面具体看下如何利用事件模型单线程处理所有I/O请求：\n\nNIO的主要事件有几个：读就绪、写就绪、有新连接到来。\n\n我们首先需要注册当这几个事件到来的时候所对应的处理器。然后在合适的时机告诉事件选择器：我对这个事件感兴趣。对于写操作，就是写不出去的时候对写事件感兴趣；对于读操作，就是完成连接和系统没有办法承载新读入的数据的时；对于accept，一般是服务器刚启动的时候；而对于connect，一般是connect失败需要重连或者直接异步调用connect的时候。\n\n其次，用一个死循环选择就绪的事件，会执行系统调用（Linux 2.6之前是select、poll，2.6之后是epoll，Windows是IOCP），还会阻塞的等待新事件的到来。新事件到来的时候，会在selector上注册标记位，标示可读、可写或者有连接到来。\n\n注意，select是阻塞的，无论是通过操作系统的通知（epoll）还是不停的轮询(select，poll)，这个函数是阻塞的。所以你可以放心大胆地在一个while(true)里面调用这个函数而不用担心CPU空转。\n\n所以我们的程序大概的模样是：\n\n```java\ninterface ChannelHandler{\n      void channelReadable(Channel channel);\n      void channelWritable(Channel channel);\n   }\n   class Channel{\n     Socket socket;\n     Event event;//读，写或者连接\n   }\n\n   //IO线程主循环:\n   class IoThread extends Thread{\n   public void run(){\n   Channel channel;\n   while(channel=Selector.select()){//选择就绪的事件和对应的连接\n      if(channel.event==accept){\n         registerNewChannelHandler(channel);//如果是新连接，则注册一个新的读写处理器\n      }\n      if(channel.event==write){\n         getChannelHandler(channel).channelWritable(channel);//如果可以写，则执行写事件\n      }\n      if(channel.event==read){\n          getChannelHandler(channel).channelReadable(channel);//如果可以读，则执行读事件\n      }\n    }\n   }\n   Map<Channel，ChannelHandler> handlerMap;//所有channel的对应事件处理器\n  }\n```\n\n这个程序很简短，也是最简单的Reactor模式：注册所有感兴趣的事件处理器，单线程轮询选择就绪事件，执行事件处理器。\n\n## 优化线程模型\n\n由上面的示例我们大概可以总结出NIO是怎么解决掉线程的瓶颈并处理海量连接的：\n\nNIO由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。除了事件的轮询是阻塞的（没有可干的事情必须要阻塞），剩余的I/O操作都是纯CPU操作，没有必要开启多线程。\n\n并且由于线程的节约，连接数大的时候因为线程切换带来的问题也随之解决，进而为处理海量连接提供了可能。\n\n单线程处理I/O的效率确实非常高，没有线程切换，只是拼命的读、写、选择事件。但现在的服务器，一般都是多核处理器，如果能够利用多核心进行I/O，无疑对效率会有更大的提高。\n\n仔细分析一下我们需要的线程，其实主要包括以下几种：\n\n1. 事件分发器，单线程选择就绪的事件。\n2. I/O处理器，包括connect、read、write等，这种纯CPU操作，一般开启CPU核心个线程就可以。\n3. 业务线程，在处理完I/O后，业务一般还会有自己的业务逻辑，有的还会有其他的阻塞I/O，如DB操作，RPC等。只要有阻塞，就需要单独的线程。\n\nJava的Selector对于Linux系统来说，有一个致命限制：同一个channel的select不能被并发的调用。因此，如果有多个I/O线程，必须保证：一个socket只能属于一个IoThread，而一个IoThread可以管理多个socket。\n\n另外连接的处理和读写的处理通常可以选择分开，这样对于海量连接的注册和读写就可以分发。虽然read()和write()是比较高效无阻塞的函数，但毕竟会占用CPU，如果面对更高的并发则无能为力。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-22efc734724d07251f8293e2f1143639_1440w.png)\n\n# NIO在客户端的魔力\n\n通过上面的分析，可以看出NIO在服务端对于解放线程，优化I/O和处理海量连接方面，确实有自己的用武之地。那么在客户端上，NIO又有什么使用场景呢?\n\n常见的客户端BIO+连接池模型，可以建立n个连接，然后当某一个连接被I/O占用的时候，可以使用其他连接来提高性能。\n\n但多线程的模型面临和服务端相同的问题：如果指望增加连接数来提高性能，则连接数又受制于线程数、线程很贵、无法建立很多线程，则性能遇到瓶颈。\n\n## 每连接顺序请求的Redis\n\n对于Redis来说，由于服务端是全局串行的，能够保证同一连接的所有请求与返回顺序一致。这样可以使用单线程＋队列，把请求数据缓冲。然后pipeline发送，返回future，然后channel可读时，直接在队列中把future取回来，done()就可以了。\n\n伪代码如下：\n\n```java\nclass RedisClient Implements ChannelHandler{\n private BlockingQueue CmdQueue;\n private EventLoop eventLoop;\n private Channel channel;\n class Cmd{\n  String cmd;\n  Future result;\n }\n public Future get(String key){\n   Cmd cmd= new Cmd(key);\n   queue.offer(cmd);\n   eventLoop.submit(new Runnable(){\n        List list = new ArrayList();\n        queue.drainTo(list);\n        if(channel.isWritable()){\n         channel.writeAndFlush(list);\n        }\n   });\n}\n public void ChannelReadFinish(Channel channel，Buffer Buffer){\n    List result = handleBuffer();//处理数据\n    //从cmdQueue取出future，并设值，future.done();\n}\n public void ChannelWritable(Channel channel){\n   channel.flush();\n}\n}\n```\n\n这样做，能够充分的利用pipeline来提高I/O能力，同时获取异步处理能力。\n\n## 多连接短连接的HttpClient\n\n类似于竞对抓取的项目，往往需要建立无数的HTTP短连接，然后抓取，然后销毁，当需要单机抓取上千网站线程数又受制的时候，怎么保证性能呢?\n\n何不尝试NIO，单线程进行连接、写、读操作？如果连接、读、写操作系统没有能力处理，简单的注册一个事件，等待下次循环就好了。\n\n如何存储不同的请求/响应呢？由于http是无状态没有版本的协议，又没有办法使用队列，好像办法不多。比较笨的办法是对于不同的socket，直接存储socket的引用作为map的key。\n\n## 常见的RPC框架，如Thrift，Dubbo\n\n这种框架内部一般维护了请求的协议和请求号，可以维护一个以请求号为key，结果的result为future的map，结合NIO+长连接，获取非常不错的性能。\n\n# NIO高级主题\n\n## Proactor与Reactor\n\n一般情况下，I/O 复用机制需要事件分发器（event dispatcher）。 事件分发器的作用，即将那些读写事件源分发给各读写事件的处理者，就像送快递的在楼下喊: 谁谁谁的快递到了， 快来拿吧！开发人员在开始的时候需要在分发器那里注册感兴趣的事件，并提供相应的处理者（event handler)，或者是回调函数；事件分发器在适当的时候，会将请求的事件分发给这些handler或者回调函数。\n\n涉及到事件分发器的两种模式称为：Reactor和Proactor。 Reactor模式是基于同步I/O的，而Proactor模式是和异步I/O相关的。在Reactor模式中，事件分发器等待某个事件或者可应用或个操作的状态发生（比如文件描述符可读写，或者是socket可读写），事件分发器就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作。\n\n而在Proactor模式中，事件处理者（或者代由事件分发器发起）直接发起一个异步读写操作（相当于请求），而实际的工作是由操作系统来完成的。发起时，需要提供的参数包括用于存放读到数据的缓存区、读的数据大小或用于存放外发数据的缓存区，以及这个请求完后的回调函数等信息。事件分发器得知了这个请求，它默默等待这个请求的完成，然后转发完成事件给相应的事件处理者或者回调。举例来说，在Windows上事件处理者投递了一个异步IO操作（称为overlapped技术），事件分发器等IO Complete事件完成。这种异步模式的典型实现是基于操作系统底层异步API的，所以我们可称之为“系统级别”的或者“真正意义上”的异步，因为具体的读写是由操作系统代劳的。\n\n举个例子，将有助于理解Reactor与Proactor二者的差异，以读操作为例（写操作类似）。\n\n#### 在Reactor中实现读\n\n- 注册读就绪事件和相应的事件处理器。\n- 事件分发器等待事件。\n- 事件到来，激活分发器，分发器调用事件对应的处理器。\n- 事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。\n\n#### 在Proactor中实现读：\n\n- 处理器发起异步读操作（注意：操作系统必须支持异步IO）。在这种情况下，处理器无视IO就绪事件，它关注的是完成事件。\n- 事件分发器等待操作完成事件。\n- 在分发器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分发器读操作完成。\n- 事件分发器呼唤处理器。\n- 事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分发器。\n\n可以看出，两个模式的相同点，都是对某个I/O事件的事件通知（即告诉某个模块，这个I/O操作可以进行或已经完成)。在结构上，两者也有相同点：事件分发器负责提交IO操作（异步)、查询设备是否可操作（同步)，然后当条件满足时，就回调handler；不同点在于，异步情况下（Proactor)，当回调handler时，表示I/O操作已经完成；同步情况下（Reactor)，回调handler时，表示I/O设备可以进行某个操作（can read 或 can write)。\n\n下面，我们将尝试应对为Proactor和Reactor模式建立可移植框架的挑战。在改进方案中，我们将Reactor原来位于事件处理器内的Read/Write操作移至分发器（不妨将这个思路称为“模拟异步”），以此寻求将Reactor多路同步I/O转化为模拟异步I/O。以读操作为例子，改进过程如下：\n\n- 注册读就绪事件和相应的事件处理器。并为分发器提供数据缓冲区地址，需要读取数据量等信息。\n- 分发器等待事件（如在select()上等待）。\n- 事件到来，激活分发器。分发器执行一个非阻塞读操作（它有完成这个操作所需的全部信息），最后调用对应处理器。\n- 事件处理器处理用户自定义缓冲区的数据，注册新的事件（当然同样要给出数据缓冲区地址，需要读取的数据量等信息），最后将控制权返还分发器。\n  如我们所见，通过对多路I/O模式功能结构的改造，可将Reactor转化为Proactor模式。改造前后，模型实际完成的工作量没有增加，只不过参与者间对工作职责稍加调换。没有工作量的改变，自然不会造成性能的削弱。对如下各步骤的比较，可以证明工作量的恒定：\n\n#### 标准/典型的Reactor：\n\n- 步骤1：等待事件到来（Reactor负责）。\n- 步骤2：将读就绪事件分发给用户定义的处理器（Reactor负责）。\n- 步骤3：读数据（用户处理器负责）。\n- 步骤4：处理数据（用户处理器负责）。\n\n#### 改进实现的模拟Proactor：\n\n- 步骤1：等待事件到来（Proactor负责）。\n- 步骤2：得到读就绪事件，执行读数据（现在由Proactor负责）。\n- 步骤3：将读完成事件分发给用户处理器（Proactor负责）。\n- 步骤4：处理数据（用户处理器负责）。\n\n步骤1：等待事件到来（Proactor负责）。\n\n步骤2：得到读就绪事件，执行读数据（现在由Proactor负责）。\n\n步骤3：将读完成事件分发给用户处理器（Proactor负责）。\n\n步骤4：处理数据（用户处理器负责）。\n\n对于不提供异步I/O API的操作系统来说，这种办法可以隐藏Socket API的交互细节，从而对外暴露一个完整的异步接口。借此，我们就可以进一步构建完全可移植的，平台无关的，有通用对外接口的解决方案。\n\n代码示例如下：\n\n```java\ninterface ChannelHandler{\n      void channelReadComplate(Channel channel，byte[] data);\n      void channelWritable(Channel channel);\n   }\n   class Channel{\n     Socket socket;\n     Event event;//读，写或者连接\n   }\n\n   //IO线程主循环：\n   class IoThread extends Thread{\n   public void run(){\n   Channel channel;\n   while(channel=Selector.select()){//选择就绪的事件和对应的连接\n      if(channel.event==accept){\n         registerNewChannelHandler(channel);//如果是新连接，则注册一个新的读写处理器\n         Selector.interested(read);\n      }\n      if(channel.event==write){\n         getChannelHandler(channel).channelWritable(channel);//如果可以写，则执行写事件\n      }\n      if(channel.event==read){\n          byte[] data = channel.read();\n          if(channel.read()==0)//没有读到数据，表示本次数据读完了\n          {\n          getChannelHandler(channel).channelReadComplate(channel，data;//处理读完成事件\n          }\n          if(过载保护){\n          Selector.interested(read);\n          }\n\n      }\n     }\n    }\n   Map<Channel，ChannelHandler> handlerMap;//所有channel的对应事件处理器\n   }\n```\n\n## Selector.wakeup()\n\n### 主要作用\n\n解除阻塞在Selector.select()/select(long)上的线程，立即返回。\n\n两次成功的select之间多次调用wakeup等价于一次调用。\n\n如果当前没有阻塞在select上，则本次wakeup调用将作用于下一次select——“记忆”作用。\n\n为什么要唤醒？\n\n注册了新的channel或者事件。\n\nchannel关闭，取消注册。\n\n优先级更高的事件触发（如定时器事件），希望及时处理。\n\n### 原理\n\nLinux上利用pipe调用创建一个管道，Windows上则是一个loopback的tcp连接。这是因为win32的管道无法加入select的fd set，将管道或者TCP连接加入select fd set。\n\nwakeup往管道或者连接写入一个字节，阻塞的select因为有I/O事件就绪，立即返回。可见，wakeup的调用开销不可忽视。\n\n## Buffer的选择\n\n通常情况下，操作系统的一次写操作分为两步：\n\n1. 将数据从用户空间拷贝到系统空间。\n2. 从系统空间往网卡写。同理，读操作也分为两步：\n   ① 将数据从网卡拷贝到系统空间；\n   ② 将数据从系统空间拷贝到用户空间。\n\n对于NIO来说，缓存的使用可以使用DirectByteBuffer和HeapByteBuffer。如果使用了DirectByteBuffer，一般来说可以减少一次系统空间到用户空间的拷贝。但Buffer创建和销毁的成本更高，更不宜维护，通常会用内存池来提高性能。\n\n如果数据量比较小的中小应用情况下，可以考虑使用heapBuffer；反之可以用directBuffer。\n\n# NIO存在的问题\n\n使用NIO != 高性能，当连接数<1000，并发程度不高或者局域网环境下NIO并没有显著的性能优势。\n\nNIO并没有完全屏蔽平台差异，它仍然是基于各个操作系统的I/O系统实现的，差异仍然存在。使用NIO做网络编程构建事件驱动模型并不容易，陷阱重重。\n\n推荐大家使用成熟的NIO框架，如Netty，MINA等。解决了很多NIO的陷阱，并屏蔽了操作系统的差异，有较好的性能和编程模型。\n\n# 总结\n\n最后总结一下到底NIO给我们带来了些什么：\n\n- 事件驱动模型\n- 避免多线程\n- 单线程处理多任务\n- 非阻塞I/O，I/O读写不再阻塞，而是返回0\n- 基于block的传输，通常比基于流的传输更高效\n- 更高级的IO函数，zero-copy\n- IO多路复用大大提高了Java网络应用的可伸缩性和实用性\n\n本文抛砖引玉，诠释了一些NIO的思想和设计理念以及应用场景，这只是从冰山一角。关于NIO可以谈的技术点其实还有很多，期待未来有机会和大家继续探讨。\n\n', '![Java NIO浅析](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-f47206d5b5e64448744b85eaf568f92d_1440w.png)', b'1', b'1', b'0', b'1', '2024-12-24 14:18:25', '2024-12-24 14:18:25', 0, 6455, 32, 10, b'0', '', 1);
INSERT INTO `blog` VALUES (11, 'Java-直接内存 DirectMemory 详解', 'https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/1634111413579.png', '# Java 直接内存\n\n## 1. 设计逻辑\n\n下面是 《深入理解 Java 虚拟机 第三版》2.2.7 小节 关于 Java 直接内存的描述。\n\n> 直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现，所以我们放到这里一起讲解。   在 JDK 1.4 中新加入了 NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里面的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。   显然，本机直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置 -Xmx 等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 OutOfMemoryError 异常。\n\n如果整理周志明对其描述的要的，那便是如下：\n\n- Direct Memory 并不是虚拟机运行时数据区的一部分；\n- 由于在 JDK 1.4 中引入了 NIO 机制，为此实现了一种通过 native 函数直接分配对外内存的，而这一切是通过以下两个概念实现的：\n- 通过存储在 Java 堆里面的 DirectByteBuffer**对象**对这块内存的引用进行操作；\n- 因避免了 Java 堆和 Native 堆（native heap）中来回复制数据，所以在一些场景中显著提高了性能；\n- 直接内存出现 OutOfMemoryError 异常的原因是物理机器的内存是受限的，但是我们通常会忘记需要为直接内存在物理机中预留相关内存空间；\n\n- 通道（Channel）;\n- 缓冲区（Buffer）;\n\n上述变化可以通过下面一图来表示：\n\n![1634111413579](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/1634111413579.png)\n\n- 关于上述的内存：可以这么粗浅地认为：栈用于方法的层层调用、返回、顺序执行，堆负责存储对象。\n- 关于内存空间的称呼变化：JDK 1.4 之前的称呼 native heap 转为现在的称呼 directory memory 。之所以 heap 前加 native 来修饰，是因为要让其和虚拟机规范中的内存 heap，而现在称呼 directory memory 是因为我们能够直接通过引用访问对象，消除了拷贝操作。\n\n实际上，栈中访问一个对象还是要借助堆，stack 寻求一个对象还是和以前一样，会问：”堆，请把对象xxx给我“，而不会向 native 堆索要。所以这个直接性是不彻底的。真正的实现是这样的，Java 程序仍然需要使用在 Java heap 中的一个对象（实际上规定为 DirectByteBuffer 类型对象来操作），但是这个对象（buffer）所持有的数据实际上存储于 native memory 中，而 Java 堆只仅仅拥有着对 native heap 的一个引用。\n\n## 2. 垃圾回收\n\n先的回答是不是的问题：直接内存也是会被 JVM 虚拟机管理进行完全不被引用的对象回收处理。\n\n但是直接内存中的对象并不是如普通对象样被 GC 管理，这方面细节会在下一小节中提到。\n\n## 3. 为什么需要 DirectByteBuffer\n\n即使不清楚 Java 设计者们会提出一个新的内存概念，不过也不难推断出其原因：由于 JVM 规范中的 heap 不满足某些领域的使用要求。\n\n首先，回答为什么需要 Buffer 。\n\n我们知道 GC 会管理内存，大致上可以这么认为，其主要做两件事：\n\n- 回收不被引用的对象；\n- 整理内存空间（比如将有效的对象整理到一起）；\n\n首先，JDK 告诉我们，NIO 操作并不适合直接在堆上操作。由于 heap 受到 GC 的直接管理，在 IO 写入的过程中 GC 可能会进行内存空间整理，这导致了一次 IO 写入的内存地址不完整。实际上，JNI（Java Native Inteface）在调用 IO 操作的 C 类库时，规定了写入时地址不能失效，这就导致了不能在 heap 上直接进行 IO 操作。在 IO 操作的时候禁止 GC 也是一个选项，如果 IO 时间过长，那么则可能会引起堆空间溢出。\n\n其次，回答 HeapByteBuffer 和 DirectByteBuffer 之间的区别。\n\n而 HeapByteBuffer 和 DirectByteBuffer 都是在堆外内存，即 native heap 上进行操作的。它们的区别是\n\n- HeapByteBuffer 实现方式是拷贝，也就是栈访问 Buffer 内的数据还是需要从堆外内存拷贝到 heap 内；\n- DirectByteBuffer 直接在堆内储存有对其的引用，不需要复制就能访问。\n\n堆外内存的垃圾回收是比堆内垃圾回收复杂的，而且有着不同的回收机制。\n\n## 4. 内存分配问题\n\n直接内存的最大大小可以通过 `-XX:MaxDirectMemorySize` 来设置，默认是 64M。\n\n在 Java 中分配内存的方式一般是通过 `sun.misc.Unsafe`类的公共 native 方法实现的（比如 文件以及网络 IO 类，但是非常不建议开发者使用，使用时一定要确保安全），而类 DirectByteBuffer 类的也是借助于此向物理内存(比如 JVM 运行于 Linux 上，那么 Linux 的内存就被称为物理内存)。\n\nUnsafe 是位于 sun.misc 包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升 Java 运行效率、增强 Java 语言底层资源操作能力方面起到了很大的作用。但由于 Unsafe 类使 Java 语言拥有了类似 C 语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用 Unsafe 类会使得程序出错的概率变大，使得 Java 这种安全的语言变得不再“安全”，因此对 Unsafe 的使用一定要慎重。\n\n而 ByteBuffer 提供的静态方法：`java.nio.ByteBuffer#allocateDirect` 将 Unsafe 类分配内存的相关操作封装好提供给开发者，如下图所示（图源：美团技术团队）：\n\n![1634111499831](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/1634111499831.png)\n\n从内存分配效率方面考虑的话，一般认为 HeapByteBuffer 以及 DirectByteBuffer 这种申请堆外内存的方式比堆内申请内存效率低，这主要是因为前者需要向物理机申请堆外内存，这是额外的开销。\n\n**延伸阅读**：\n\n美团技术团队：\n\n**注意事项**：\n\n基地址并非是 JVM 运行环境的物理地址，而是虚拟内存地址，详细可见 R 大的回答：\n\n**建议**：\n\nOracle JDK 没有 Unsafe 类的源码，所以需要 OpenJDK 才能知道 Unsafe 类中的方法详细返回类型，网址如下：\n\n## 5. ByteBuffer 和其他 Buffer 对比\n\n在 rt.jar 包的 java.nio 包下还有很多其他类型的 Buffer 类，比如 CharBuffer、IntBuffer 等等（每个基本类型*都对应一个 *Buffer，除了特殊的占一个 bit 的布尔类型）。但是唯独只有 ByteBuffer 类提供了输入参数为其他基本类型的 `put` 方法，这是为什么呢？\n\n这涉及了 Java 中整型基本类型存储的位数都是字节二进制位数的整数倍，如下表所示。\n\n![1634111533052](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/1634111533052.png)\n\n有人这样认为 Java 中存储本质以字节 byte 为单位，这不完全对，因为二进制才是本质存储。但是换个说法就对了：Java 字节所占的二进制位数的整数倍恰好是其他基本类型所占的二进制位数，上表就是这个含义。所以所有基本类型都可以用字节表示，比如 char 类型就是以两个字节大小存储的，如果 char 类型的数据前 8 位和后 8 位完全可以分别用两个 byte 表示。换句话说 ByteBuffer 起到了 CharBuffer 的作用。\n\n以下 `java.nio.DirectByteBuffer#putChar(char)`和 `java.nio.DirectByteBuffer#getChar()` 的源码：\n\n- putchar\n\n```java\npublic ByteBuffer putChar(char x) {\n        putChar(ix(nextPutIndex((1 << 1))), x);\n        return this;\n    }\n```\n\n- getchar\n\n```java\npublic char getChar() {\n        return getChar(ix(nextGetIndex((1 << 1))));\n    }\n```\n\n其中 `nextPutIndex` 以及 `nextGetIndex` 第一参数相当于待放入的基本类型要分为几份 byte 类型，这两个方法主要用于处理加入/拿出基本类型数据是对计数指针的加与减。以 `putChar` 为例，其做好统计指针操作后，又调用了本地的方法 `putchar`，其源代码如下：\n\n```java\nprivate ByteBuffer putChar(long a, char x) {\n      \n        if (unaligned) {\n            char y = (x);\n            unsafe.putChar(a, (nativeByteOrder ? y : Bits.swap(y)));\n        } else {\n            Bits.putChar(a, x, bigEndian);\n        }\n        return this;\n    }\n```\n\n其最终会调用 native `putChat()` 方法：`sun.misc.Unsafe#getChar(long)`。\n\n**注意事项**：\n\n上述方法利用了左移操作 left shift，整形数据左移一位代表`*2`，但是不用 2 而用 `1<<1`，这样不就意味着多进行了一层没有必要的运算了吗？实际上，使用左移运算体现了除 byte 类型的基本类型可以由 byte 类型整数倍表示，增加了可读性，这是这样写代码的主要原因。其次左移操作并不会带来执行时的额外运算，因为左移这类计算表达式在编译期间会直接优化为结果值。', '![Java-直接内存 DirectMemory 详解](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/1634111413579.png)', b'1', b'1', b'0', b'0', '2024-12-24 14:33:56', '2024-12-24 14:33:56', 0, 2633, 13, 10, b'0', '', 1);
INSERT INTO `blog` VALUES (12, 'Java中9种常见的CMS GC问题分析与解决（上）', 'https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-60d737e7e61afcf601d9e2d4506c92f9_1440w.png', '> 目前，互联网上 Java 的 GC 资料要么是主要讲解理论，要么就是针对单一场景的 GC 问题进行了剖析，对整个体系总结的资料少之又少。前车之鉴，后事之师，美团的几位工程师历时一年多的时间，搜集了内部各种 GC 问题的分析文章，并结合个人的理解做了一些总结，希望能起到“抛砖引玉”的作用。\n\n# 1. 写在前面\n\n**|**本文主要针对 Hotspot VM 中“CMS + ParNew”组合的一些使用场景进行总结。重点通过部分源码对根因进行分析以及对排查方法进行总结，排查过程会省略较多。另外，本文专业术语较多，有一定的阅读门槛，如未介绍清楚，还请自行查阅相关材料。\n\n**|**本文总字数 2 万左右（不包含代码片段），整体阅读时间约 30min ，文章较长，可以选择你感兴趣的场景进行研究。\n\n本篇系第一部分。\n\n**1.1 引言**\n\n自 Sun 发布 Java 语言以来，开始使用 GC 技术来进行内存自动管理，避免了手动管理带来的悬挂指针（Dangling Pointer）问题，很大程度上提升了开发效率，从此 GC 技术也一举成名。GC 有着非常悠久的历史，1960 年有着“Lisp 之父”和“人工智能之父”之称的 John McCarthy 就在论文中发布了 GC 算法，60 年以来， GC 技术的发展也突飞猛进，但不管是多么前沿的收集器也都是基于三种基本算法的组合或应用，也就是说 GC 要解决的根本问题这么多年一直都没有变过。笔者认为，在不太远的将来， GC 技术依然不会过时，比起日新月异的新技术，GC 这门古典技术更值得我们学习。\n\n那么，GC 问题处理能力能不能系统性掌握？一些影响因素都是**互为因果**的问题该怎么分析？比如一个服务 RT 突然上涨，有 GC 耗时增大、线程 Block 增多、慢查询增多、CPU 负载高四个表象，到底哪个是诱因？如何判断 GC 有没有问题？使用 CMS 有哪些常见问题？如何判断根因是什么？如何解决或避免这些问题？阅读完本文，相信你将会对 CMS GC 的问题处理有一个系统性的认知，更能游刃有余地解决这些问题，下面就让我们开始吧！文中若有错误之处，还请大家不吝指正。\n\n**1.2 概览**\n\n想要系统性地掌握 GC 问题处理，笔者这里给出一个学习路径，整体文章的框架也是按照这个结构展开，主要分四大步。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-60d737e7e61afcf601d9e2d4506c92f9_1440w.png)\n\n- **建立知识体系：**从 JVM 的内存结构到垃圾收集的算法和收集器，学习 GC 的基础知识，掌握一些常用的 GC 问题分析工具。\n- **确定评价指标：**了解基本 GC 的评价方法，摸清如何设定独立系统的指标，以及在业务场景中判断 GC 是否存在问题的手段。\n- **场景调优实践：**运用掌握的知识和系统评价指标，分析与解决九种 CMS 中常见 GC 问题场景。\n- **总结优化经验：**对整体过程做总结并提出笔者的几点建议，同时将总结到的经验完善到知识体系之中。\n\n# 2. GC 基础\n\n在正式开始前，先做些简要铺垫，介绍下 JVM 内存划分、收集算法、收集器等常用概念介绍，基础比较好的同学可以直接跳过这部分。\n\n## 2.1 基础概念\n\n- **GC：**GC 本身有三种语义，下文需要根据具体场景带入不同的语义：\n- \n- **Mutator：**生产垃圾的角色，也就是我们的应用程序，垃圾制造者，通过 Allocator 进行 allocate 和 free。\n- **TLAB：**Thread Local Allocation Buffer 的简写，基于 CAS 的独享线程（Mutator Threads）可以优先将对象分配在 Eden 中的一块内存，因为是 Java 线程独享的内存区没有锁竞争，所以分配速度更快，每个 TLAB 都是一个线程独享的。\n- **Card Table：**中文翻译为卡表，主要是用来标记卡页的状态，每个卡表项对应一个卡页。当卡页中一个对象引用有写操作时，写屏障将会标记对象所在的卡表状态改为 dirty，卡表的本质是用来解决跨代引用的问题。具体怎么解决的可以参考 StackOverflow 上的这个问题，或者研读一下 cardTableRS.app 中的源码。\n\n**GC：**GC 本身有三种语义，下文需要根据具体场景带入不同的语义：\n\n- **Garbage Collection**：垃圾收集技术，名词。\n\n- **Garbage Collector**：垃圾收集器，名词。\n- **Garbage Collecting**：垃圾收集动作，动词。\n\n**Mutator：**生产垃圾的角色，也就是我们的应用程序，垃圾制造者，通过 Allocator 进行 allocate 和 free。\n\n**TLAB：**Thread Local Allocation Buffer 的简写，基于 CAS 的独享线程（Mutator Threads）可以优先将对象分配在 Eden 中的一块内存，因为是 Java 线程独享的内存区没有锁竞争，所以分配速度更快，每个 TLAB 都是一个线程独享的。\n\n**Card Table：**中文翻译为卡表，主要是用来标记卡页的状态，每个卡表项对应一个卡页。当卡页中一个对象引用有写操作时，写屏障将会标记对象所在的卡表状态改为 dirty，卡表的本质是用来解决跨代引用的问题。具体怎么解决的可以参考 StackOverflow 上的这个问题 ，或者研读一下 cardTableRS.app 中的源码。\n\n**2.2 JVM 内存划分**\n\n从 JCP（Java Community Process）的官网中可以看到，目前 Java 版本最新已经到了 Java 16，未来的 Java 17 以及现在的 Java 11 和 Java 8 是 LTS 版本，JVM 规范也在随着迭代在变更，由于本文主要讨论 CMS，此处还是放 Java 8 的内存结构。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-9009f4c34faaceb483ca788a1b38fb21_1440w.png)\n\nGC 主要工作在 Heap 区和 MetaSpace 区（上图蓝色部分），在 Direct Memory 中，如果使用的是 DirectByteBuffer，那么在分配内存不够时则是 GC 通过 `Cleaner#clean` 间接管理。\n\n任何自动内存管理系统都会面临的步骤：为新对象分配空间，然后收集垃圾对象空间，下面我们就展开介绍一下这些基础知识。\n\n## 2.3 分配对象\n\nJava 中对象地址操作主要使用 Unsafe 调用了 C 的 allocate 和 free 两个方法，分配方法有两种：\n\n- **空闲链表（free list）：**通过额外的存储记录空闲的地址，将随机 IO 变为顺序 IO，但带来了额外的空间消耗。\n- **碰撞指针（bump pointer）：**通过一个指针作为分界点，需要分配内存时，仅需把指针往空闲的一端移动与对象大小相等的距离，分配效率较高，但使用场景有限。\n\n## 2.4 收集对象\n\n**2.4.1 识别垃圾**\n\n- **引用计数法（Reference Counting）：**对每个对象的引用进行计数，每当有一个地方引用它时计数器 +1、引用失效则 -1，引用的计数放到对象头中，大于 0 的对象被认为是存活对象。虽然循环引用的问题可通过 Recycler 算法解决，但是在多线程环境下，引用计数变更也要进行昂贵的同步操作，性能较低，早期的编程语言会采用此算法。\n- **可达性分析，又称引用链法（Tracing GC）：**从 GC Root 开始进行对象搜索，可以被搜索到的对象即为可达对象，此时还不足以判断对象是否存活/死亡，需要经过多次标记才能更加准确地确定，整个连通图之外的对象便可以作为垃圾被回收掉。目前 Java 中主流的虚拟机均采用此算法。\n\n备注：引用计数法是可以处理循环引用问题的，下次面试时不要再这么说啦~ ~\n\n**2.4.2 收集算法**\n\n自从有自动内存管理出现之时就有的一些收集算法，不同的收集器也是在不同场景下进行组合。\n\n- **Mark-Sweep（标记-清除）：**回收过程主要分为两个阶段，第一阶段为追踪（Tracing）阶段，即从 GC Root 开始遍历对象图，并标记（Mark）所遇到的每个对象，第二阶段为清除（Sweep）阶段，即回收器检查堆中每一个对象，并将所有未被标记的对象进行回收，整个过程不会发生对象移动。整个算法在不同的实现中会使用三色抽象（Tricolour Abstraction）、位图标记（BitMap）等技术来提高算法的效率，存活对象较多时较高效。\n- **Mark-Compact （标记-整理）：**这个算法的主要目的就是解决在非移动式回收器中都会存在的碎片化问题，也分为两个阶段，第一阶段与 Mark-Sweep 类似，第二阶段则会对存活对象按照整理顺序（Compaction Order）进行整理。主要实现有双指针（Two-Finger）回收算法、滑动回收（Lisp2）算法和引线整理（Threaded Compaction）算法等。\n- **Copying（复制）：**将空间分为两个大小相同的 From 和 To 两个半区，同一时间只会使用其中一个，每次进行回收时将一个半区的存活对象通过复制的方式转移到另一个半区。有递归（Robert R. Fenichel 和 Jerome C. Yochelson提出）和迭代（Cheney 提出）算法，以及解决了前两者递归栈、缓存行等问题的近似优先搜索算法。复制算法可以通过碰撞指针的方式进行快速地分配内存，但是也存在着空间利用率不高的缺点，另外就是存活对象比较大时复制的成本比较高。\n\n三种算法在是否移动对象、空间和时间方面的一些对比，假设存活对象数量为 *L*、堆空间大小为 *H*，则：\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-9a4f8c8f5ef5b2ad87a62873bf3e4b98_1440w.png)\n\n把 mark、sweep、compaction、copying 这几种动作的耗时放在一起看，大致有这样的关系：\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-fa669d559428cf42d491c6181eab157c_1440w.png)\n\n虽然 compaction 与 copying 都涉及移动对象，但取决于具体算法，compaction 可能要先计算一次对象的目标地址，然后修正指针，最后再移动对象。copying 则可以把这几件事情合为一体来做，所以可以快一些。另外，还需要留意 GC 带来的开销不能只看 Collector 的耗时，还得看 Allocator 。如果能保证内存没碎片，分配就可以用 pointer bumping 方式，只需要挪一个指针就完成了分配，非常快。而如果内存有碎片就得用 freelist 之类的方式管理，分配速度通常会慢一些。\n\n## 2.5 收集器\n\n目前在 Hotspot VM 中主要有分代收集和分区收集两大类，具体可以看下面的这个图，不过未来会逐渐向分区收集发展。在美团内部，有部分业务尝试用了 ZGC（感兴趣的同学可以学习下这篇文章《》），其余基本都停留在 CMS 和 G1 上。另外在 JDK11 后提供了一个不执行任何垃圾回收动作的回收器 Epsilon（A No-Op Garbage Collector）用作性能分析。另外一个就是 Azul 的 Zing JVM，其 C4（Concurrent Continuously Compacting Collector）收集器也在业内有一定的影响力。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-0d9c390627af2278544db8d4279f9a15_1440w.png)\n\n备注：值得一提的是，早些年国内 GC 技术的布道者 RednaxelaFX （江湖人称 R 大）也曾就职于 Azul，本文的一部分材料也参考了他的一些文章。\n\n**2.5.1 分代收集器**\n\n- **ParNew：**一款多线程的收集器，采用复制算法，主要工作在 Young 区，可以通过`-XX:ParallelGCThreads`参数来控制收集的线程数，整个过程都是 STW 的，常与 CMS 组合使用。\n- **CMS：**以获取最短回收停顿时间为目标，采用“标记-清除”算法，分 4 大步进行垃圾收集，其中初始标记和重新标记会 STW ，多数应用于互联网站或者 B/S 系统的服务器端上，JDK9 被标记弃用，JDK14 被删除，详情可见。\n\n**2.5.2 分区收集器**\n\n- **G1：**一种服务器端的垃圾收集器，应用在多处理器和大容量内存环境中，在实现高吞吐量的同时，尽可能地满足垃圾收集暂停时间的要求。\n- **ZGC：**JDK11 中推出的一款低延迟垃圾回收器，适用于大内存低延迟服务的内存管理和回收，SPECjbb 2015 基准测试，在 128G 的大堆下，最大停顿时间才 1.68 ms，停顿时间远胜于 G1 和 CMS。\n- **Shenandoah：**由 Red Hat 的一个团队负责开发，与 G1 类似，基于 Region 设计的垃圾收集器，但不需要 Remember Set 或者 Card Table 来记录跨 Region 引用，停顿时间和堆的大小没有任何关系。停顿时间与 ZGC 接近，下图为与 CMS 和 G1 等收集器的 benchmark。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-bf3a8087ed9440b0524855852a3bdbbf_1440w.png)\n\n**2.5.3 常用收集器**\n\n目前使用最多的是 CMS 和 G1 收集器，二者都有分代的概念，主要内存结构如下：\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-6794981a41fa4133295324da8bca889d_1440w.png)\n\n**2.5.4 其他收集器**\n\n以上仅列出常见收集器，除此之外还有很多，如 Metronome、Stopless、Staccato、Chicken、Clover 等实时回收器，Sapphire、Compressor、Pauseless 等并发复制/整理回收器，Doligez-Leroy-Conthier 等标记整理回收器，由于篇幅原因，不在此一一介绍。\n\n## 2.6 常用工具\n\n工欲善其事，必先利其器，此处列出一些笔者常用的工具，具体情况大家可以自由选择，本文的问题都是使用这些工具来定位和分析的。\n\n**2.6.1 命令行终端**\n\n- **标准终端类**：jps、jinfo、jstat、jstack、jmap\n- **功能整合类**：jcmd、vjtools、arthas、greys\n\n**2.6.2 可视化界面**\n\n- **简易**：JConsole、JVisualvm、HA、GCHisto、GCViewer\n- **进阶**：MAT、JProfiler\n\n命令行推荐 arthas ，可视化界面推荐 JProfiler，此外还有一些在线的平台 、、 ，美团内部的 Scalpel（一款自研的 JVM 问题诊断工具，暂时未开源）也比较好用。\n\n# 3. GC 问题判断\n\n在做 GC 问题排查和优化之前，我们需要先来明确下到底是不是 GC 直接导致的问题，或者应用代码导致的 GC 异常，最终出现问题。\n\n## 3.1 判断 GC 有没有问题？\n\n**3.1.1 设定评价标准**\n\n评判 GC 的两个核心指标：\n\n- **延迟（Latency）：**也可以理解为最大停顿时间，即垃圾收集过程中一次 STW 的最长时间，越短越好，一定程度上可以接受频次的增大，GC 技术的主要发展方向。\n- **吞吐量（Throughput）：**应用系统的生命周期内，由于 GC 线程会占用 Mutator 当前可用的 CPU 时钟周期，吞吐量即为 Mutator 有效花费的时间占系统总运行时间的百分比，例如系统运行了 100 min，GC 耗时 1 min，则系统吞吐量为 99%，吞吐量优先的收集器可以接受较长的停顿。\n\n目前各大互联网公司的系统基本都更追求低延时，避免一次 GC 停顿的时间过长对用户体验造成损失，衡量指标需要结合一下应用服务的 SLA，主要如下两点来判断：\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-42cfd9fbe59b80f3ae880a3a16e6d5cc_1440w.png)\n\n简而言之，即为**一次停顿的时间不超过应用服务的 TP9999，GC 的吞吐量不小于 99.99%**。举个例子，假设某个服务 A 的 TP9999 为 80 ms，平均 GC 停顿为 30 ms，那么该服务的最大停顿时间最好不要超过 80 ms，GC 频次控制在 5 min 以上一次。如果满足不了，那就需要调优或者通过更多资源来进行并联冗余。（大家可以先停下来，看看监控平台上面的 gc.meantime 分钟级别指标，如果超过了 6 ms 那单机 GC 吞吐量就达不到 4 个 9 了。）\n\n备注：除了这两个指标之外还有 Footprint（资源量大小测量）、反应速度等指标，互联网这种实时系统追求低延迟，而很多嵌入式系统则追求 Footprint。\n\n**3.1.2 读懂 GC Cause**\n\n拿到 GC 日志，我们就可以简单分析 GC 情况了，通过一些工具，我们可以比较直观地看到 Cause 的分布情况，如下图就是使用 gceasy 绘制的图表：\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-0613a73a748a820b0502052e7bd2b222_1440w.png)\n\n如上图所示，我们很清晰的就能知道是什么原因引起的 GC，以及每次的时间花费情况，但是要分析 GC 的问题，先要读懂 GC Cause，即 JVM 什么样的条件下选择进行 GC 操作，具体 Cause 的分类可以看一下 Hotspot 源码：src/share/vm/gc/shared/gcCause.hpp 和 src/share/vm/gc/shared/gcCause.cpp 中。\n\n```cpp\nconst char* GCCause::to_string(GCCause::Cause cause) {\n  switch (cause) {\n    case _java_lang_system_gc:\n      return \"System.gc()\";\n\n    case _full_gc_alot:\n      return \"FullGCAlot\";\n\n    case _scavenge_alot:\n      return \"ScavengeAlot\";\n\n    case _allocation_profiler:\n      return \"Allocation Profiler\";\n\n    case _jvmti_force_gc:\n      return \"JvmtiEnv ForceGarbageCollection\";\n\n    case _gc_locker:\n      return \"GCLocker Initiated GC\";\n\n    case _heap_inspection:\n      return \"Heap Inspection Initiated GC\";\n\n    case _heap_dump:\n      return \"Heap Dump Initiated GC\";\n\n    case _wb_young_gc:\n      return \"WhiteBox Initiated Young GC\";\n\n    case _wb_conc_mark:\n      return \"WhiteBox Initiated Concurrent Mark\";\n\n    case _wb_full_gc:\n      return \"WhiteBox Initiated Full GC\";\n\n    case _no_gc:\n      return \"No GC\";\n\n    case _allocation_failure:\n      return \"Allocation Failure\";\n\n    case _tenured_generation_full:\n      return \"Tenured Generation Full\";\n\n    case _metadata_GC_threshold:\n      return \"Metadata GC Threshold\";\n\n    case _metadata_GC_clear_soft_refs:\n      return \"Metadata GC Clear Soft References\";\n\n    case _cms_generation_full:\n      return \"CMS Generation Full\";\n\n    case _cms_initial_mark:\n      return \"CMS Initial Mark\";\n\n    case _cms_final_remark:\n      return \"CMS Final Remark\";\n\n    case _cms_concurrent_mark:\n      return \"CMS Concurrent Mark\";\n\n    case _old_generation_expanded_on_last_scavenge:\n      return \"Old Generation Expanded On Last Scavenge\";\n\n    case _old_generation_too_full_to_scavenge:\n      return \"Old Generation Too Full To Scavenge\";\n\n    case _adaptive_size_policy:\n      return \"Ergonomics\";\n\n    case _g1_inc_collection_pause:\n      return \"G1 Evacuation Pause\";\n\n    case _g1_humongous_allocation:\n      return \"G1 Humongous Allocation\";\n\n    case _dcmd_gc_run:\n      return \"Diagnostic Command\";\n\n    case _last_gc_cause:\n      return \"ILLEGAL VALUE - last gc cause - ILLEGAL VALUE\";\n\n    default:\n      return \"unknown GCCause\";\n  }\n  ShouldNotReachHere();\n}\n```\n\n重点需要关注的几个GC Cause：\n\n- **System.gc()：**手动触发GC操作。\n- **CMS：**CMS GC 在执行过程中的一些动作，重点关注 CMS Initial Mark 和 CMS Final Remark 两个 STW 阶段。\n- **Promotion Failure：**Old 区没有足够的空间分配给 Young 区晋升的对象（即使总可用内存足够大）。\n- **Concurrent Mode Failure：**CMS GC 运行期间，Old 区预留的空间不足以分配给新的对象，此时收集器会发生退化，严重影响 GC 性能，下面的一个案例即为这种场景。\n- **GCLocker Initiated GC：**如果线程执行在 JNI 临界区时，刚好需要进行 GC，此时 GC Locker 将会阻止 GC 的发生，同时阻止其他线程进入 JNI 临界区，直到最后一个线程退出临界区时触发一次 GC。\n\n什么时机使用这些 Cause 触发回收，大家可以看一下 CMS 的代码，这里就不讨论了，具体在 /src/hotspot/share/gc/cms/concurrentMarkSweepGeneration.cpp 中。\n\nshouldConcurrentCollect\n\n```cpp\nbool CMSCollector::shouldConcurrentCollect() {\n  LogTarget(Trace, gc) log;\n\n  if (_full_gc_requested) {\n    log.print(\"CMSCollector: collect because of explicit  gc request (or GCLocker)\");\n    return true;\n  }\n\n  FreelistLocker x(this);\n  // ------------------------------------------------------------------\n  // Print out lots of information which affects the initiation of\n  // a collection.\n  if (log.is_enabled() && stats().valid()) {\n    log.print(\"CMSCollector shouldConcurrentCollect: \");\n\n    LogStream out(log);\n    stats().print_on(&out);\n\n    log.print(\"time_until_cms_gen_full %3.7f\", stats().time_until_cms_gen_full());\n    log.print(\"free=\" SIZE_FORMAT, _cmsGen->free());\n    log.print(\"contiguous_available=\" SIZE_FORMAT, _cmsGen->contiguous_available());\n    log.print(\"promotion_rate=%g\", stats().promotion_rate());\n    log.print(\"cms_allocation_rate=%g\", stats().cms_allocation_rate());\n    log.print(\"occupancy=%3.7f\", _cmsGen->occupancy());\n    log.print(\"initiatingOccupancy=%3.7f\", _cmsGen->initiating_occupancy());\n    log.print(\"cms_time_since_begin=%3.7f\", stats().cms_time_since_begin());\n    log.print(\"cms_time_since_end=%3.7f\", stats().cms_time_since_end());\n    log.print(\"metadata initialized %d\", MetaspaceGC::should_concurrent_collect());\n  }\n  // ------------------------------------------------------------------\n\n  // If the estimated time to complete a cms collection (cms_duration())\n  // is less than the estimated time remaining until the cms generation\n  // is full, start a collection.\n  if (!UseCMSInitiatingOccupancyOnly) {\n    if (stats().valid()) {\n      if (stats().time_until_cms_start() == 0.0) {\n        return true;\n      }\n    } else {\n\n      if (_cmsGen->occupancy() >= _bootstrap_occupancy) {\n        log.print(\" CMSCollector: collect for bootstrapping statistics: occupancy = %f, boot occupancy = %f\",\n                  _cmsGen->occupancy(), _bootstrap_occupancy);\n        return true;\n      }\n    }\n  }\n  if (_cmsGen->should_concurrent_collect()) {\n    log.print(\"CMS old gen initiated\");\n    return true;\n  }\n\n  CMSHeap* heap = CMSHeap::heap();\n  if (heap->incremental_collection_will_fail(true /* consult_young */)) {\n    log.print(\"CMSCollector: collect because incremental collection will fail \");\n    return true;\n  }\n\n  if (MetaspaceGC::should_concurrent_collect()) {\n    log.print(\"CMSCollector: collect for metadata allocation \");\n    return true;\n  }\n\n  // CMSTriggerInterval starts a CMS cycle if enough time has passed.\n  if (CMSTriggerInterval >= 0) {\n    if (CMSTriggerInterval == 0) {\n      // Trigger always\n      return true;\n    }\n\n    // Check the CMS time since begin (we do not check the stats validity\n    // as we want to be able to trigger the first CMS cycle as well)\n    if (stats().cms_time_since_begin() >= (CMSTriggerInterval / ((double) MILLIUNITS))) {\n      if (stats().valid()) {\n        log.print(\"CMSCollector: collect because of trigger interval (time since last begin %3.7f secs)\",\n                  stats().cms_time_since_begin());\n      } else {\n        log.print(\"CMSCollector: collect because of trigger interval (first collection)\");\n      }\n      return true;\n    }\n  }\n\n  return false;\n}\n```\n\n## 3.2 判断是不是 GC 引发的问题？\n\n到底是结果（现象）还是原因，在一次 GC 问题处理的过程中，如何判断是 GC 导致的故障，还是系统本身引发 GC 问题。这里继续拿在本文开头提到的一个 Case：“GC 耗时增大、线程 Block 增多、慢查询增多、CPU 负载高等四个表象，如何判断哪个是根因？”，笔者这里根据自己的经验大致整理了四种判断方法供参考：\n\n- **时序分析：**先发生的事件是根因的概率更大，通过监控手段分析各个指标的异常时间点，还原事件时间线，如先观察到 CPU 负载高（要有足够的时间 Gap），那么整个问题影响链就可能是：CPU 负载高 -> 慢查询增多 -> GC 耗时增大 -> 线程Block增多 -> RT 上涨。\n- **概率分析：**使用统计概率学，结合历史问题的经验进行推断，由近到远按类型分析，如过往慢查的问题比较多，那么整个问题影响链就可能是：慢查询增多 -> GC 耗时增大 -> CPU 负载高 -> 线程 Block 增多 -> RT上涨。\n- **实验分析：**通过故障演练等方式对问题现场进行模拟，触发其中部分条件（一个或多个），观察是否会发生问题，如只触发线程 Block 就会发生问题，那么整个问题影响链就可能是：线程Block增多 -> CPU 负载高 -> 慢查询增多 -> GC 耗时增大 -> RT 上涨。\n- **反证分析：**对其中某一表象进行反证分析，即判断表象的发不发生跟结果是否有相关性，例如我们从整个集群的角度观察到某些节点慢查和 CPU 都正常，但也出了问题，那么整个问题影响链就可能是：GC 耗时增大 -> 线程 Block 增多 -> RT 上涨。\n\n不同的根因，后续的分析方法是完全不同的。如果是 CPU 负载高那可能需要用火焰图看下热点、如果是慢查询增多那可能需要看下 DB 情况、如果是线程 Block 引起那可能需要看下锁竞争的情况，最后如各个表象证明都没有问题，那可能 GC 确实存在问题，可以继续分析 GC 问题了。\n\n## 3.3 问题分类导读\n\n**3.3.1 Mutator 类型**\n\nMutator 的类型根据对象存活时间比例图来看主要分为两种，在弱分代假说中也提到类似的说法，如下图所示 “Survival Time” 表示对象存活时间，“Rate” 表示对象分配比例：\n\n- **IO 交互型：**互联网上目前大部分的服务都属于该类型，例如分布式 RPC、MQ、HTTP 网关服务等，对内存要求并不大，大部分对象在 TP9999 的时间内都会死亡， Young 区越大越好。\n- **MEM 计算型：**主要是分布式数据计算 Hadoop，分布式存储 HBase、Cassandra，自建的分布式缓存等，对内存要求高，对象存活时间长，Old 区越大越好。\n\n当然，除了二者之外还有介于两者之间的场景，本篇文章主要讨论第一种情况。对象 Survival Time 分布图，对我们设置 GC 参数有着非常重要的指导意义，如下图就可以简单推算分代的边界。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-824a46eacbb48cfba87cd31869a44c24_1440w.png)\n\n**3.3.2 GC 问题分类**\n\n笔者选取了九种不同类型的 GC 问题，覆盖了大部分场景，如果有更好的场景，欢迎在评论区给出。\n\n- **Unexpected GC：**意外发生的 GC，实际上不需要发生，我们可以通过一些手段去避免。\n- \n- **Partial GC：**部分收集操作的 GC，只对某些分代/分区进行回收。\n- **Old GC：**分代收集里面的 Old 区收集动作，也可以叫做 Major GC，有些也会叫做 Full GC，但其实这种叫法是不规范的，在 CMS 发生 Foreground GC 时才是 Full GC，CMSScavengeBeforeRemark 参数也只是在 Remark 前触发一次Young GC。\n- **Full GC：**全量收集的 GC，对整个堆进行回收，STW 时间会比较长，一旦发生，影响较大，也可以叫做 Major GC，参见“场景七：内存碎片&收集器退化”。\n- **MetaSpace：**元空间回收引发问题，参见“场景三：MetaSpace 区 OOM”。\n- **Direct Memory：**直接内存（也可以称作为堆外内存）回收引发问题，参见“场景八：堆外内存 OOM”。\n- **JNI：**本地 Native 方法引发问题，参见“场景九：JNI 引发的 GC 问题”。\n\n**Unexpected GC：**意外发生的 GC，实际上不需要发生，我们可以通过一些手段去避免。\n\n- **Space Shock：**空间震荡问题，参见“场景一：动态扩容引起的空间震荡”。\n\n- **Explicit GC：**显示执行 GC 问题，参见“场景二：显式 GC 的去与留”。\n\n**Partial GC：**部分收集操作的 GC，只对某些分代/分区进行回收。\n\n- **Young GC：**分代收集里面的 Young 区收集动作，也可以叫做 Minor GC。\n\n- \n- **Old GC：**分代收集里面的 Old 区收集动作，也可以叫做 Major GC，有些也会叫做 Full GC，但其实这种叫法是不规范的，在 CMS 发生 Foreground GC 时才是 Full GC，CMSScavengeBeforeRemark 参数也只是在 Remark 前触发一次Young GC。\n- \n\n- **ParNew：**Young GC 频繁，参见“场景四：过早晋升”。\n\n**Old GC：**分代收集里面的 Old 区收集动作，也可以叫做 Major GC，有些也会叫做 Full GC，但其实这种叫法是不规范的，在 CMS 发生 Foreground GC 时才是 Full GC，CMSScavengeBeforeRemark 参数也只是在 Remark 前触发一次Young GC。\n\n- **CMS：**Old GC 频繁，参见“场景五：CMS Old GC 频繁”。\n\n- **CMS：**Old GC 不频繁但单次耗时大，参见“场景六：单次 CMS Old GC 耗时长”。\n\n**Full GC：**全量收集的 GC，对整个堆进行回收，STW 时间会比较长，一旦发生，影响较大，也可以叫做 Major GC，参见“场景七：内存碎片&收集器退化”。\n\n**MetaSpace：**元空间回收引发问题，参见“场景三：MetaSpace 区 OOM”。\n\n**Direct Memory：**直接内存（也可以称作为堆外内存）回收引发问题，参见“场景八：堆外内存 OOM”。\n\n**JNI：**本地 Native 方法引发问题，参见“场景九：JNI 引发的 GC 问题”。\n\n**3.3.3 排查难度**\n\n一个问题的**解决难度跟它的常见程度成反比**，大部分我们都可以通过各种搜索引擎找到类似的问题，然后用同样的手段尝试去解决。当一个问题在各种网站上都找不到相似的问题时，那么可能会有两种情况，一种这不是一个问题，另一种就是遇到一个隐藏比较深的问题，遇到这种问题可能就要深入到源码级别去调试了。以下 GC 问题场景，排查难度从上到下依次递增。\n\n# 4. 常见场景分析与解决\n\n## 4.1 场景一：动态扩容引起的空间震荡\n\n**4.1.1 现象**\n\n服务**刚刚启动时 GC 次数较多**，最大空间剩余很多但是依然发生 GC，这种情况我们可以通过观察 GC 日志或者通过监控工具来观察堆的空间变化情况即可。GC Cause 一般为 Allocation Failure，且在 GC 日志中会观察到经历一次 GC ，堆内各个空间的大小会被调整，如下图所示：\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-e460523f6afb99d552c6c4a9734df850_1440w.png)\n\n**4.1.2 原因**\n\n在 JVM 的参数中 `-Xms` 和 `-Xmx` 设置的不一致，在初始化时只会初始 `-Xms` 大小的空间存储信息，每当空间不够用时再向操作系统申请，这样的话必然要进行一次 GC。具体是通过 `ConcurrentMarkSweepGeneration::compute_new_size()` 方法计算新的空间大小：\n\nConcurrentMarkSweepGeneration::compute_new_size()\n\n```cpp\nvoid ConcurrentMarkSweepGeneration::compute_new_size() {\n  assert_locked_or_safepoint(Heap_lock);\n\n  // If incremental collection failed, we just want to expand\n  // to the limit.\n  if (incremental_collection_failed()) {\n    clear_incremental_collection_failed();\n    grow_to_reserved();\n    return;\n  }\n\n  // The heap has been compacted but not reset yet.\n  // Any metric such as free() or used() will be incorrect.\n\n  CardGeneration::compute_new_size();\n\n  // Reset again after a possible resizing\n  if (did_compact()) {\n    cmsSpace()->reset_after_compaction();\n  }\n}\n```\n\n另外，如果空间剩余很多时也会进行缩容操作，JVM 通过 `-XX:MinHeapFreeRatio` 和 `-XX:MaxHeapFreeRatio` 来控制扩容和缩容的比例，调节这两个值也可以控制伸缩的时机，例如扩容便是使用 `GenCollectedHeap::expand_heap_and_allocate()` 来完成的，代码如下：\n\nGenCollectedHeap::expand_heap_and_allocate()\n\n```cpp\nHeapWord* GenCollectedHeap::expand_heap_and_allocate(size_t size, bool   is_tlab) {\n  HeapWord* result = NULL;\n  if (_old_gen->should_allocate(size, is_tlab)) {\n    result = _old_gen->expand_and_allocate(size, is_tlab);\n  }\n  if (result == NULL) {\n    if (_young_gen->should_allocate(size, is_tlab)) {\n      result = _young_gen->expand_and_allocate(size, is_tlab);\n    }\n  }\n  assert(result == NULL || is_in_reserved(result), \"result not in heap\");\n  return result;\n}\n```\n\n整个伸缩的模型理解可以看这个图，当 committed 的空间大小超过了低水位/高水位的大小，capacity 也会随之调整：\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-2f1f3f2bfc3d85ccabb80cfe39267ddf_1440w.png)\n\n**4.1.3 策略**\n\n**定位**：观察 CMS GC 触发时间点 Old/MetaSpace 区的 committed 占比是不是一个固定的值，或者像上文提到的观察总的内存使用率也可以。\n\n**解决**：尽量**将成对出现的空间大小配置参数设置成固定的**，如 `-Xms` 和 `-Xmx`，`-XX:MaxNewSize` 和 `-XX:NewSize`，`-XX:MetaSpaceSize` 和 `-XX:MaxMetaSpaceSize` 等。\n\n**4.1.4 小结**\n\n一般来说，我们需要保证 Java 虚拟机的堆是稳定的，确保 `-Xms` 和 `-Xmx` 设置的是一个值（即初始值和最大值一致），获得一个稳定的堆，同理在 MetaSpace 区也有类似的问题。不过在不追求停顿时间的情况下震荡的空间也是有利的，可以动态地伸缩以节省空间，例如作为富客户端的 Java 应用。\n\n这个问题虽然初级，但是发生的概率还真不小，尤其是在一些规范不太健全的情况下。\n\n## 4.2 场景二：显式 GC 的去与留\n\n**4.2.1 现象**\n\n除了扩容缩容会触发 CMS GC 之外，还有 Old 区达到回收阈值、MetaSpace 空间不足、Young 区晋升失败、大对象担保失败等几种触发条件，如果这些情况都没有发生却触发了 GC ？这种情况有可能是代码中手动调用了 System.gc 方法，此时可以找到 GC 日志中的 GC Cause 确认下。那么这种 GC 到底有没有问题，翻看网上的一些资料，有人说可以添加 `-XX:+DisableExplicitGC` 参数来避免这种 GC，也有人说不能加这个参数，加了就会影响 Native Memory 的回收。先说结论，笔者这里建议保留 System.gc，那为什么要保留？我们一起来分析下。\n\n**4.2.2 原因**\n\n找到 System.gc 在 Hotspot 中的源码，可以发现增加 `-XX:+DisableExplicitGC` 参数后，这个方法变成了一个空方法，如果没有加的话便会调用 `Universe::heap()::collect` 方法，继续跟进到这个方法中，发现 System.gc 会引发一次 STW 的 Full GC，对整个堆做收集。\n\nDisableExplicitGC\n\n```cpp\nJVM_ENTRY_NO_ENV(void, JVM_GC(void))\n  JVMWrapper(\"JVM_GC\");\n  if (!DisableExplicitGC) {\n    Universe::heap()->collect(GCCause::_java_lang_system_gc);\n  }\nJVM_END\n```\n\nGenCollectedHeap::collect()\n\n```cpp\nvoid GenCollectedHeap::collect(GCCause::Cause cause) {\n  if (cause == GCCause::_wb_young_gc) {\n    // Young collection for the WhiteBox API.\n    collect(cause, YoungGen);\n  } else {\n#ifdef ASSERT\n  if (cause == GCCause::_scavenge_alot) {\n    // Young collection only.\n    collect(cause, YoungGen);\n  } else {\n    // Stop-the-world full collection.\n    collect(cause, OldGen);\n  }\n#else\n    // Stop-the-world full collection.\n    collect(cause, OldGen);\n#endif\n  }\n}\n```\n\n**保留 System.gc**\n\n此处补充一个知识点，**CMS GC 共分为 Background 和 Foreground 两种模式**，前者就是我们常规理解中的并发收集，可以不影响正常的业务线程运行，但 Foreground Collector 却有很大的差异，他会进行一次压缩式 GC。此压缩式 GC 使用的是跟 Serial Old GC 一样的 Lisp2 算法，其使用 Mark-Compact 来做 Full GC，一般称之为 MSC（Mark-Sweep-Compact），它收集的范围是 Java 堆的 Young 区和 Old 区以及 MetaSpace。由上面的算法章节中我们知道 compact 的代价是巨大的，那么使用 Foreground Collector 时将会带来非常长的 STW。如果在应用程序中 System.gc 被频繁调用，那就非常危险了。\n\n**去掉 System.gc**\n\n如果禁用掉的话就会带来另外一个内存泄漏问题，此时就需要说一下 DirectByteBuffer，它有着零拷贝等特点，被 Netty 等各种 NIO 框架使用，会使用到堆外内存。堆内存由 JVM 自己管理，堆外内存必须要手动释放，DirectByteBuffer 没有 Finalizer，它的 Native Memory 的清理工作是通过 `sun.misc.Cleaner` 自动完成的，是一种基于 PhantomReference 的清理工具，比普通的 Finalizer 轻量些。\n\n为 DirectByteBuffer 分配空间过程中会显式调用 System.gc ，希望通过 Full GC 来强迫已经无用的 DirectByteBuffer 对象释放掉它们关联的 Native Memory，下面为代码实现：\n\nreserveMemory\n\n```cpp\n// These methods should be called whenever direct memory is allocated or\n// freed.  They allow the user to control the amount of direct memory\n// which a process may access.  All sizes are specified in bytes.\nstatic void reserveMemory(long size) {\n\n    synchronized (Bits.class) {\n        if (!memoryLimitSet && VM.isBooted()) {\n            maxMemory = VM.maxDirectMemory();\n            memoryLimitSet = true;\n        }\n        if (size <= maxMemory - reservedMemory) {\n            reservedMemory += size;\n            return;\n        }\n    }\n\n    System.gc();\n    try {\n        Thread.sleep(100);\n    } catch (InterruptedException x) {\n        // Restore interrupt status\n        Thread.currentThread().interrupt();\n    }\n    synchronized (Bits.class) {\n        if (reservedMemory + size > maxMemory)\n            throw new OutOfMemoryError(\"Direct buffer memory\");\n        reservedMemory += size;\n    }\n\n}\n```\n\nHotSpot VM 只会在 Old GC 的时候才会对 Old 中的对象做 Reference Processing，而在 Young GC 时只会对 Young 里的对象做 Reference Processing。Young 中的 DirectByteBuffer 对象会在 Young GC 时被处理，也就是说，做 CMS GC 的话会对 Old 做 Reference Processing，进而能触发 Cleaner 对已死的 DirectByteBuffer 对象做清理工作。但如果很长一段时间里没做过 GC 或者只做了 Young GC 的话则不会在 Old 触发 Cleaner 的工作，那么就可能让本来已经死亡，但已经晋升到 Old 的 DirectByteBuffer 关联的 Native Memory 得不到及时释放。这几个实现特征使得依赖于 System.gc 触发 GC 来保证 DirectByteMemory 的清理工作能及时完成。如果打开了 `-XX:+DisableExplicitGC`，清理工作就可能得不到及时完成，于是就有发生 Direct Memory 的 OOM。\n\n**4.2.3 策略**\n\n通过上面的分析看到，无论是保留还是去掉都会有一定的风险点，不过目前互联网中的 RPC 通信会大量使用 NIO，所以笔者在这里建议保留。此外 JVM 还提供了 `-XX:+ExplicitGCInvokesConcurrent` 和 `-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses` 参数来将 System.gc 的触发类型从 Foreground 改为 Background，同时 Background 也会做 Reference Processing，这样的话就能大幅降低了 STW 开销，同时也不会发生 NIO Direct Memory OOM。\n\n**4.2.4 小结**\n\n不止 CMS，在 G1 或 ZGC中开启 `ExplicitGCInvokesConcurrent` 模式，都会采用高性能的并发收集方式进行收集，不过还是建议在代码规范方面也要做好约束，规范好 System.gc 的使用。\n\nP.S. HotSpot 对 System.gc 有特别处理，最主要的地方体现在一次 System.gc 是否与普通 GC 一样会触发 GC 的统计/阈值数据的更新，HotSpot 里的许多 GC 算法都带有自适应的功能，会根据先前收集的效率来决定接下来的 GC 中使用的参数，但 System.gc 默认不更新这些统计数据，避免用户强行 GC 对这些自适应功能的干扰（可以参考 -XX:+UseAdaptiveSizePolicyWithSystemGC 参数，默认是 false）。\n\n## 4.3 场景三：MetaSpace 区 OOM\n\n**4.3.1 现象**\n\nJVM 在启动后或者某个时间点开始，**MetaSpace 的已使用大小在持续增长，同时每次 GC 也无法释放，调大 MetaSpace 空间也无法彻底解决**。\n\n**4.3.2 原因**\n\n在讨论为什么会 OOM 之前，我们先来看一下这个区里面会存什么数据，Java 7 之前字符串常量池被放到了 Perm 区，所有被 intern 的 String 都会被存在这里，由于 String.intern 是不受控的，所以 `-XX:MaxPermSize` 的值也不太好设置，经常会出现 `java.lang.OutOfMemoryError: PermGen space` 异常，所以在 Java 7 之后常量池等字面量（Literal）、类静态变量（Class Static）、符号引用（Symbols Reference）等几项被移到 Heap 中。而 Java 8 之后 PermGen 也被移除，取而代之的是 MetaSpace。\n\n在最底层，JVM 通过 mmap 接口向操作系统申请内存映射，每次申请 2MB 空间，这里是虚拟内存映射，不是真的就消耗了主存的 2MB，只有之后在使用的时候才会真的消耗内存。申请的这些内存放到一个链表中 VirtualSpaceList，作为其中的一个 Node。\n\n在上层，MetaSpace 主要由 Klass Metaspace 和 NoKlass Metaspace 两大部分组成。\n\n- **Klass MetaSpace：**就是用来存 Klass 的，就是 Class 文件在 JVM 里的运行时数据结构，这部分默认放在 Compressed Class Pointer Space 中，是一块连续的内存区域，紧接着 Heap。Compressed Class Pointer Space 不是必须有的，如果设置了`-XX:-UseCompressedClassPointers`，或者`-Xmx`设置大于 32 G，就不会有这块内存，这种情况下 Klass 都会存在 NoKlass Metaspace 里。\n- **NoKlass MetaSpace：**专门来存 Klass 相关的其他的内容，比如 Method，ConstantPool 等，可以由多块不连续的内存组成。虽然叫做 NoKlass Metaspace，但是也其实可以存 Klass 的内容，上面已经提到了对应场景。\n\n具体的定义都可以在源码 shared/vm/memory/metaspace.hpp 中找到：\n\nMetaSpace\n\n```cpp\nclass Metaspace : public AllStatic {\n\n  friend class MetaspaceShared;\n\n public:\n  enum MetadataType {\n    ClassType,\n    NonClassType,\n    MetadataTypeCount\n  };\n  enum MetaspaceType {\n    ZeroMetaspaceType = 0,\n    StandardMetaspaceType = ZeroMetaspaceType,\n    BootMetaspaceType = StandardMetaspaceType + 1,\n    AnonymousMetaspaceType = BootMetaspaceType + 1,\n    ReflectionMetaspaceType = AnonymousMetaspaceType + 1,\n    MetaspaceTypeCount\n  };\n\n private:\n\n  // Align up the word size to the allocation word size\n  static size_t align_word_size_up(size_t);\n\n  // Aligned size of the metaspace.\n  static size_t _compressed_class_space_size;\n\n  static size_t compressed_class_space_size() {\n    return _compressed_class_space_size;\n  }\n\n  static void set_compressed_class_space_size(size_t size) {\n    _compressed_class_space_size = size;\n  }\n\n  static size_t _first_chunk_word_size;\n  static size_t _first_class_chunk_word_size;\n\n  static size_t _commit_alignment;\n  static size_t _reserve_alignment;\n  DEBUG_ONLY(static bool   _frozen;)\n\n  // Virtual Space lists for both classes and other metadata\n  static metaspace::VirtualSpaceList* _space_list;\n  static metaspace::VirtualSpaceList* _class_space_list;\n\n  static metaspace::ChunkManager* _chunk_manager_metadata;\n  static metaspace::ChunkManager* _chunk_manager_class;\n\n  static const MetaspaceTracer* _tracer;\n}\n```\n\nMetaSpace 的对象为什么无法释放，我们看下面两点：\n\n- **MetaSpace 内存管理：**类和其元数据的生命周期与其对应的类加载器相同，只要类的类加载器是存活的，在 Metaspace 中的类元数据也是存活的，不能被回收。每个加载器有单独的存储空间，通过 ClassLoaderMetaspace 来进行管理 SpaceManager* 的指针，相互隔离的。\n- **MetaSpace 弹性伸缩：**由于 MetaSpace 空间和 Heap 并不在一起，所以这块的空间可以不用设置或者单独设置，一般情况下避免 MetaSpace 耗尽 VM 内存都会设置一个 MaxMetaSpaceSize，在运行过程中，如果实际大小小于这个值，JVM 就会通过`-XX:MinMetaspaceFreeRatio`和`-XX:MaxMetaspaceFreeRatio`两个参数动态控制整个 MetaSpace 的大小，具体使用可以看`MetaSpaceGC::compute_new_size()`方法（下方代码），这个方法会在 CMSCollector 和 G1CollectorHeap 等几个收集器执行 GC 时调用。这个里面会根据`used_after_gc`，`MinMetaspaceFreeRatio`和`MaxMetaspaceFreeRatio`这三个值计算出来一个新的`_capacity_until_GC`值（水位线）。然后根据实际的`_capacity_until_GC`值使用`MetaspaceGC::inc_capacity_until_GC()`和`MetaspaceGC::dec_capacity_until_GC()`进行 expand 或 shrink，这个过程也可以参照场景一中的伸缩模型进行理解。\n\nMetaspaceGC::compute_new_size()\n\n```cpp\nvoid MetaspaceGC::compute_new_size() {\n  assert(_shrink_factor <= 100, \"invalid shrink factor\");\n  uint current_shrink_factor = _shrink_factor;\n  _shrink_factor = 0;\n  const size_t used_after_gc = MetaspaceUtils::committed_bytes();\n  const size_t capacity_until_GC = MetaspaceGC::capacity_until_GC();\n\n  const double minimum_free_percentage = MinMetaspaceFreeRatio / 100.0;\n  const double maximum_used_percentage = 1.0 - minimum_free_percentage;\n\n  const double min_tmp = used_after_gc / maximum_used_percentage;\n  size_t minimum_desired_capacity =\n    (size_t)MIN2(min_tmp, double(max_uintx));\n  // Don\'t shrink less than the initial generation size\n  minimum_desired_capacity = MAX2(minimum_desired_capacity,\n                                  MetaspaceSize);\n\n  log_trace(gc, metaspace)(\"MetaspaceGC::compute_new_size: \");\n  log_trace(gc, metaspace)(\"    minimum_free_percentage: %6.2f  maximum_used_percentage: %6.2f\",\n                           minimum_free_percentage, maximum_used_percentage);\n  log_trace(gc, metaspace)(\"     used_after_gc       : %6.1fKB\", used_after_gc / (double) K);\n\n  size_t shrink_bytes = 0;\n  if (capacity_until_GC < minimum_desired_capacity) {\n    // If we have less capacity below the metaspace HWM, then\n    // increment the HWM.\n    size_t expand_bytes = minimum_desired_capacity - capacity_until_GC;\n    expand_bytes = align_up(expand_bytes, Metaspace::commit_alignment());\n    // Don\'t expand unless it\'s significant\n    if (expand_bytes >= MinMetaspaceExpansion) {\n      size_t new_capacity_until_GC = 0;\n      bool succeeded = MetaspaceGC::inc_capacity_until_GC(expand_bytes, &new_capacity_until_GC);\n      assert(succeeded, \"Should always succesfully increment HWM when at safepoint\");\n\n      Metaspace::tracer()->report_gc_threshold(capacity_until_GC,\n                                               new_capacity_until_GC,\n                                               MetaspaceGCThresholdUpdater::ComputeNewSize);\n      log_trace(gc, metaspace)(\"    expanding:  minimum_desired_capacity: %6.1fKB  expand_bytes: %6.1fKB  MinMetaspaceExpansion: %6.1fKB  new metaspace HWM:  %6.1fKB\",\n                               minimum_desired_capacity / (double) K,\n                               expand_bytes / (double) K,\n                               MinMetaspaceExpansion / (double) K,\n                               new_capacity_until_GC / (double) K);\n    }\n    return;\n  }\n\n  // No expansion, now see if we want to shrink\n  // We would never want to shrink more than this\n  assert(capacity_until_GC >= minimum_desired_capacity,\n         SIZE_FORMAT \" >= \" SIZE_FORMAT,\n         capacity_until_GC, minimum_desired_capacity);\n  size_t max_shrink_bytes = capacity_until_GC - minimum_desired_capacity;\n\n  // Should shrinking be considered?\n  if (MaxMetaspaceFreeRatio < 100) {\n    const double maximum_free_percentage = MaxMetaspaceFreeRatio / 100.0;\n    const double minimum_used_percentage = 1.0 - maximum_free_percentage;\n    const double max_tmp = used_after_gc / minimum_used_percentage;\n    size_t maximum_desired_capacity = (size_t)MIN2(max_tmp, double(max_uintx));\n    maximum_desired_capacity = MAX2(maximum_desired_capacity,\n                                    MetaspaceSize);\n    log_trace(gc, metaspace)(\"    maximum_free_percentage: %6.2f  minimum_used_percentage: %6.2f\",\n                             maximum_free_percentage, minimum_used_percentage);\n    log_trace(gc, metaspace)(\"    minimum_desired_capacity: %6.1fKB  maximum_desired_capacity: %6.1fKB\",\n                             minimum_desired_capacity / (double) K, maximum_desired_capacity / (double) K);\n\n    assert(minimum_desired_capacity <= maximum_desired_capacity,\n           \"sanity check\");\n\n    if (capacity_until_GC > maximum_desired_capacity) {\n      // Capacity too large, compute shrinking size\n      shrink_bytes = capacity_until_GC - maximum_desired_capacity;\n      shrink_bytes = shrink_bytes / 100 * current_shrink_factor;\n\n      shrink_bytes = align_down(shrink_bytes, Metaspace::commit_alignment());\n\n      assert(shrink_bytes <= max_shrink_bytes,\n             \"invalid shrink size \" SIZE_FORMAT \" not <= \" SIZE_FORMAT,\n             shrink_bytes, max_shrink_bytes);\n      if (current_shrink_factor == 0) {\n        _shrink_factor = 10;\n      } else {\n        _shrink_factor = MIN2(current_shrink_factor * 4, (uint) 100);\n      }\n      log_trace(gc, metaspace)(\"    shrinking:  initThreshold: %.1fK  maximum_desired_capacity: %.1fK\",\n                               MetaspaceSize / (double) K, maximum_desired_capacity / (double) K);\n      log_trace(gc, metaspace)(\"    shrink_bytes: %.1fK  current_shrink_factor: %d  new shrink factor: %d  MinMetaspaceExpansion: %.1fK\",\n                               shrink_bytes / (double) K, current_shrink_factor, _shrink_factor, MinMetaspaceExpansion / (double) K);\n    }\n  }\n\n  // Don\'t shrink unless it\'s significant\n  if (shrink_bytes >= MinMetaspaceExpansion &&\n      ((capacity_until_GC - shrink_bytes) >= MetaspaceSize)) {\n    size_t new_capacity_until_GC = MetaspaceGC::dec_capacity_until_GC(shrink_bytes);\n    Metaspace::tracer()->report_gc_threshold(capacity_until_GC,\n                                             new_capacity_until_GC,\n                                             MetaspaceGCThresholdUpdater::ComputeNewSize);\n  }\n}\n```\n\n由场景一可知，为了避免弹性伸缩带来的额外 GC 消耗，我们会将 `-XX:MetaSpaceSize` 和 `-XX:MaxMetaSpaceSize` 两个值设置为固定的，但是这样也会导致在空间不够的时候无法扩容，然后频繁地触发 GC，最终 OOM。所以关键原因就是 ClassLoader 不停地在内存中 load 了新的 Class ，一般这种问题都发生在动态类加载等情况上。\n\n**4.3.3 策略**\n\n了解大概什么原因后，如何定位和解决就很简单了，可以 dump 快照之后通过 JProfiler 或 MAT 观察 Classes 的 Histogram（直方图） 即可，或者直接通过命令即可定位， jcmd 打几次 Histogram 的图，看一下具体是哪个包下的 Class 增加较多就可以定位了。不过有时候也要结合InstBytes、KlassBytes、Bytecodes、MethodAll 等几项指标综合来看下。如下图便是笔者使用 jcmd 排查到一个 Orika 的问题。\n\n```bash\njcmd <PID> GC.class_stats|awk \'{print$13}\'|sed  \'s/\\(.*\\)\\.\\(.*\\)/\\1/g\'|sort |uniq -c|sort -nrk1\n```\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-b7707c54095cedf638dc20a371e5fd91_1440w.png)\n\n如果无法从整体的角度定位，可以添加 `-XX:+TraceClassLoading` 和 `-XX:+TraceClassUnLoading` 参数观察详细的类加载和卸载信息。\n\n**4.3.4 小结**\n\n原理理解比较复杂，但定位和解决问题会比较简单，经常会出问题的几个点有 Orika 的 classMap、JSON 的 ASMSerializer、Groovy 动态加载类等，基本都集中在反射、Javasisit 字节码增强、CGLIB 动态代理、OSGi 自定义类加载器等的技术点上。另外就是及时给 MetaSpace 区的使用率加一个监控，如果指标有波动提前发现并解决问题。\n\n## **4.4 场景四：过早晋升 **\n\n**4.4.1 现象**\n\n这种场景主要发生在分代的收集器上面，专业的术语称为“Premature Promotion”。90% 的对象朝生夕死，只有在 Young 区经历过几次 GC 的洗礼后才会晋升到 Old 区，每经历一次 GC 对象的 GC Age 就会增长 1，最大通过 `-XX:MaxTenuringThreshold` 来控制。\n\n过早晋升一般不会直接影响 GC，总会伴随着浮动垃圾、大对象担保失败等问题，但这些问题不是立刻发生的，我们可以观察以下几种现象来判断是否发生了过早晋升。\n\n**分配速率接近于晋升速率**，对象晋升年龄较小。\n\nGC 日志中出现“Desired survivor size 107347968 bytes, **new threshold 1(max 6)**”等信息，说明此时经历过一次 GC 就会放到 Old 区。\n\n**Full GC 比较频繁**，且经历过一次 GC 之后 Old 区的**变化比例非常大**。\n\n比如说 Old 区触发的回收阈值是 80%，经历过一次 GC 之后下降到了 10%，这就说明 Old 区的 70% 的对象存活时间其实很短，如下图所示，Old 区大小每次 GC 后从 2.1G 回收到 300M，也就是说回收掉了 1.8G 的垃圾，只有 **300M 的活跃对象**。整个 Heap 目前是 4G，活跃对象只占了不到十分之一。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-ade2c117e5590cee987e553c67a04fe1_1440w.png)\n\n过早晋升的危害：\n\n- Young GC 频繁，总的吞吐量下降。\n- Full GC 频繁，可能会有较大停顿。\n\n**4.4.2 原因**\n\n主要的原因有以下两点：\n\n- **Young/Eden 区过小：**过小的直接后果就是 Eden 被装满的时间变短，本应该回收的对象参与了 GC 并晋升，Young GC 采用的是复制算法，由基础篇我们知道 copying 耗时远大于 mark，也就是 Young GC 耗时本质上就是 copy 的时间（CMS 扫描 Card Table 或 G1 扫描 Remember Set 出问题的情况另说），没来及回收的对象增大了回收的代价，所以 Young GC 时间增加，同时又无法快速释放空间，Young GC 次数也跟着增加。\n- **分配速率过大：**可以观察出问题前后 Mutator 的分配速率，如果有明显波动可以尝试观察网卡流量、存储类中间件慢查询日志等信息，看是否有大量数据被加载到内存中。\n\n同时无法 GC 掉对象还会带来另外一个问题，引发动态年龄计算：JVM 通过 `-XX:MaxTenuringThreshold` 参数来控制晋升年龄，每经过一次 GC，年龄就会加一，达到最大年龄就可以进入 Old 区，最大值为 15（因为 JVM 中使用 4 个比特来表示对象的年龄）。设定固定的 MaxTenuringThreshold 值作为晋升条件：\n\n- MaxTenuringThreshold 如果设置得过大，原本应该晋升的对象一直停留在 Survivor 区，直到 Survivor 区溢出，一旦溢出发生，Eden + Survivor 中对象将不再依据年龄全部提升到 Old 区，这样对象老化的机制就失效了。\n- MaxTenuringThreshold 如果设置得过小，过早晋升即对象不能在 Young 区充分被回收，大量短期对象被晋升到 Old 区，Old 区空间迅速增长，引起频繁的 Major GC，分代回收失去了意义，严重影响 GC 性能。\n\n相同应用在不同时间的表现不同，特殊任务的执行或者流量成分的变化，都会导致对象的生命周期分布发生波动，那么固定的阈值设定，因为无法动态适应变化，会造成和上面问题，所以 Hotspot 会使用动态计算的方式来调整晋升的阈值。\n\n具体动态计算可以看一下 Hotspot 源码，具体在 /src/hotspot/share/gc/shared/ageTable.cpp 的 `compute_tenuring_threshold` 方法中：\n\ncompute_tenuring_threshold\n\n```cpp\nuint ageTable::compute_tenuring_threshold(size_t survivor_capacity) {\n  //TargetSurvivorRatio默认50，意思是：在回收之后希望survivor区的占用率达到这个比例\n  size_t desired_survivor_size = (size_t)((((double) survivor_capacity)*TargetSurvivorRatio)/100);\n  size_t total = 0;\n  uint age = 1;\n  assert(sizes[0] == 0, \"no objects with age zero should be recorded\");\n  while (age < table_size) {//table_size=16\n    total += sizes[age];\n    //如果加上这个年龄的所有对象的大小之后，占用量>期望的大小，就设置age为新的晋升阈值\n    if (total > desired_survivor_size) break;\n    age++;\n  }\n\n  uint result = age < MaxTenuringThreshold ? age : MaxTenuringThreshold;\n  if (PrintTenuringDistribution || UsePerfData) {\n\n    //打印期望的survivor的大小以及新计算出来的阈值，和设置的最大阈值\n    if (PrintTenuringDistribution) {\n      gclog_or_tty->cr();\n      gclog_or_tty->print_cr(\"Desired survivor size \" SIZE_FORMAT \" bytes, new threshold %u (max %u)\",\n        desired_survivor_size*oopSize, result, (int) MaxTenuringThreshold);\n    }\n\n    total = 0;\n    age = 1;\n    while (age < table_size) {\n      total += sizes[age];\n      if (sizes[age] > 0) {\n        if (PrintTenuringDistribution) {\n          gclog_or_tty->print_cr(\"- age %3u: \" SIZE_FORMAT_W(10) \" bytes, \" SIZE_FORMAT_W(10) \" total\",\n                                        age,    sizes[age]*oopSize,          total*oopSize);\n        }\n      }\n      if (UsePerfData) {\n        _perf_sizes[age]->set_value(sizes[age]*oopSize);\n      }\n      age++;\n    }\n    if (UsePerfData) {\n      SharedHeap* sh = SharedHeap::heap();\n      CollectorPolicy* policy = sh->collector_policy();\n      GCPolicyCounters* gc_counters = policy->counters();\n      gc_counters->tenuring_threshold()->set_value(result);\n      gc_counters->desired_survivor_size()->set_value(\n        desired_survivor_size*oopSize);\n    }\n  }\n\n  return result;\n}\n```\n\n可以看到 Hotspot 遍历所有对象时，从所有年龄为 0 的对象占用的空间开始累加，如果加上年龄等于 n 的所有对象的空间之后，使用 Survivor 区的条件值（TargetSurvivorRatio / 100，TargetSurvivorRatio 默认值为 50）进行判断，若大于这个值则结束循环，将 n 和 MaxTenuringThreshold 比较，若 n 小，则阈值为 n，若 n 大，则只能去设置最大阈值为 MaxTenuringThreshold。**动态年龄触发后导致更多的对象进入了 Old 区，造成资源浪费**。\n\n**4.4.3 策略**\n\n知道问题原因后我们就有解决的方向，如果是 **Young/Eden 区过小**，我们可以在总的 Heap 内存不变的情况下适当增大 Young 区，具体怎么增加？一般情况下 Old 的大小应当为活跃对象的 2~3 倍左右，考虑到浮动垃圾问题最好在 3 倍左右，剩下的都可以分给 Young 区。\n\n拿笔者的一次典型过早晋升优化来看，原配置为 Young 1.2G + Old 2.8G，通过观察 CMS GC 的情况找到存活对象大概为 300~400M，于是调整 Old 1.5G 左右，剩下 2.5G 分给 Young 区。仅仅调了一个 Young 区大小参数（`-Xmn`），整个 JVM 一分钟 Young GC 从 26 次降低到了 11 次，单次时间也没有增加，总的 GC 时间从 1100ms 降低到了 500ms，CMS GC 次数也从 40 分钟左右一次降低到了 7 小时 30 分钟一次。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-b5456730169750a0aedb6aacfafb5af2_1440w.png)\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-40b19dfbe41c6d7ef16931f698a66af7_1440w.png)\n\n如果是分配速率过大：\n\n- **偶发较大**：通过内存分析工具找到问题代码，从业务逻辑上做一些优化。\n- **一直较大**：当前的 Collector 已经不满足 Mutator 的期望了，这种情况要么扩容 Mutator 的 VM，要么调整 GC 收集器类型或加大空间。\n\n**4.4.4 小结**\n\n过早晋升问题一般不会特别明显，但日积月累之后可能会爆发一波收集器退化之类的问题，所以我们还是要提前避免掉的，可以看看自己系统里面是否有这些现象，如果比较匹配的话，可以尝试优化一下。一行代码优化的 ROI 还是很高的。\n\n如果在观察 Old 区前后比例变化的过程中，发现可以回收的比例非常小，如从 80% 只回收到了 60%，说明我们大部分对象都是存活的，Old 区的空间可以适当调大些。\n\n**4.4.5 加餐**\n\n关于在调整 Young 与 Old 的比例时，如何选取具体的 NewRatio 值，这里将问题抽象成为一个蓄水池模型，找到以下关键衡量指标，大家可以根据自己场景进行推算。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-ee457fc11fed168c0a633010efd58a00_1440w.png)\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-09e05c1f3baa66890631e8705d471425_1440w.png)\n\n- NewRatio 的值 r 与 va、vp、vyc、voc、rs 等值存在一定函数相关性（rs 越小 r 越大、r 越小 vp 越小，…，之前尝试使用 NN 来辅助建模，但目前还没有完全算出具体的公式，有想法的同学可以在评论区给出你的答案 ）。\n- 总停顿时间 T 为 Young GC 总时间 Tyc 和 Old GC 总时间 Toc 之和，其中 Tyc 与 vyc 和 vp 相关，Toc 与 voc相关。\n- 忽略掉 GC 时间后，两次 Young GC 的时间间隔要大于 TP9999 时间，这样尽量让对象在 Eden 区就被回收，可以减少很多停顿。\n\n## **4.5 场景五：CMS Old GC 频繁 **\n\n**4.5.1 现象**\n\nOld 区频繁的做 CMS GC，但是每次耗时不是特别长，整体最大 STW 也在可接受范围内，但由于 GC 太频繁导致吞吐下降比较多。\n\n**4.5.2 原因**\n\n这种情况比较常见，基本都是一次 Young GC 完成后，负责处理 CMS GC 的一个后台线程 concurrentMarkSweepThread 会不断地轮询，使用 `shouldConcurrentCollect()` 方法做一次检测，判断是否达到了回收条件。如果达到条件，使用 `collect_in_background()` 启动一次 Background 模式 GC。轮询的判断是使用 `sleepBeforeNextCycle()` 方法，间隔周期为 `-XX:CMSWaitDuration` 决定，默认为2s。\n\n具体代码在：src/hotspot/share/gc/cms/concurrentMarkSweepThread.cpp。\n\nrun_service()\n\n```cpp\nvoid ConcurrentMarkSweepThread::run_service() {\n  assert(this == cmst(), \"just checking\");\n\n  if (BindCMSThreadToCPU && !os::bind_to_processor(CPUForCMSThread)) {\n    log_warning(gc)(\"Couldn\'t bind CMS thread to processor \" UINTX_FORMAT, CPUForCMSThread);\n  }\n\n  while (!should_terminate()) {\n    sleepBeforeNextCycle();\n    if (should_terminate()) break;\n    GCIdMark gc_id_mark;\n    GCCause::Cause cause = _collector->_full_gc_requested ?\n      _collector->_full_gc_cause : GCCause::_cms_concurrent_mark;\n    _collector->collect_in_background(cause);\n  }\n  verify_ok_to_terminate();\n}\n```\n\nsleepBeforeNextCycle()\n\n```cpp\nvoid ConcurrentMarkSweepThread::sleepBeforeNextCycle() {\n  while (!should_terminate()) {\n    if(CMSWaitDuration >= 0) {\n      // Wait until the next synchronous GC, a concurrent full gc\n      // request or a timeout, whichever is earlier.\n      wait_on_cms_lock_for_scavenge(CMSWaitDuration);\n    } else {\n      // Wait until any cms_lock event or check interval not to call shouldConcurrentCollect permanently\n      wait_on_cms_lock(CMSCheckInterval);\n    }\n    // Check if we should start a CMS collection cycle\n    if (_collector->shouldConcurrentCollect()) {\n      return;\n    }\n    // .. collection criterion not yet met, let\'s go back\n    // and wait some more\n  }\n}\n```\n\n判断是否进行回收的代码在：/src/hotspot/share/gc/cms/concurrentMarkSweepGeneration.cpp。\n\nshouldConcurrentCollect()\n\n```cpp\nbool CMSCollector::shouldConcurrentCollect() {\n  LogTarget(Trace, gc) log;\n\n  if (_full_gc_requested) {\n    log.print(\"CMSCollector: collect because of explicit  gc request (or GCLocker)\");\n    return true;\n  }\n\n  FreelistLocker x(this);\n  // ------------------------------------------------------------------\n  // Print out lots of information which affects the initiation of\n  // a collection.\n  if (log.is_enabled() && stats().valid()) {\n    log.print(\"CMSCollector shouldConcurrentCollect: \");\n\n    LogStream out(log);\n    stats().print_on(&out);\n\n    log.print(\"time_until_cms_gen_full %3.7f\", stats().time_until_cms_gen_full());\n    log.print(\"free=\" SIZE_FORMAT, _cmsGen->free());\n    log.print(\"contiguous_available=\" SIZE_FORMAT, _cmsGen->contiguous_available());\n    log.print(\"promotion_rate=%g\", stats().promotion_rate());\n    log.print(\"cms_allocation_rate=%g\", stats().cms_allocation_rate());\n    log.print(\"occupancy=%3.7f\", _cmsGen->occupancy());\n    log.print(\"initiatingOccupancy=%3.7f\", _cmsGen->initiating_occupancy());\n    log.print(\"cms_time_since_begin=%3.7f\", stats().cms_time_since_begin());\n    log.print(\"cms_time_since_end=%3.7f\", stats().cms_time_since_end());\n    log.print(\"metadata initialized %d\", MetaspaceGC::should_concurrent_collect());\n  }\n  // ------------------------------------------------------------------\n  if (!UseCMSInitiatingOccupancyOnly) {\n    if (stats().valid()) {\n      if (stats().time_until_cms_start() == 0.0) {\n        return true;\n      }\n    } else {\n\n      if (_cmsGen->occupancy() >= _bootstrap_occupancy) {\n        log.print(\" CMSCollector: collect for bootstrapping statistics: occupancy = %f, boot occupancy = %f\",\n                  _cmsGen->occupancy(), _bootstrap_occupancy);\n        return true;\n      }\n    }\n  }\n\n  if (_cmsGen->should_concurrent_collect()) {\n    log.print(\"CMS old gen initiated\");\n    return true;\n  }\n\n  // We start a collection if we believe an incremental collection may fail;\n  // this is not likely to be productive in practice because it\'s probably too\n  // late anyway.\n  CMSHeap* heap = CMSHeap::heap();\n  if (heap->incremental_collection_will_fail(true /* consult_young */)) {\n    log.print(\"CMSCollector: collect because incremental collection will fail \");\n    return true;\n  }\n\n  if (MetaspaceGC::should_concurrent_collect()) {\n    log.print(\"CMSCollector: collect for metadata allocation \");\n    return true;\n  }\n\n  // CMSTriggerInterval starts a CMS cycle if enough time has passed.\n  if (CMSTriggerInterval >= 0) {\n    if (CMSTriggerInterval == 0) {\n      // Trigger always\n      return true;\n    }\n\n    // Check the CMS time since begin (we do not check the stats validity\n    // as we want to be able to trigger the first CMS cycle as well)\n    if (stats().cms_time_since_begin() >= (CMSTriggerInterval / ((double) MILLIUNITS))) {\n      if (stats().valid()) {\n        log.print(\"CMSCollector: collect because of trigger interval (time since last begin %3.7f secs)\",\n                  stats().cms_time_since_begin());\n      } else {\n        log.print(\"CMSCollector: collect because of trigger interval (first collection)\");\n      }\n      return true;\n    }\n  }\n\n  return false;\n}\n```\n\n分析其中逻辑判断是否触发 GC，分为以下几种情况：\n\n- **触发 CMS GC：**通过调用`_collector->collect_in_background()`进行触发 Background GC 。\n- \n- **触发 Full GC：**直接进行 Full GC，这种情况到场景七中展开说明。\n- \n\n**触发 CMS GC：**通过调用 `_collector->collect_in_background()` 进行触发 Background GC 。\n\n- CMS 默认采用 JVM 运行时的统计数据判断是否需要触发 CMS GC，如果需要根据`-XX:CMSInitiatingOccupancyFraction`的值进行判断，需要设置参数`-XX:+UseCMSInitiatingOccupancyOnly`。\n\n- 如果开启了`-XX:UseCMSInitiatingOccupancyOnly`参数，判断当前 Old 区使用率是否大于阈值，则触发 CMS GC，该阈值可以通过参数`-XX:CMSInitiatingOccupancyFraction`进行设置，如果没有设置，默认为 92%。\n- 如果之前的 Young GC 失败过，或者下次 Young 区执行 Young GC 可能失败，这两种情况下都需要触发 CMS GC。\n- CMS 默认不会对 MetaSpace 或 Perm 进行垃圾收集，如果希望对这些区域进行垃圾收集，需要设置参数`-XX:+CMSClassUnloadingEnabled`。\n\n**触发 Full GC：**直接进行 Full GC，这种情况到场景七中展开说明。\n\n- 如果`_full_gc_requested`为真，说明有明确的需求要进行 GC，比如调用 System.gc。\n\n- 在 Eden 区为对象或 TLAB 分配内存失败，导致一次 Young GC，在`GenCollectorPolicy`类的`satisfy_failed_allocation()`方法中进行判断。\n\n大家可以看一下源码中的日志打印，通过日志我们就可以比较清楚地知道具体的原因，然后就可以着手分析了。\n\n**4.5.3 策略**\n\n我们这里还是拿最常见的达到回收比例这个场景来说，与过早晋升不同的是这些对象确实存活了一段时间，Survival Time 超过了 TP9999 时间，但是又达不到长期存活，如各种数据库、网络链接，带有失效时间的缓存等。\n\n处理这种常规内存泄漏问题基本是一个思路，主要步骤如下：\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-40aec4367afa88dc39a96f90120ed395_1440w.png)\n\nDump Diff 和 Leak Suspects 比较直观就不介绍了，这里说下其它几个关键点：\n\n- **内存 Dump：**使用 jmap、arthas 等 dump 堆进行快照时记得摘掉流量，同时**分别在 CMS GC 的发生前后分别 dump 一次**。\n- **分析 Top Component：**要记得按照对象、类、类加载器、包等多个维度观察 Histogram，同时使用 outgoing 和 incoming 分析关联的对象，另外就是 Soft Reference 和 Weak Reference、Finalizer 等也要看一下。\n- **分析 Unreachable：**重点看一下这个，关注下 Shallow 和 Retained 的大小。如下图所示，笔者之前一次 GC 优化，就根据 Unreachable Objects 发现了 Hystrix 的滑动窗口问题。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-e9226cf558ac9709e18469212197d6e5_1440w.png)\n\n**4.5.4 小结**\n\n经过整个流程下来基本就能定位问题了，不过在优化的过程中记得使用**控制变量**的方法来优化，防止一些会加剧问题的改动被掩盖。\n\n目前，互联网上 Java 的 GC 资料要么是主要讲解理论，要么就是针对单一场景的 GC 问题进行了剖析，对整个体系总结的资料少之又少。前车之鉴，后事之师，美团的几位工程师历时一年多的时间，搜集了内部各种 GC 问题的分析文章，并结合个人的理解做了一些总结，希望能起到“抛砖引玉”的作用。\n\n## **4.6 场景六：单次 CMS Old GC 耗时长 **\n\n**4.6.1 现象**\n\nCMS GC 单次 STW 最大超过 1000ms，不会频繁发生，如下图所示最长达到了 8000ms。某些场景下会引起“雪崩效应”，这种场景非常危险，我们应该尽量避免出现。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-4053612fa65cc0e94680cb8038dc68f2_1440w.png)\n\n**4.6.2 原因**\n\nCMS 在回收的过程中，STW 的阶段主要是 Init Mark 和 Final Remark 这两个阶段，也是导致 CMS Old GC 最多的原因，另外有些情况就是在 STW 前等待 Mutator 的线程到达 SafePoint 也会导致时间过长，但这种情况较少，我们在此处主要讨论前者。发生收集器退化或者碎片压缩的场景请看场景七。\n\n想要知道这两个阶段为什么会耗时，我们需要先看一下这两个阶段都会干什么。\n\n核心代码都在 /src/hotspot/share/gc/cms/concurrentMarkSweepGeneration.cpp 中，内部有个线程 ConcurrentMarkSweepThread 轮询来校验，Old 区的垃圾回收相关细节被完全封装在 CMSCollector 中，调用入口就是 ConcurrentMarkSweepThread 调用的 CMSCollector::collect_in_background 和 ConcurrentMarkSweepGeneration 调用的 CMSCollector::collect 方法，此处我们讨论大多数场景的 collect_in_background。整个过程中会 STW 的主要是 initial Mark 和 Final Remark，核心代码在 VM_CMS_Initial_Mark / VM_CMS_Final_Remark 中，执行时需要将执行权交由 VMThread 来执行。\n\n- CMS Init Mark执行步骤，实现在 CMSCollector::checkpointRootsInitialWork() 和 CMSParInitialMarkTask::work 中，整体步骤和代码如下：\n\nCMSCollector::checkpointRootsInitialWork()\n\n```cpp\nvoid CMSCollector::checkpointRootsInitialWork() {\n  assert(SafepointSynchronize::is_at_safepoint(), \"world should be stopped\");\n  assert(_collectorState == InitialMarking, \"just checking\");\n\n  // Already have locks.\n  assert_lock_strong(bitMapLock());\n  assert(_markBitMap.isAllClear(), \"was reset at end of previous cycle\");\n\n  // Setup the verification and class unloading state for this\n  // CMS collection cycle.\n  setup_cms_unloading_and_verification_state();\n\n  GCTraceTime(Trace, gc, phases) ts(\"checkpointRootsInitialWork\", _gc_timer_cm);\n\n  // Reset all the PLAB chunk arrays if necessary.\n  if (_survivor_plab_array != NULL && !CMSPLABRecordAlways) {\n    reset_survivor_plab_arrays();\n  }\n\n  ResourceMark rm;\n  HandleMark  hm;\n\n  MarkRefsIntoClosure notOlder(_span, &_markBitMap);\n  CMSHeap* heap = CMSHeap::heap();\n\n  verify_work_stacks_empty();\n  verify_overflow_empty();\n\n  heap->ensure_parsability(false);  // fill TLABs, but no need to retire them\n  // Update the saved marks which may affect the root scans.\n  heap->save_marks();\n\n  // weak reference processing has not started yet.\n  ref_processor()->set_enqueuing_is_done(false);\n\n  // Need to remember all newly created CLDs,\n  // so that we can guarantee that the remark finds them.\n  ClassLoaderDataGraph::remember_new_clds(true);\n\n  // Whenever a CLD is found, it will be claimed before proceeding to mark\n  // the klasses. The claimed marks need to be cleared before marking starts.\n  ClassLoaderDataGraph::clear_claimed_marks();\n\n  print_eden_and_survivor_chunk_arrays();\n\n  {\n    if (CMSParallelInitialMarkEnabled) {\n      // The parallel version.\n      WorkGang* workers = heap->workers();\n      assert(workers != NULL, \"Need parallel worker threads.\");\n      uint n_workers = workers->active_workers();\n\n      StrongRootsScope srs(n_workers);\n\n      CMSParInitialMarkTask tsk(this, &srs, n_workers);\n      initialize_sequential_subtasks_for_young_gen_rescan(n_workers);\n      // If the total workers is greater than 1, then multiple workers\n      // may be used at some time and the initialization has been set\n      // such that the single threaded path cannot be used.\n      if (workers->total_workers() > 1) {\n        workers->run_task(&tsk);\n      } else {\n        tsk.work(0);\n      }\n    } else {\n      // The serial version.\n      CLDToOopClosure cld_closure(&notOlder, true);\n      heap->rem_set()->prepare_for_younger_refs_iterate(false); // Not parallel.\n\n      StrongRootsScope srs(1);\n\n      heap->cms_process_roots(&srs,\n                             true,   // young gen as roots\n                             GenCollectedHeap::ScanningOption(roots_scanning_options()),\n                             should_unload_classes(),\n                             &notOlder,\n                             &cld_closure);\n    }\n  }\n\n  // Clear mod-union table; it will be dirtied in the prologue of\n  // CMS generation per each young generation collection.\n  assert(_modUnionTable.isAllClear(),\n       \"Was cleared in most recent final checkpoint phase\"\n       \" or no bits are set in the gc_prologue before the start of the next \"\n       \"subsequent marking phase.\");\n\n  assert(_ct->cld_rem_set()->mod_union_is_clear(), \"Must be\");\n  // Save the end of the used_region of the constituent generations\n  // to be used to limit the extent of sweep in each generation.\n  save_sweep_limits();\n  verify_overflow_empty();\n}\n```\n\nCMSParInitialMarkTask::work\n\n```cpp\nvoid CMSParInitialMarkTask::work(uint worker_id) {\n  elapsedTimer _timer;\n  ResourceMark rm;\n  HandleMark   hm;\n\n  // ---------- scan from roots --------------\n  _timer.start();\n  CMSHeap* heap = CMSHeap::heap();\n  ParMarkRefsIntoClosure par_mri_cl(_collector->_span, &(_collector->_markBitMap));\n\n  // ---------- young gen roots --------------\n  {\n    work_on_young_gen_roots(&par_mri_cl);\n    _timer.stop();\n    log_trace(gc, task)(\"Finished young gen initial mark scan work in %dth thread: %3.3f sec\", worker_id, _timer.seconds());\n  }\n\n  // ---------- remaining roots --------------\n  _timer.reset();\n  _timer.start();\n\n  CLDToOopClosure cld_closure(&par_mri_cl, true);\n\n  heap->cms_process_roots(_strong_roots_scope,\n                          false,     // yg was scanned above\n                          GenCollectedHeap::ScanningOption(_collector->CMSCollector::roots_scanning_options()),\n                          _collector->should_unload_classes(),\n                          &par_mri_cl,\n                          &cld_closure,\n                          &_par_state_string);\n\n  assert(_collector->should_unload_classes()\n         || (_collector->CMSCollector::roots_scanning_options() & GenCollectedHeap::SO_AllCodeCache),\n         \"if we didn\'t scan the code cache, we have to be ready to drop nmethods with expired weak oops\");\n  _timer.stop();\n  log_trace(gc, task)(\"Finished remaining root initial mark scan work in %dth thread: %3.3f sec\", worker_id, _timer.seconds());\n}\n```\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-f80b3b01033524e8f96fa27fd11d6771_1440w.png)\n\n整个过程比较简单，从 GC Root 出发标记 Old 中的对象，处理完成后借助 BitMap 处理下 Young 区对 Old 区的引用，整个过程基本都比较快，很少会有较大的停顿。\n\n- CMS Final Remark 执行步骤，实现在 CMSCollector::checkpointRootsFinalWork() 中，整体代码和步骤如下：\n\nCMSCollector::checkpointRootsFinalWork()\n\n```cpp\nvoid CMSCollector::checkpointRootsFinalWork() {\n  GCTraceTime(Trace, gc, phases) tm(\"checkpointRootsFinalWork\", _gc_timer_cm);\n\n  assert(haveFreelistLocks(), \"must have free list locks\");\n  assert_lock_strong(bitMapLock());\n\n  ResourceMark rm;\n  HandleMark   hm;\n\n  CMSHeap* heap = CMSHeap::heap();\n\n  if (should_unload_classes()) {\n    CodeCache::gc_prologue();\n  }\n  assert(haveFreelistLocks(), \"must have free list locks\");\n  assert_lock_strong(bitMapLock());\n\n  heap->ensure_parsability(false);  // fill TLAB\'s, but no need to retire them\n  // Update the saved marks which may affect the root scans.\n  heap->save_marks();\n\n  print_eden_and_survivor_chunk_arrays();\n\n  {\n    if (CMSParallelRemarkEnabled) {\n      GCTraceTime(Debug, gc, phases) t(\"Rescan (parallel)\", _gc_timer_cm);\n      do_remark_parallel();\n    } else {\n      GCTraceTime(Debug, gc, phases) t(\"Rescan (non-parallel)\", _gc_timer_cm);\n      do_remark_non_parallel();\n    }\n  }\n  verify_work_stacks_empty();\n  verify_overflow_empty();\n\n  {\n    GCTraceTime(Trace, gc, phases) ts(\"refProcessingWork\", _gc_timer_cm);\n    refProcessingWork();\n  }\n  verify_work_stacks_empty();\n  verify_overflow_empty();\n\n  if (should_unload_classes()) {\n    CodeCache::gc_epilogue();\n  }\n  JvmtiExport::gc_epilogue();\n  assert(_markStack.isEmpty(), \"No grey objects\");\n  size_t ser_ovflw = _ser_pmc_remark_ovflw + _ser_pmc_preclean_ovflw +\n                     _ser_kac_ovflw        + _ser_kac_preclean_ovflw;\n  if (ser_ovflw > 0) {\n    log_trace(gc)(\"Marking stack overflow (benign) (pmc_pc=\" SIZE_FORMAT \", pmc_rm=\" SIZE_FORMAT \", kac=\" SIZE_FORMAT \", kac_preclean=\" SIZE_FORMAT \")\",\n                         _ser_pmc_preclean_ovflw, _ser_pmc_remark_ovflw, _ser_kac_ovflw, _ser_kac_preclean_ovflw);\n    _markStack.expand();\n    _ser_pmc_remark_ovflw = 0;\n    _ser_pmc_preclean_ovflw = 0;\n    _ser_kac_preclean_ovflw = 0;\n    _ser_kac_ovflw = 0;\n  }\n  if (_par_pmc_remark_ovflw > 0 || _par_kac_ovflw > 0) {\n     log_trace(gc)(\"Work queue overflow (benign) (pmc_rm=\" SIZE_FORMAT \", kac=\" SIZE_FORMAT \")\",\n                          _par_pmc_remark_ovflw, _par_kac_ovflw);\n     _par_pmc_remark_ovflw = 0;\n    _par_kac_ovflw = 0;\n  }\n   if (_markStack._hit_limit > 0) {\n     log_trace(gc)(\" (benign) Hit max stack size limit (\" SIZE_FORMAT \")\",\n                          _markStack._hit_limit);\n   }\n   if (_markStack._failed_double > 0) {\n     log_trace(gc)(\" (benign) Failed stack doubling (\" SIZE_FORMAT \"), current capacity \" SIZE_FORMAT,\n                          _markStack._failed_double, _markStack.capacity());\n   }\n  _markStack._hit_limit = 0;\n  _markStack._failed_double = 0;\n\n  if ((VerifyAfterGC || VerifyDuringGC) &&\n      CMSHeap::heap()->total_collections() >= VerifyGCStartAt) {\n    verify_after_remark();\n  }\n\n  _gc_tracer_cm->report_object_count_after_gc(&_is_alive_closure);\n\n  // Change under the freelistLocks.\n  _collectorState = Sweeping;\n  // Call isAllClear() under bitMapLock\n  assert(_modUnionTable.isAllClear(),\n      \"Should be clear by end of the final marking\");\n  assert(_ct->cld_rem_set()->mod_union_is_clear(),\n      \"Should be clear by end of the final marking\");\n}\n```\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-a864edd6b8d3b079634b745633bff104_1440w.png)\n\nFinal Remark 是最终的第二次标记，这种情况只有在 Background GC 执行了 InitialMarking 步骤的情形下才会执行，如果是 Foreground GC 执行的 InitialMarking 步骤则不需要再次执行 FinalRemark。Final Remark 的开始阶段与 Init Mark 处理的流程相同，但是后续多了 Card Table 遍历、Reference 实例的清理并将其加入到 Reference 维护的 pend_list 中，如果要收集元数据信息，还要清理 SystemDictionary、CodeCache、SymbolTable、StringTable 等组件中不再使用的资源。\n\n**4.6.3 策略**\n\n知道了两个 STW 过程执行流程，我们分析解决就比较简单了，由于大部分问题都出在 Final Remark 过程，这里我们也拿这个场景来举例，主要步骤：\n\n- **【方向】**观察详细 GC 日志，找到出问题时 Final Remark 日志，分析下 Reference 处理和元数据处理 real 耗时是否正常，详细信息需要通过 -XX:+PrintReferenceGC 参数开启。**基本在日志里面就能定位到大概是哪个方向出了问题，耗时超过 10% 的就需要关注**。\n\n```log\n2019-02-27T19:55:37.920+0800: 516952.915: [GC (CMS Final Remark) 516952.915: [ParNew516952.939: [SoftReference, 0 refs, 0.0003857 secs]516952.939: [WeakReference, 1362 refs, 0.0002415 secs]516952.940: [FinalReference, 146 refs, 0.0001233 secs]516952.940: [PhantomReference, 0 refs, 57 refs, 0.0002369 secs]516952.940: [JNI Weak Reference, 0.0000662 secs]\n[class unloading, 0.1770490 secs]516953.329: [scrub symbol table, 0.0442567 secs]516953.373: [scrub string table, 0.0036072 secs][1 CMS-remark: 1638504K(2048000K)] 1667558K(4352000K), 0.5269311 secs] [Times: user=1.20 sys=0.03, real=0.53 secs]\n```\n\n- **【根因】**有了具体的方向我们就可以进行深入的分析，一般来说最容易出问题的地方就是 Reference 中的 FinalReference 和元数据信息处理中的 scrub symbol table 两个阶段，想要找到具体问题代码就需要内存分析工具 MAT 或 JProfiler 了，注意要 dump 即将开始 CMS GC 的堆。在用 MAT 等工具前也可以先用命令行看下对象 Histogram，有可能直接就能定位问题。\n- 对 FinalReference 的分析主要观察 java.lang.ref.Finalizer 对象的 dominator tree，找到泄漏的来源。经常会出现问题的几个点有 Socket 的 SocksSocketImpl 、Jersey 的 ClientRuntime、MySQL 的 ConnectionImpl 等等。\n- scrub symbol table 表示清理元数据符号引用耗时，符号引用是 Java 代码被编译成字节码时，方法在 JVM 中的表现形式，生命周期一般与 Class 一致，当 _should_unload_classes 被设置为 true 时在 CMSCollector::refProcessingWork() 中与 Class Unload、String Table 一起被处理。\n\nCMSCollector::refProcessingWork()\n\n```cpp\nif (should_unload_classes()) {\n    {\n      GCTraceTime(Debug, gc, phases) t(\"Class Unloading\", _gc_timer_cm);\n\n      // Unload classes and purge the SystemDictionary.\n      bool purged_class = SystemDictionary::do_unloading(_gc_timer_cm);\n\n      // Unload nmethods.\n      CodeCache::do_unloading(&_is_alive_closure, purged_class);\n\n      // Prune dead klasses from subklass/sibling/implementor lists.\n      Klass::clean_weak_klass_links(purged_class);\n    }\n\n    {\n      GCTraceTime(Debug, gc, phases) t(\"Scrub Symbol Table\", _gc_timer_cm);\n      // Clean up unreferenced symbols in symbol table.\n      SymbolTable::unlink();\n    }\n\n    {\n      GCTraceTime(Debug, gc, phases) t(\"Scrub String Table\", _gc_timer_cm);\n      // Delete entries for dead interned strings.\n      StringTable::unlink(&_is_alive_closure);\n    }\n  }\n```\n\n- **【策略】**知道 GC 耗时的根因就比较好处理了，这种问题不会大面积同时爆发，不过有很多时候单台 STW 的时间会比较长，如果业务影响比较大，及时摘掉流量，具体后续优化策略如下：\n- FinalReference：找到内存来源后通过优化代码的方式来解决，如果短时间无法定位可以增加 -XX:+ParallelRefProcEnabled 对 Reference 进行并行处理。\n- symbol table：观察 MetaSpace 区的历史使用峰值，以及每次 GC 前后的回收情况，一般没有使用动态类加载或者 DSL 处理等，MetaSpace 的使用率上不会有什么变化，这种情况可以通过 -XX:-CMSClassUnloadingEnabled 来避免 MetaSpace 的处理，JDK8 会默认开启 CMSClassUnloadingEnabled，这会使得 CMS 在 CMS-Remark 阶段尝试进行类的卸载。\n\n**4.6.4 小结**\n\n正常情况进行的 Background CMS GC，出现问题基本都集中在 Reference 和 Class 等元数据处理上，在 Reference 类的问题处理方面，不管是 FinalReference，还是 SoftReference、WeakReference 核心的手段就是找准时机 dump 快照，然后用内存分析工具来分析。Class 处理方面目前除了关闭类卸载开关，没有太好的方法。\n\n在 G1 中同样有 Reference 的问题，可以观察日志中的 Ref Proc，处理方法与 CMS 类似。\n\n## 4.7 场景七：内存碎片&收集器退化\n\n**4.7.1 现象**\n\n并发的 CMS GC 算法，退化为 Foreground 单线程串行 GC 模式，STW 时间超长，有时会长达十几秒。其中 CMS 收集器退化后单线程串行 GC 算法有两种：\n\n- 带压缩动作的算法，称为 MSC，上面我们介绍过，使用标记-清理-压缩，单线程全暂停的方式，对整个堆进行垃圾收集，也就是真正意义上的 Full GC，暂停时间要长于普通 CMS。\n- 不带压缩动作的算法，收集 Old 区，和普通的 CMS 算法比较相似，暂停时间相对 MSC 算法短一些。\n\n**4.7.2 原因**\n\nCMS 发生收集器退化主要有以下几种情况。\n\n**晋升失败（Promotion Failed）**\n\n顾名思义，晋升失败就是指在进行 Young GC 时，Survivor 放不下，对象只能放入 Old，但此时 Old 也放不下。直觉上乍一看这种情况可能会经常发生，但其实因为有 concurrentMarkSweepThread 和担保机制的存在，发生的条件是很苛刻的，除非是短时间将 Old 区的剩余空间迅速填满，例如上文中说的动态年龄判断导致的过早晋升（见下文的增量收集担保失败）。另外还有一种情况就是内存碎片导致的 Promotion Failed，Young GC 以为 Old 有足够的空间，结果到分配时，晋级的大对象找不到连续的空间存放。\n\n使用 CMS 作为 GC 收集器时，运行过一段时间的 Old 区如下图所示，清除算法导致内存出现多段的不连续，出现大量的内存碎片。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-8f4de3e5ea0b2bd0658969a24462db41_1440w.png)\n\n碎片带来了两个问题：\n\n- **空间分配效率较低**：上文已经提到过，如果是连续的空间 JVM 可以通过使用 pointer bumping 的方式来分配，而对于这种有大量碎片的空闲链表则需要逐个访问 freelist 中的项来访问，查找可以存放新建对象的地址。\n- **空间利用效率变低**：Young 区晋升的对象大小大于了连续空间的大小，那么将会触发 Promotion Failed ，即使整个 Old 区的容量是足够的，但由于其不连续，也无法存放新对象，也就是本文所说的问题。\n\n**增量收集担保失败**\n\n分配内存失败后，会判断统计得到的 Young GC 晋升到 Old 的平均大小，以及当前 Young 区已使用的大小也就是最大可能晋升的对象大小，是否大于 Old 区的剩余空间。只要 CMS 的剩余空间比前两者的任意一者大，CMS 就认为晋升还是安全的，反之，则代表不安全，不进行Young GC，直接触发Full GC。\n\n**显式 GC**\n\n这种情况参见场景二。\n\n**并发模式失败（Concurrent Mode Failure）**\n\n最后一种情况，也是发生概率较高的一种，在 GC 日志中经常能看到 Concurrent Mode Failure 关键字。这种是由于并发 Background CMS GC 正在执行，同时又有 Young GC 晋升的对象要放入到了 Old 区中，而此时 Old 区空间不足造成的。\n\n为什么 CMS GC 正在执行还会导致收集器退化呢？主要是由于 CMS 无法处理浮动垃圾（Floating Garbage）引起的。CMS 的并发清理阶段，Mutator 还在运行，因此不断有新的垃圾产生，而这些垃圾不在这次清理标记的范畴里，无法在本次 GC 被清除掉，这些就是浮动垃圾，除此之外在 Remark 之前那些断开引用脱离了读写屏障控制的对象也算浮动垃圾。所以 Old 区回收的阈值不能太高，否则预留的内存空间很可能不够，从而导致 Concurrent Mode Failure 发生。\n\n**4.7.3 策略**\n\n分析到具体原因后，我们就可以针对性解决了，具体思路还是从根因出发，具体解决策略：\n\n- **内存碎片：**通过配置 -XX:UseCMSCompactAtFullCollection=true 来控制 Full GC的过程中是否进行空间的整理（默认开启，注意是Full GC，不是普通CMS GC），以及 -XX: CMSFullGCsBeforeCompaction=n 来控制多少次 Full GC 后进行一次压缩。\n- **增量收集：**降低触发 CMS GC 的阈值，即参数 -XX:CMSInitiatingOccupancyFraction 的值，让 CMS GC 尽早执行，以保证有足够的连续空间，也减少 Old 区空间的使用大小，另外需要使用 -XX:+UseCMSInitiatingOccupancyOnly 来配合使用，不然 JVM 仅在第一次使用设定值，后续则自动调整。\n- **浮动垃圾：**视情况控制每次晋升对象的大小，或者缩短每次 CMS GC 的时间，必要时可调节 NewRatio 的值。另外就是使用 -XX:+CMSScavengeBeforeRemark 在过程中提前触发一次 Young GC，防止后续晋升过多对象。\n\n**4.7.4 小结**\n\n正常情况下触发并发模式的 CMS GC，停顿非常短，对业务影响很小，但 CMS GC 退化后，影响会非常大，建议发现一次后就彻底根治。只要能定位到内存碎片、浮动垃圾、增量收集相关等具体产生原因，还是比较好解决的，关于内存碎片这块，如果 -XX:CMSFullGCsBeforeCompaction 的值不好选取的话，可以使用 -XX:PrintFLSStatistics 来观察内存碎片率情况，然后再设置具体的值。\n\n最后就是在编码的时候也要避免需要连续地址空间的大对象的产生，如过长的字符串，用于存放附件、序列化或反序列化的 byte 数组等，还有就是过早晋升问题尽量在爆发问题前就避免掉。\n\n## 4.8 场景八：堆外内存 OOM\n\n**4.8.1 现象**\n\n内存使用率不断上升，甚至开始使用 SWAP 内存，同时可能出现 GC 时间飙升，线程被 Block 等现象，**通过 top 命令发现 Java 进程的 RES 甚至超过了** **-Xmx** **的大小**。出现这些现象时，基本可以确定是出现了堆外内存泄漏。\n\n**4.8.2 原因**\n\nJVM 的堆外内存泄漏，主要有两种的原因：\n\n- 通过 UnSafe#allocateMemory，ByteBuffer#allocateDirect 主动申请了堆外内存而没有释放，常见于 NIO、Netty 等相关组件。\n- 代码中有通过 JNI 调用 Native Code 申请的内存没有释放。\n\n**4.8.3 策略**\n\n哪种原因造成的堆外内存泄漏？\n\n首先，我们需要确定是哪种原因导致的堆外内存泄漏。这里可以使用 NMT（） 进行分析。在项目中添加 -XX:NativeMemoryTracking=detail JVM参数后重启项目（需要注意的是，打开 NMT 会带来 5%~10% 的性能损耗）。使用命令 jcmd pid VM.native_memory detail 查看内存分布。重点观察 total 中的 committed，因为 jcmd 命令显示的内存包含堆内内存、Code 区域、通过 Unsafe.allocateMemory 和 DirectByteBuffer 申请的内存，但是不包含其他 Native Code（C 代码）申请的堆外内存。\n\n如果 total 中的 committed 和 top 中的 RES 相差不大，则应为主动申请的堆外内存未释放造成的，如果相差较大，则基本可以确定是 JNI 调用造成的。\n\n**原因一：主动申请未释放**\n\nJVM 使用 -XX:MaxDirectMemorySize=size 参数来控制可申请的堆外内存的最大值。在 Java 8 中，如果未配置该参数，默认和 -Xmx 相等。\n\nNIO 和 Netty 都会取 -XX:MaxDirectMemorySize 配置的值，来限制申请的堆外内存的大小。NIO 和 Netty 中还有一个计数器字段，用来计算当前已申请的堆外内存大小，NIO 中是 java.nio.Bits#totalCapacity、Netty 中 io.netty.util.internal.PlatformDependent#DIRECT_MEMORY_COUNTER。\n\n当申请堆外内存时，NIO 和 Netty 会比较计数器字段和最大值的大小，如果计数器的值超过了最大值的限制，会抛出 OOM 的异常。\n\nNIO 中是：OutOfMemoryError: Direct buffer memory。\n\nNetty 中是：OutOfDirectMemoryError: failed to allocate capacity byte(s) of direct memory (used: usedMemory , max: DIRECT_MEMORY_LIMIT )。\n\n我们可以检查代码中是如何使用堆外内存的，NIO 或者是 Netty，通过反射，获取到对应组件中的计数器字段，并在项目中对该字段的数值进行打点，即可准确地监控到这部分堆外内存的使用情况。\n\n此时，可以通过 Debug 的方式确定使用堆外内存的地方是否正确执行了释放内存的代码。另外，需要检查 JVM 的参数是否有 -XX:+DisableExplicitGC 选项，如果有就去掉，因为该参数会使 System.gc 失效。（场景二：显式 GC 的去与留）\n\n**原因二：通过 JNI 调用的 Native Code 申请的内存未释放**\n\n这种情况排查起来比较困难，我们可以通过 Google perftools + Btrace 等工具，帮助我们分析出问题的代码在哪里。\n\ngperftools 是 Google 开发的一款非常实用的工具集，它的原理是在 Java 应用程序运行时，当调用 malloc 时换用它的 libtcmalloc.so，这样就能对内存分配情况做一些统计。我们使用 gperftools 来追踪分配内存的命令。如下图所示，通过 gperftools 发现 Java_java_util_zip_Inflater_init 比较可疑。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-3fb139cff7ad872397792d4d598b1f63_1440w.png)\n\n接下来可以使用 Btrace，尝试定位具体的调用栈。Btrace 是 Sun 推出的一款 Java 追踪、监控工具，可以在不停机的情况下对线上的 Java 程序进行监控。如下图所示，通过 Btrace 定位出项目中的 ZipHelper 在频繁调用 GZIPInputStream ，在堆外内存分配对象。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-5becf452ba0b7c23ae20712647f629df_1440w.png)\n\n最终定位到是，项目中对 GIPInputStream 的使用错误，没有正确的 close()。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-f1b3690844164ac3cd1f6a4a6cbcdf00_1440w.png)\n\n除了项目本身的原因，还可能有外部依赖导致的泄漏，如 Netty 和 Spring Boot，详细情况可以学习下这两篇文章：《》、《》。\n\n**4.8.4 小结**\n\n首先可以使用 NMT + jcmd 分析泄漏的堆外内存是哪里申请，确定原因后，使用不同的手段，进行原因定位。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-cacb2478ec2ca17cbf30a38582f14568_1440w.png)\n\n## 4.9 场景九：JNI 引发的 GC 问题\n\n**4.9.1 现象**\n\n在 GC 日志中，出现 GC Cause 为 GCLocker Initiated GC。\n\n```log\n2020-09-23T16:49:09.727+0800: 504426.742: [GC (GCLocker Initiated GC) 504426.742: [ParNew (promotion failed): 209716K->6042K(1887488K), 0.0843330 secs] 1449487K->1347626K(3984640K), 0.0848963 secs] [Times: user=0.19 sys=0.00, real=0.09 secs]\n2020-09-23T16:49:09.812+0800: 504426.827: [Full GC (GCLocker Initiated GC) 504426.827: [CMS: 1341583K->419699K(2097152K), 1.8482275 secs] 1347626K->419699K(3984640K), [Metaspace: 297780K->297780K(1329152K)], 1.8490564 secs] [Times: user=1.62 sys=0.20, real=1.85 secs]\n```\n\n**4.9.2 原因**\n\nJNI（Java Native Interface）意为 Java 本地调用，它允许 Java 代码和其他语言写的 Native 代码进行交互。\n\nJNI 如果需要获取 JVM 中的 String 或者数组，有两种方式：\n\n- 拷贝传递。\n- 共享引用（指针），性能更高。\n\n由于 Native 代码直接使用了 JVM 堆区的指针，如果这时发生 GC，就会导致数据错误。因此，在发生此类 JNI 调用时，禁止 GC 的发生，同时阻止其他线程进入 JNI 临界区，直到最后一个线程退出临界区时触发一次 GC。\n\nGC Locker 实验：\n\n```cpp\npublic class GCLockerTest {\n\n  static final int ITERS = 100;\n  static final int ARR_SIZE =  10000;\n  static final int WINDOW = 10000000;\n\n  static native void acquire(int[] arr);\n  static native void release(int[] arr);\n\n  static final Object[] window = new Object[WINDOW];\n\n  public static void main(String... args) throws Throwable {\n    System.loadLibrary(\"GCLockerTest\");\n    int[] arr = new int[ARR_SIZE];\n\n    for (int i = 0; i < ITERS; i++) {\n      acquire(arr);\n      System.out.println(\"Acquired\");\n      try {\n        for (int c = 0; c < WINDOW; c++) {\n          window[c] = new Object();\n        }\n      } catch (Throwable t) {\n        // omit\n      } finally {\n        System.out.println(\"Releasing\");\n        release(arr);\n      }\n    }\n  }\n}\n```\n\n```cpp\n#include <jni.h>\n#include \"GCLockerTest.h\"\n\nstatic jbyte* sink;\n\nJNIEXPORT void JNICALL Java_GCLockerTest_acquire(JNIEnv* env, jclass klass, jintArray arr) {\nsink = (*env)->GetPrimitiveArrayCritical(env, arr, 0);\n}\n\nJNIEXPORT void JNICALL Java_GCLockerTest_release(JNIEnv* env, jclass klass, jintArray arr) {\n(*env)->ReleasePrimitiveArrayCritical(env, arr, sink, 0);\n}\n```\n\n运行该 JNI 程序，可以看到发生的 GC 都是 GCLocker Initiated GC，并且注意在 “Acquired” 和 “Released” 时不可能发生 GC。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-e188cc9d9b0773fdf081225bf35cceed_1440w.png)\n\nGC Locker 可能导致的不良后果有：\n\n- 如果此时是 Young 区不够 Allocation Failure 导致的 GC，由于无法进行 Young GC，会将对象直接分配至 Old 区。\n- 如果 Old 区也没有空间了，则会等待锁释放，导致线程阻塞。\n- 可能触发额外不必要的 Young GC，JDK 有一个 Bug，有一定的几率，本来只该触发一次 GCLocker Initiated GC 的 Young GC，实际发生了一次 Allocation Failure GC 又紧接着一次 GCLocker Initiated GC。是因为 GCLocker Initiated GC 的属性被设为 full，导致两次 GC 不能收敛。\n\n**4.9.3 策略**\n\n- 添加 -XX+PrintJNIGCStalls 参数，可以打印出发生 JNI 调用时的线程，进一步分析，找到引发问题的 JNI 调用。\n- JNI 调用需要谨慎，不一定可以提升性能，反而可能造成 GC 问题。\n- 升级 JDK 版本到 14，避免导致的重复 GC。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-7248fbaf7dceb99e7803e6e907d18ae5_1440w.png)\n\n**4.9.4 小结**\n\nJNI 产生的 GC 问题较难排查，需要谨慎使用。\n\n# 5. 总结\n\n在这里，我们把整个文章内容总结一下，方便大家整体地理解回顾。\n\n## 5.1 处理流程（SOP）\n\n下图为整体 GC 问题普适的处理流程，重点的地方下面会单独标注，其他的基本都是标准处理流程，此处不再赘述，最后在整个问题都处理完之后有条件的话建议做一下复盘。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-d5dce299d725fea10f4ae7e6d56f9498_1440w.png)\n\n- **制定标准：**这块内容其实非常重要，但大部分系统都是缺失的，笔者过往面试的同学中只有不到一成的同学能给出自己的系统 GC 标准到底什么样，其他的都是用的统一指标模板，缺少预见性，具体指标制定可以参考 3.1 中的内容，需要结合应用系统的 TP9999 时间和延迟、吞吐量等设定具体的指标，而不是被问题驱动。\n- **保留现场：**目前线上服务基本都是分布式服务，某个节点发生问题后，如果条件允许一定不要直接操作重启、回滚等动作恢复，优先通过摘掉流量的方式来恢复，这样我们可以将堆、栈、GC 日志等关键信息保留下来，不然错过了定位根因的时机，后续解决难度将大大增加。当然除了这些，应用日志、中间件日志、内核日志、各种 Metrics 指标等对问题分析也有很大帮助。\n- **因果分析：**判断 GC 异常与其他系统指标异常的因果关系，可以参考笔者在 3.2 中介绍的时序分析、概率分析、实验分析、反证分析等 4 种因果分析法，避免在排查过程中走入误区。\n- **根因分析：**确实是 GC 的问题后，可以借助上文提到的工具并通过 5 Why 根因分析法以及跟第三节中的九种常见的场景进行逐一匹配，或者直接参考下文的根因鱼骨图，找出问题发生根因，最后再选择优化手段。\n\n## 5.2 根因鱼骨图\n\n送上一张问题根因鱼骨图，一般情况下我们在处理一个 GC 问题时，只要能定位到问题的“病灶”，有的放矢，其实就相当于解决了 80%，如果在某些场景下不太好定位，大家可以借助这种根因分析图通过**排除法**去定位。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-45516be9a66e2a15ffa8f3d1be1db5c6_1440w.png)\n\n## 5.3 调优建议\n\n- **Trade Off：**与 CAP 注定要缺一角一样，GC 优化要在延迟（Latency）、吞吐量（Throughput）、容量（Capacity）三者之间进行权衡。\n- **最终手段：**GC 发生问题不是一定要对 JVM 的 GC 参数进行调优，大部分情况下是通过 GC 的情况找出一些业务问题，切记上来就对 GC 参数进行调整，当然有明确配置错误的场景除外。\n- **控制变量：**控制变量法是在蒙特卡洛（Monte Carlo）方法中用于减少方差的一种技术方法，我们调优的时候尽量也要使用，每次调优过程尽可能只调整一个变量。\n- **善用搜索：**理论上 99.99% 的 GC 问题基本都被遇到了，我们要学会使用搜索引擎的高级技巧，重点关注 StackOverFlow、Github 上的 Issue、以及各种论坛博客，先看看其他人是怎么解决的，会让解决问题事半功倍。能看到这篇文章，你的搜索能力基本过关了~\n- **调优重点：**总体上来讲，我们开发的过程中遇到的问题类型也基本都符合正态分布，太简单或太复杂的基本遇到的概率很低，笔者这里将中间最重要的三个场景添加了“*”标识，希望阅读完本文之后可以观察下自己负责的系统，是否存在上述问题。\n- **GC 参数：**如果堆、栈确实无法第一时间保留，一定要保留 GC 日志，这样我们最起码可以看到 GC Cause，有一个大概的排查方向。关于 GC 日志相关参数，最基本的 -XX:+HeapDumpOnOutOfMemoryError 等一些参数就不再提了，笔者建议添加以下参数，可以提高我们分析问题的效率。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-1f760f2fac0548b6dd872614fb506dc1_1440w.png)\n\n- **其他建议：**上文场景中没有提到，但是对 GC 性能也有提升的一些建议。\n- **主动式 GC：**也有另开生面的做法，通过监控手段监控观测 Old 区的使用情况，即将到达阈值时将应用服务摘掉流量，手动触发一次 Major GC，减少 CMS GC 带来的停顿，但随之系统的健壮性也会减少，如非必要不建议引入。\n- **禁用偏向锁：**偏向锁在只有一个线程使用到该锁的时候效率很高，但是在竞争激烈情况会升级成轻量级锁，此时就需要先**消除偏向锁，这个过程是 STW**的。如果每个同步资源都走这个升级过程，开销会非常大，所以在已知并发激烈的前提下，一般会禁用偏向锁 -XX:-UseBiasedLocking 来提高性能。\n- **虚拟内存：**启动初期有些操作系统（例如 Linux）并没有真正分配物理内存给 JVM ，而是在虚拟内存中分配，使用的时候才会在物理内存中分配内存页，这样也会导致 GC 时间较长。这种情况可以添加 -XX:+AlwaysPreTouch 参数，让 VM 在 commit 内存时跑个循环来强制保证申请的内存真的 commit，避免运行时触发缺页异常。在一些大内存的场景下，有时候能将前几次的 GC 时间降一个数量级，但是添加这个参数后，启动的过程可能会变慢。\n\n# 6. 写在最后\n\n最后，再说笔者个人的一些小建议，遇到一些 GC 问题，如果有精力，一定要探本穷源，找出最深层次的原因。另外，在这个信息泛滥的时代，有一些被“奉为圭臬”的经验可能都是错误的，尽量养成看源码的习惯，有一句话说到“源码面前，了无秘密”，也就意味着遇到搞不懂的问题，我们可以从源码中一窥究竟，某些场景下确有奇效。但也不是只靠读源码来学习，如果硬啃源码但不理会其背后可能蕴含的理论基础，那很容易“捡芝麻丢西瓜”，“只见树木，不见森林”，让“了无秘密”变成了一句空话，我们还是要结合一些实际的业务场景去针对性地学习。\n\n**你的时间在哪里，你的成就就会在哪里**。笔者也是在前两年才开始逐步地在 GC 方向上不断深入，查问题、看源码、做总结，每个 Case 形成一个小的闭环，目前初步摸到了 GC 问题处理的一些门道，同时将经验总结应用于生产环境实践，慢慢地形成一个良性循环。\n\n本篇文章主要是介绍了 CMS GC 的一些常见场景分析，另外一些，如 CodeCache 问题导致 JIT 失效、SafePoint 就绪时间长、Card Table 扫描耗时等问题不太常见就没有花太多篇幅去讲解。Java GC 是在“分代”的思想下内卷了很多年才突破到了“分区”，目前在美团也已经开始使用 G1 来替换使用了多年的 CMS，虽然在小的堆方面 G1 还略逊色于 CMS，但这是一个趋势，短时间无法升级到 ZGC，所以未来遇到的 G1 的问题可能会逐渐增多。目前已经收集到 Remember Set 粗化、Humongous 分配、Ergonomics 异常、Mixed GC 中 Evacuation Failure 等问题，除此之外也会给出 CMS 升级到 G1 的一些建议，接下来笔者将继续完成这部分文章整理，敬请期待。\n\n“防火”永远要胜于“救火”，**不放过任何一个异常的小指标**（一般来说，任何**不平滑的曲线**都是值得怀疑的） ，就有可能避免一次故障的发生。作为 Java 程序员基本都会遇到一些 GC 的问题，独立解决 GC 问题是我们必须迈过的一道坎。开篇中也提到过 GC 作为经典的技术，非常值得我们学习，一些 GC 的学习材料，如《The Garbage Collection Handbook》、《深入理解Java虚拟机》等也是常读常新，赶紧动起来，苦练 GC 基本功吧。\n\n最后的最后，再多啰嗦一句，目前所有 GC 调优相关的文章，第一句讲的就是“不要过早优化”，使得很多同学对 GC 优化望而却步。在这里笔者提出不一样的观点，熵增定律（在一个孤立系统里，如果没有外力做功，其总混乱度（即熵）会不断增大）在计算机系统同样适用，**如果不主动做功使熵减，系统终究会脱离你的掌控**，在我们对业务系统和 GC 原理掌握得足够深的时候，可以放心大胆地做优化，因为我们基本可以预测到每一个操作的结果，放手一搏吧，少年！', '![Java中9种常见的CMS GC问题分析与解决（上）](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-60d737e7e61afcf601d9e2d4506c92f9_1440w.png)', b'1', b'1', b'0', b'0', '2024-12-24 14:42:51', '2024-12-24 14:42:51', 0, 23655, 118, 10, b'0', '', 1);
INSERT INTO `blog` VALUES (13, 'Java中9种常见的CMS GC问题分析与解决（下）', 'https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-4053612fa65cc0e94680cb8038dc68f2_1440w.png', '目前，互联网上 Java 的 GC 资料要么是主要讲解理论，要么就是针对单一场景的 GC 问题进行了剖析，对整个体系总结的资料少之又少。前车之鉴，后事之师，美团的几位工程师历时一年多的时间，搜集了内部各种 GC 问题的分析文章，并结合个人的理解做了一些总结，希望能起到“抛砖引玉”的作用。\n\n## 1. 写在前面\n\n**|**本文主要针对 Hotspot VM 中“CMS + ParNew”组合的一些使用场景进行总结。重点通过部分源码对根因进行分析以及对排查方法进行总结，排查过程会省略较多。另外，本文专业术语较多，有一定的阅读门槛，如未介绍清楚，还请自行查阅相关材料。\n\n**|**本文总字数 2 万左右（不包含代码片段），整体阅读时间约 30min ，文章较长，可以选择你感兴趣的场景进行研究。\n\n本篇系第二部分。\n\n**4.6 场景六：单次 CMS Old GC 耗时长**\n\n**4.6.1 现象**\n\nCMS GC 单次 STW 最大超过 1000ms，不会频繁发生，如下图所示最长达到了 8000ms。某些场景下会引起“雪崩效应”，这种场景非常危险，我们应该尽量避免出现。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-4053612fa65cc0e94680cb8038dc68f2_1440w.png)\n\n**4.6.2 原因**\n\nCMS 在回收的过程中，STW 的阶段主要是 Init Mark 和 Final Remark 这两个阶段，也是导致 CMS Old GC 最多的原因，另外有些情况就是在 STW 前等待 Mutator 的线程到达 SafePoint 也会导致时间过长，但这种情况较少，我们在此处主要讨论前者。发生收集器退化或者碎片压缩的场景请看场景七。\n\n想要知道这两个阶段为什么会耗时，我们需要先看一下这两个阶段都会干什么。\n\n核心代码都在 /src/hotspot/share/gc/cms/concurrentMarkSweepGeneration.cpp 中，内部有个线程 ConcurrentMarkSweepThread 轮询来校验，Old 区的垃圾回收相关细节被完全封装在 CMSCollector 中，调用入口就是 ConcurrentMarkSweepThread 调用的 CMSCollector::collect_in_background 和 ConcurrentMarkSweepGeneration 调用的 CMSCollector::collect 方法，此处我们讨论大多数场景的 collect_in_background。整个过程中会 STW 的主要是 initial Mark 和 Final Remark，核心代码在 VM_CMS_Initial_Mark / VM_CMS_Final_Remark 中，执行时需要将执行权交由 VMThread 来执行。\n\n- CMS Init Mark执行步骤，实现在 CMSCollector::checkpointRootsInitialWork() 和 CMSParInitialMarkTask::work 中，整体步骤和代码如下：\n\nCMSCollector::checkpointRootsInitialWork()\n\n```cpp\nvoid CMSCollector::checkpointRootsInitialWork() {\n  assert(SafepointSynchronize::is_at_safepoint(), \"world should be stopped\");\n  assert(_collectorState == InitialMarking, \"just checking\");\n\n  // Already have locks.\n  assert_lock_strong(bitMapLock());\n  assert(_markBitMap.isAllClear(), \"was reset at end of previous cycle\");\n\n  // Setup the verification and class unloading state for this\n  // CMS collection cycle.\n  setup_cms_unloading_and_verification_state();\n\n  GCTraceTime(Trace, gc, phases) ts(\"checkpointRootsInitialWork\", _gc_timer_cm);\n\n  // Reset all the PLAB chunk arrays if necessary.\n  if (_survivor_plab_array != NULL && !CMSPLABRecordAlways) {\n    reset_survivor_plab_arrays();\n  }\n\n  ResourceMark rm;\n  HandleMark  hm;\n\n  MarkRefsIntoClosure notOlder(_span, &_markBitMap);\n  CMSHeap* heap = CMSHeap::heap();\n\n  verify_work_stacks_empty();\n  verify_overflow_empty();\n\n  heap->ensure_parsability(false);  // fill TLABs, but no need to retire them\n  // Update the saved marks which may affect the root scans.\n  heap->save_marks();\n\n  // weak reference processing has not started yet.\n  ref_processor()->set_enqueuing_is_done(false);\n\n  // Need to remember all newly created CLDs,\n  // so that we can guarantee that the remark finds them.\n  ClassLoaderDataGraph::remember_new_clds(true);\n\n  // Whenever a CLD is found, it will be claimed before proceeding to mark\n  // the klasses. The claimed marks need to be cleared before marking starts.\n  ClassLoaderDataGraph::clear_claimed_marks();\n\n  print_eden_and_survivor_chunk_arrays();\n\n  {\n    if (CMSParallelInitialMarkEnabled) {\n      // The parallel version.\n      WorkGang* workers = heap->workers();\n      assert(workers != NULL, \"Need parallel worker threads.\");\n      uint n_workers = workers->active_workers();\n\n      StrongRootsScope srs(n_workers);\n\n      CMSParInitialMarkTask tsk(this, &srs, n_workers);\n      initialize_sequential_subtasks_for_young_gen_rescan(n_workers);\n      // If the total workers is greater than 1, then multiple workers\n      // may be used at some time and the initialization has been set\n      // such that the single threaded path cannot be used.\n      if (workers->total_workers() > 1) {\n        workers->run_task(&tsk);\n      } else {\n        tsk.work(0);\n      }\n    } else {\n      // The serial version.\n      CLDToOopClosure cld_closure(&notOlder, true);\n      heap->rem_set()->prepare_for_younger_refs_iterate(false); // Not parallel.\n\n      StrongRootsScope srs(1);\n\n      heap->cms_process_roots(&srs,\n                             true,   // young gen as roots\n                             GenCollectedHeap::ScanningOption(roots_scanning_options()),\n                             should_unload_classes(),\n                             &notOlder,\n                             &cld_closure);\n    }\n  }\n\n  // Clear mod-union table; it will be dirtied in the prologue of\n  // CMS generation per each young generation collection.\n  assert(_modUnionTable.isAllClear(),\n       \"Was cleared in most recent final checkpoint phase\"\n       \" or no bits are set in the gc_prologue before the start of the next \"\n       \"subsequent marking phase.\");\n\n  assert(_ct->cld_rem_set()->mod_union_is_clear(), \"Must be\");\n  // Save the end of the used_region of the constituent generations\n  // to be used to limit the extent of sweep in each generation.\n  save_sweep_limits();\n  verify_overflow_empty();\n}\n```\n\nCMSParInitialMarkTask::work\n\n```cpp\nvoid CMSParInitialMarkTask::work(uint worker_id) {\n  elapsedTimer _timer;\n  ResourceMark rm;\n  HandleMark   hm;\n\n  // ---------- scan from roots --------------\n  _timer.start();\n  CMSHeap* heap = CMSHeap::heap();\n  ParMarkRefsIntoClosure par_mri_cl(_collector->_span, &(_collector->_markBitMap));\n\n  // ---------- young gen roots --------------\n  {\n    work_on_young_gen_roots(&par_mri_cl);\n    _timer.stop();\n    log_trace(gc, task)(\"Finished young gen initial mark scan work in %dth thread: %3.3f sec\", worker_id, _timer.seconds());\n  }\n\n  // ---------- remaining roots --------------\n  _timer.reset();\n  _timer.start();\n\n  CLDToOopClosure cld_closure(&par_mri_cl, true);\n\n  heap->cms_process_roots(_strong_roots_scope,\n                          false,     // yg was scanned above\n                          GenCollectedHeap::ScanningOption(_collector->CMSCollector::roots_scanning_options()),\n                          _collector->should_unload_classes(),\n                          &par_mri_cl,\n                          &cld_closure,\n                          &_par_state_string);\n\n  assert(_collector->should_unload_classes()\n         || (_collector->CMSCollector::roots_scanning_options() & GenCollectedHeap::SO_AllCodeCache),\n         \"if we didn\'t scan the code cache, we have to be ready to drop nmethods with expired weak oops\");\n  _timer.stop();\n  log_trace(gc, task)(\"Finished remaining root initial mark scan work in %dth thread: %3.3f sec\", worker_id, _timer.seconds());\n}\n```\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-f80b3b01033524e8f96fa27fd11d6771_1440w.png)\n\n整个过程比较简单，从 GC Root 出发标记 Old 中的对象，处理完成后借助 BitMap 处理下 Young 区对 Old 区的引用，整个过程基本都比较快，很少会有较大的停顿。\n\n- CMS Final Remark 执行步骤，实现在 CMSCollector::checkpointRootsFinalWork() 中，整体代码和步骤如下：\n\nCMSCollector::checkpointRootsFinalWork()\n\n```cpp\nvoid CMSCollector::checkpointRootsFinalWork() {\n  GCTraceTime(Trace, gc, phases) tm(\"checkpointRootsFinalWork\", _gc_timer_cm);\n\n  assert(haveFreelistLocks(), \"must have free list locks\");\n  assert_lock_strong(bitMapLock());\n\n  ResourceMark rm;\n  HandleMark   hm;\n\n  CMSHeap* heap = CMSHeap::heap();\n\n  if (should_unload_classes()) {\n    CodeCache::gc_prologue();\n  }\n  assert(haveFreelistLocks(), \"must have free list locks\");\n  assert_lock_strong(bitMapLock());\n\n  heap->ensure_parsability(false);  // fill TLAB\'s, but no need to retire them\n  // Update the saved marks which may affect the root scans.\n  heap->save_marks();\n\n  print_eden_and_survivor_chunk_arrays();\n\n  {\n    if (CMSParallelRemarkEnabled) {\n      GCTraceTime(Debug, gc, phases) t(\"Rescan (parallel)\", _gc_timer_cm);\n      do_remark_parallel();\n    } else {\n      GCTraceTime(Debug, gc, phases) t(\"Rescan (non-parallel)\", _gc_timer_cm);\n      do_remark_non_parallel();\n    }\n  }\n  verify_work_stacks_empty();\n  verify_overflow_empty();\n\n  {\n    GCTraceTime(Trace, gc, phases) ts(\"refProcessingWork\", _gc_timer_cm);\n    refProcessingWork();\n  }\n  verify_work_stacks_empty();\n  verify_overflow_empty();\n\n  if (should_unload_classes()) {\n    CodeCache::gc_epilogue();\n  }\n  JvmtiExport::gc_epilogue();\n  assert(_markStack.isEmpty(), \"No grey objects\");\n  size_t ser_ovflw = _ser_pmc_remark_ovflw + _ser_pmc_preclean_ovflw +\n                     _ser_kac_ovflw        + _ser_kac_preclean_ovflw;\n  if (ser_ovflw > 0) {\n    log_trace(gc)(\"Marking stack overflow (benign) (pmc_pc=\" SIZE_FORMAT \", pmc_rm=\" SIZE_FORMAT \", kac=\" SIZE_FORMAT \", kac_preclean=\" SIZE_FORMAT \")\",\n                         _ser_pmc_preclean_ovflw, _ser_pmc_remark_ovflw, _ser_kac_ovflw, _ser_kac_preclean_ovflw);\n    _markStack.expand();\n    _ser_pmc_remark_ovflw = 0;\n    _ser_pmc_preclean_ovflw = 0;\n    _ser_kac_preclean_ovflw = 0;\n    _ser_kac_ovflw = 0;\n  }\n  if (_par_pmc_remark_ovflw > 0 || _par_kac_ovflw > 0) {\n     log_trace(gc)(\"Work queue overflow (benign) (pmc_rm=\" SIZE_FORMAT \", kac=\" SIZE_FORMAT \")\",\n                          _par_pmc_remark_ovflw, _par_kac_ovflw);\n     _par_pmc_remark_ovflw = 0;\n    _par_kac_ovflw = 0;\n  }\n   if (_markStack._hit_limit > 0) {\n     log_trace(gc)(\" (benign) Hit max stack size limit (\" SIZE_FORMAT \")\",\n                          _markStack._hit_limit);\n   }\n   if (_markStack._failed_double > 0) {\n     log_trace(gc)(\" (benign) Failed stack doubling (\" SIZE_FORMAT \"), current capacity \" SIZE_FORMAT,\n                          _markStack._failed_double, _markStack.capacity());\n   }\n  _markStack._hit_limit = 0;\n  _markStack._failed_double = 0;\n\n  if ((VerifyAfterGC || VerifyDuringGC) &&\n      CMSHeap::heap()->total_collections() >= VerifyGCStartAt) {\n    verify_after_remark();\n  }\n\n  _gc_tracer_cm->report_object_count_after_gc(&_is_alive_closure);\n\n  // Change under the freelistLocks.\n  _collectorState = Sweeping;\n  // Call isAllClear() under bitMapLock\n  assert(_modUnionTable.isAllClear(),\n      \"Should be clear by end of the final marking\");\n  assert(_ct->cld_rem_set()->mod_union_is_clear(),\n      \"Should be clear by end of the final marking\");\n}\n```\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-a864edd6b8d3b079634b745633bff104_1440w.png)\n\nFinal Remark 是最终的第二次标记，这种情况只有在 Background GC 执行了 InitialMarking 步骤的情形下才会执行，如果是 Foreground GC 执行的 InitialMarking 步骤则不需要再次执行 FinalRemark。Final Remark 的开始阶段与 Init Mark 处理的流程相同，但是后续多了 Card Table 遍历、Reference 实例的清理并将其加入到 Reference 维护的 pend_list 中，如果要收集元数据信息，还要清理 SystemDictionary、CodeCache、SymbolTable、StringTable 等组件中不再使用的资源。\n\n**4.6.3 策略**\n\n知道了两个 STW 过程执行流程，我们分析解决就比较简单了，由于大部分问题都出在 Final Remark 过程，这里我们也拿这个场景来举例，主要步骤：\n\n- **【方向】**观察详细 GC 日志，找到出问题时 Final Remark 日志，分析下 Reference 处理和元数据处理 real 耗时是否正常，详细信息需要通过 -XX:+PrintReferenceGC 参数开启。**基本在日志里面就能定位到大概是哪个方向出了问题，耗时超过 10% 的就需要关注**。\n\n```log\n2019-02-27T19:55:37.920+0800: 516952.915: [GC (CMS Final Remark) 516952.915: [ParNew516952.939: [SoftReference, 0 refs, 0.0003857 secs]516952.939: [WeakReference, 1362 refs, 0.0002415 secs]516952.940: [FinalReference, 146 refs, 0.0001233 secs]516952.940: [PhantomReference, 0 refs, 57 refs, 0.0002369 secs]516952.940: [JNI Weak Reference, 0.0000662 secs]\n[class unloading, 0.1770490 secs]516953.329: [scrub symbol table, 0.0442567 secs]516953.373: [scrub string table, 0.0036072 secs][1 CMS-remark: 1638504K(2048000K)] 1667558K(4352000K), 0.5269311 secs] [Times: user=1.20 sys=0.03, real=0.53 secs]\n```\n\n- **【根因】**有了具体的方向我们就可以进行深入的分析，一般来说最容易出问题的地方就是 Reference 中的 FinalReference 和元数据信息处理中的 scrub symbol table 两个阶段，想要找到具体问题代码就需要内存分析工具 MAT 或 JProfiler 了，注意要 dump 即将开始 CMS GC 的堆。在用 MAT 等工具前也可以先用命令行看下对象 Histogram，有可能直接就能定位问题。\n- 对 FinalReference 的分析主要观察 java.lang.ref.Finalizer 对象的 dominator tree，找到泄漏的来源。经常会出现问题的几个点有 Socket 的 SocksSocketImpl 、Jersey 的 ClientRuntime、MySQL 的 ConnectionImpl 等等。\n- scrub symbol table 表示清理元数据符号引用耗时，符号引用是 Java 代码被编译成字节码时，方法在 JVM 中的表现形式，生命周期一般与 Class 一致，当 _should_unload_classes 被设置为 true 时在 CMSCollector::refProcessingWork() 中与 Class Unload、String Table 一起被处理。\n\nCMSCollector::refProcessingWork()\n\n```cpp\nif (should_unload_classes()) {\n    {\n      GCTraceTime(Debug, gc, phases) t(\"Class Unloading\", _gc_timer_cm);\n\n      // Unload classes and purge the SystemDictionary.\n      bool purged_class = SystemDictionary::do_unloading(_gc_timer_cm);\n\n      // Unload nmethods.\n      CodeCache::do_unloading(&_is_alive_closure, purged_class);\n\n      // Prune dead klasses from subklass/sibling/implementor lists.\n      Klass::clean_weak_klass_links(purged_class);\n    }\n\n    {\n      GCTraceTime(Debug, gc, phases) t(\"Scrub Symbol Table\", _gc_timer_cm);\n      // Clean up unreferenced symbols in symbol table.\n      SymbolTable::unlink();\n    }\n\n    {\n      GCTraceTime(Debug, gc, phases) t(\"Scrub String Table\", _gc_timer_cm);\n      // Delete entries for dead interned strings.\n      StringTable::unlink(&_is_alive_closure);\n    }\n  }\n```\n\n- **【策略】**知道 GC 耗时的根因就比较好处理了，这种问题不会大面积同时爆发，不过有很多时候单台 STW 的时间会比较长，如果业务影响比较大，及时摘掉流量，具体后续优化策略如下：\n- FinalReference：找到内存来源后通过优化代码的方式来解决，如果短时间无法定位可以增加 -XX:+ParallelRefProcEnabled 对 Reference 进行并行处理。\n- symbol table：观察 MetaSpace 区的历史使用峰值，以及每次 GC 前后的回收情况，一般没有使用动态类加载或者 DSL 处理等，MetaSpace 的使用率上不会有什么变化，这种情况可以通过 -XX:-CMSClassUnloadingEnabled 来避免 MetaSpace 的处理，JDK8 会默认开启 CMSClassUnloadingEnabled，这会使得 CMS 在 CMS-Remark 阶段尝试进行类的卸载。\n\n**4.6.4 小结**\n\n正常情况进行的 Background CMS GC，出现问题基本都集中在 Reference 和 Class 等元数据处理上，在 Reference 类的问题处理方面，不管是 FinalReference，还是 SoftReference、WeakReference 核心的手段就是找准时机 dump 快照，然后用内存分析工具来分析。Class 处理方面目前除了关闭类卸载开关，没有太好的方法。\n\n在 G1 中同样有 Reference 的问题，可以观察日志中的 Ref Proc，处理方法与 CMS 类似。\n\n**4.7 场景七：内存碎片&收集器退化**\n\n**4.7.1 现象**\n\n并发的 CMS GC 算法，退化为 Foreground 单线程串行 GC 模式，STW 时间超长，有时会长达十几秒。其中 CMS 收集器退化后单线程串行 GC 算法有两种：\n\n- 带压缩动作的算法，称为 MSC，上面我们介绍过，使用标记-清理-压缩，单线程全暂停的方式，对整个堆进行垃圾收集，也就是真正意义上的 Full GC，暂停时间要长于普通 CMS。\n- 不带压缩动作的算法，收集 Old 区，和普通的 CMS 算法比较相似，暂停时间相对 MSC 算法短一些。\n\n**4.7.2 原因**\n\nCMS 发生收集器退化主要有以下几种情况。\n\n**晋升失败（Promotion Failed）**\n\n顾名思义，晋升失败就是指在进行 Young GC 时，Survivor 放不下，对象只能放入 Old，但此时 Old 也放不下。直觉上乍一看这种情况可能会经常发生，但其实因为有 concurrentMarkSweepThread 和担保机制的存在，发生的条件是很苛刻的，除非是短时间将 Old 区的剩余空间迅速填满，例如上文中说的动态年龄判断导致的过早晋升（见下文的增量收集担保失败）。另外还有一种情况就是内存碎片导致的 Promotion Failed，Young GC 以为 Old 有足够的空间，结果到分配时，晋级的大对象找不到连续的空间存放。\n\n使用 CMS 作为 GC 收集器时，运行过一段时间的 Old 区如下图所示，清除算法导致内存出现多段的不连续，出现大量的内存碎片。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-8f4de3e5ea0b2bd0658969a24462db41_1440w.png)\n\n碎片带来了两个问题：\n\n- **空间分配效率较低**：上文已经提到过，如果是连续的空间 JVM 可以通过使用 pointer bumping 的方式来分配，而对于这种有大量碎片的空闲链表则需要逐个访问 freelist 中的项来访问，查找可以存放新建对象的地址。\n- **空间利用效率变低**：Young 区晋升的对象大小大于了连续空间的大小，那么将会触发 Promotion Failed ，即使整个 Old 区的容量是足够的，但由于其不连续，也无法存放新对象，也就是本文所说的问题。\n\n**增量收集担保失败**\n\n分配内存失败后，会判断统计得到的 Young GC 晋升到 Old 的平均大小，以及当前 Young 区已使用的大小也就是最大可能晋升的对象大小，是否大于 Old 区的剩余空间。只要 CMS 的剩余空间比前两者的任意一者大，CMS 就认为晋升还是安全的，反之，则代表不安全，不进行Young GC，直接触发Full GC。\n\n**显式 GC**\n\n这种情况参见场景二。\n\n**并发模式失败（Concurrent Mode Failure）**\n\n最后一种情况，也是发生概率较高的一种，在 GC 日志中经常能看到 Concurrent Mode Failure 关键字。这种是由于并发 Background CMS GC 正在执行，同时又有 Young GC 晋升的对象要放入到了 Old 区中，而此时 Old 区空间不足造成的。\n\n为什么 CMS GC 正在执行还会导致收集器退化呢？主要是由于 CMS 无法处理浮动垃圾（Floating Garbage）引起的。CMS 的并发清理阶段，Mutator 还在运行，因此不断有新的垃圾产生，而这些垃圾不在这次清理标记的范畴里，无法在本次 GC 被清除掉，这些就是浮动垃圾，除此之外在 Remark 之前那些断开引用脱离了读写屏障控制的对象也算浮动垃圾。所以 Old 区回收的阈值不能太高，否则预留的内存空间很可能不够，从而导致 Concurrent Mode Failure 发生。\n\n**4.7.3 策略**\n\n分析到具体原因后，我们就可以针对性解决了，具体思路还是从根因出发，具体解决策略：\n\n- **内存碎片：**通过配置 -XX:UseCMSCompactAtFullCollection=true 来控制 Full GC的过程中是否进行空间的整理（默认开启，注意是Full GC，不是普通CMS GC），以及 -XX: CMSFullGCsBeforeCompaction=n 来控制多少次 Full GC 后进行一次压缩。\n- **增量收集：**降低触发 CMS GC 的阈值，即参数 -XX:CMSInitiatingOccupancyFraction 的值，让 CMS GC 尽早执行，以保证有足够的连续空间，也减少 Old 区空间的使用大小，另外需要使用 -XX:+UseCMSInitiatingOccupancyOnly 来配合使用，不然 JVM 仅在第一次使用设定值，后续则自动调整。\n- **浮动垃圾：**视情况控制每次晋升对象的大小，或者缩短每次 CMS GC 的时间，必要时可调节 NewRatio 的值。另外就是使用 -XX:+CMSScavengeBeforeRemark 在过程中提前触发一次 Young GC，防止后续晋升过多对象。\n\n**4.7.4 小结**\n\n正常情况下触发并发模式的 CMS GC，停顿非常短，对业务影响很小，但 CMS GC 退化后，影响会非常大，建议发现一次后就彻底根治。只要能定位到内存碎片、浮动垃圾、增量收集相关等具体产生原因，还是比较好解决的，关于内存碎片这块，如果 -XX:CMSFullGCsBeforeCompaction 的值不好选取的话，可以使用 -XX:PrintFLSStatistics 来观察内存碎片率情况，然后再设置具体的值。\n\n最后就是在编码的时候也要避免需要连续地址空间的大对象的产生，如过长的字符串，用于存放附件、序列化或反序列化的 byte 数组等，还有就是过早晋升问题尽量在爆发问题前就避免掉。\n\n**4.8 场景八：堆外内存 OOM**\n\n**4.8.1 现象**\n\n内存使用率不断上升，甚至开始使用 SWAP 内存，同时可能出现 GC 时间飙升，线程被 Block 等现象，**通过 top 命令发现 Java 进程的 RES 甚至超过了** **-Xmx** **的大小**。出现这些现象时，基本可以确定是出现了堆外内存泄漏。\n\n**4.8.2 原因**\n\nJVM 的堆外内存泄漏，主要有两种的原因：\n\n- 通过 UnSafe#allocateMemory，ByteBuffer#allocateDirect 主动申请了堆外内存而没有释放，常见于 NIO、Netty 等相关组件。\n- 代码中有通过 JNI 调用 Native Code 申请的内存没有释放。\n\n**4.8.3 策略**\n\n哪种原因造成的堆外内存泄漏？\n\n首先，我们需要确定是哪种原因导致的堆外内存泄漏。这里可以使用 NMT（） 进行分析。在项目中添加 -XX:NativeMemoryTracking=detail JVM参数后重启项目（需要注意的是，打开 NMT 会带来 5%~10% 的性能损耗）。使用命令 jcmd pid VM.native_memory detail 查看内存分布。重点观察 total 中的 committed，因为 jcmd 命令显示的内存包含堆内内存、Code 区域、通过 Unsafe.allocateMemory 和 DirectByteBuffer 申请的内存，但是不包含其他 Native Code（C 代码）申请的堆外内存。\n\n如果 total 中的 committed 和 top 中的 RES 相差不大，则应为主动申请的堆外内存未释放造成的，如果相差较大，则基本可以确定是 JNI 调用造成的。\n\n**原因一：主动申请未释放**\n\nJVM 使用 -XX:MaxDirectMemorySize=size 参数来控制可申请的堆外内存的最大值。在 Java 8 中，如果未配置该参数，默认和 -Xmx 相等。\n\nNIO 和 Netty 都会取 -XX:MaxDirectMemorySize 配置的值，来限制申请的堆外内存的大小。NIO 和 Netty 中还有一个计数器字段，用来计算当前已申请的堆外内存大小，NIO 中是 java.nio.Bits#totalCapacity、Netty 中 io.netty.util.internal.PlatformDependent#DIRECT_MEMORY_COUNTER。\n\n当申请堆外内存时，NIO 和 Netty 会比较计数器字段和最大值的大小，如果计数器的值超过了最大值的限制，会抛出 OOM 的异常。\n\nNIO 中是：OutOfMemoryError: Direct buffer memory。\n\nNetty 中是：OutOfDirectMemoryError: failed to allocate capacity byte(s) of direct memory (used: usedMemory , max: DIRECT_MEMORY_LIMIT )。\n\n我们可以检查代码中是如何使用堆外内存的，NIO 或者是 Netty，通过反射，获取到对应组件中的计数器字段，并在项目中对该字段的数值进行打点，即可准确地监控到这部分堆外内存的使用情况。\n\n此时，可以通过 Debug 的方式确定使用堆外内存的地方是否正确执行了释放内存的代码。另外，需要检查 JVM 的参数是否有 -XX:+DisableExplicitGC 选项，如果有就去掉，因为该参数会使 System.gc 失效。（场景二：显式 GC 的去与留）\n\n**原因二：通过 JNI 调用的 Native Code 申请的内存未释放**\n\n这种情况排查起来比较困难，我们可以通过 Google perftools + Btrace 等工具，帮助我们分析出问题的代码在哪里。\n\ngperftools 是 Google 开发的一款非常实用的工具集，它的原理是在 Java 应用程序运行时，当调用 malloc 时换用它的 libtcmalloc.so，这样就能对内存分配情况做一些统计。我们使用 gperftools 来追踪分配内存的命令。如下图所示，通过 gperftools 发现 Java_java_util_zip_Inflater_init 比较可疑。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-3fb139cff7ad872397792d4d598b1f63_1440w.png)\n\n接下来可以使用 Btrace，尝试定位具体的调用栈。Btrace 是 Sun 推出的一款 Java 追踪、监控工具，可以在不停机的情况下对线上的 Java 程序进行监控。如下图所示，通过 Btrace 定位出项目中的 ZipHelper 在频繁调用 GZIPInputStream ，在堆外内存分配对象。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-5becf452ba0b7c23ae20712647f629df_1440w.png)\n\n最终定位到是，项目中对 GIPInputStream 的使用错误，没有正确的 close()。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-f1b3690844164ac3cd1f6a4a6cbcdf00_1440w.png)\n\n除了项目本身的原因，还可能有外部依赖导致的泄漏，如 Netty 和 Spring Boot，详细情况可以学习下这两篇文章：《》、《》。\n\n**4.8.4 小结**\n\n首先可以使用 NMT + jcmd 分析泄漏的堆外内存是哪里申请，确定原因后，使用不同的手段，进行原因定位。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-cacb2478ec2ca17cbf30a38582f14568_1440w.png)\n\n**4.9 场景九：JNI 引发的 GC 问题**\n\n**4.9.1 现象**\n\n在 GC 日志中，出现 GC Cause 为 GCLocker Initiated GC。\n\n```log\n2020-09-23T16:49:09.727+0800: 504426.742: [GC (GCLocker Initiated GC) 504426.742: [ParNew (promotion failed): 209716K->6042K(1887488K), 0.0843330 secs] 1449487K->1347626K(3984640K), 0.0848963 secs] [Times: user=0.19 sys=0.00, real=0.09 secs]\n2020-09-23T16:49:09.812+0800: 504426.827: [Full GC (GCLocker Initiated GC) 504426.827: [CMS: 1341583K->419699K(2097152K), 1.8482275 secs] 1347626K->419699K(3984640K), [Metaspace: 297780K->297780K(1329152K)], 1.8490564 secs] [Times: user=1.62 sys=0.20, real=1.85 secs]\n```\n\n**4.9.2 原因**\n\nJNI（Java Native Interface）意为 Java 本地调用，它允许 Java 代码和其他语言写的 Native 代码进行交互。\n\nJNI 如果需要获取 JVM 中的 String 或者数组，有两种方式：\n\n- 拷贝传递。\n- 共享引用（指针），性能更高。\n\n由于 Native 代码直接使用了 JVM 堆区的指针，如果这时发生 GC，就会导致数据错误。因此，在发生此类 JNI 调用时，禁止 GC 的发生，同时阻止其他线程进入 JNI 临界区，直到最后一个线程退出临界区时触发一次 GC。\n\nGC Locker 实验：\n\n```cpp\npublic class GCLockerTest {\n\n  static final int ITERS = 100;\n  static final int ARR_SIZE =  10000;\n  static final int WINDOW = 10000000;\n\n  static native void acquire(int[] arr);\n  static native void release(int[] arr);\n\n  static final Object[] window = new Object[WINDOW];\n\n  public static void main(String... args) throws Throwable {\n    System.loadLibrary(\"GCLockerTest\");\n    int[] arr = new int[ARR_SIZE];\n\n    for (int i = 0; i < ITERS; i++) {\n      acquire(arr);\n      System.out.println(\"Acquired\");\n      try {\n        for (int c = 0; c < WINDOW; c++) {\n          window[c] = new Object();\n        }\n      } catch (Throwable t) {\n        // omit\n      } finally {\n        System.out.println(\"Releasing\");\n        release(arr);\n      }\n    }\n  }\n}\n```\n\n```cpp\n#include <jni.h>\n#include \"GCLockerTest.h\"\n\nstatic jbyte* sink;\n\nJNIEXPORT void JNICALL Java_GCLockerTest_acquire(JNIEnv* env, jclass klass, jintArray arr) {\nsink = (*env)->GetPrimitiveArrayCritical(env, arr, 0);\n}\n\nJNIEXPORT void JNICALL Java_GCLockerTest_release(JNIEnv* env, jclass klass, jintArray arr) {\n(*env)->ReleasePrimitiveArrayCritical(env, arr, sink, 0);\n}\n```\n\n运行该 JNI 程序，可以看到发生的 GC 都是 GCLocker Initiated GC，并且注意在 “Acquired” 和 “Released” 时不可能发生 GC。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-e188cc9d9b0773fdf081225bf35cceed_1440w.png)\n\nGC Locker 可能导致的不良后果有：\n\n- 如果此时是 Young 区不够 Allocation Failure 导致的 GC，由于无法进行 Young GC，会将对象直接分配至 Old 区。\n- 如果 Old 区也没有空间了，则会等待锁释放，导致线程阻塞。\n- 可能触发额外不必要的 Young GC，JDK 有一个 Bug，有一定的几率，本来只该触发一次 GCLocker Initiated GC 的 Young GC，实际发生了一次 Allocation Failure GC 又紧接着一次 GCLocker Initiated GC。是因为 GCLocker Initiated GC 的属性被设为 full，导致两次 GC 不能收敛。\n\n**4.9.3 策略**\n\n- 添加 -XX+PrintJNIGCStalls 参数，可以打印出发生 JNI 调用时的线程，进一步分析，找到引发问题的 JNI 调用。\n- JNI 调用需要谨慎，不一定可以提升性能，反而可能造成 GC 问题。\n- 升级 JDK 版本到 14，避免导致的重复 GC。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-7248fbaf7dceb99e7803e6e907d18ae5_1440w.png)\n\n**4.9.4 小结**\n\nJNI 产生的 GC 问题较难排查，需要谨慎使用。\n\n## 5. 总结\n\n在这里，我们把整个文章内容总结一下，方便大家整体地理解回顾。\n\n**5.1 处理流程（SOP）**\n\n下图为整体 GC 问题普适的处理流程，重点的地方下面会单独标注，其他的基本都是标准处理流程，此处不再赘述，最后在整个问题都处理完之后有条件的话建议做一下复盘。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-d5dce299d725fea10f4ae7e6d56f9498_1440w.png)\n\n- **制定标准：**这块内容其实非常重要，但大部分系统都是缺失的，笔者过往面试的同学中只有不到一成的同学能给出自己的系统 GC 标准到底什么样，其他的都是用的统一指标模板，缺少预见性，具体指标制定可以参考 3.1 中的内容，需要结合应用系统的 TP9999 时间和延迟、吞吐量等设定具体的指标，而不是被问题驱动。\n- **保留现场：**目前线上服务基本都是分布式服务，某个节点发生问题后，如果条件允许一定不要直接操作重启、回滚等动作恢复，优先通过摘掉流量的方式来恢复，这样我们可以将堆、栈、GC 日志等关键信息保留下来，不然错过了定位根因的时机，后续解决难度将大大增加。当然除了这些，应用日志、中间件日志、内核日志、各种 Metrics 指标等对问题分析也有很大帮助。\n- **因果分析：**判断 GC 异常与其他系统指标异常的因果关系，可以参考笔者在 3.2 中介绍的时序分析、概率分析、实验分析、反证分析等 4 种因果分析法，避免在排查过程中走入误区。\n- **根因分析：**确实是 GC 的问题后，可以借助上文提到的工具并通过 5 Why 根因分析法以及跟第三节中的九种常见的场景进行逐一匹配，或者直接参考下文的根因鱼骨图，找出问题发生根因，最后再选择优化手段。\n\n**5.2 根因鱼骨图**\n\n送上一张问题根因鱼骨图，一般情况下我们在处理一个 GC 问题时，只要能定位到问题的“病灶”，有的放矢，其实就相当于解决了 80%，如果在某些场景下不太好定位，大家可以借助这种根因分析图通过**排除法**去定位。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-45516be9a66e2a15ffa8f3d1be1db5c6_1440w.png)\n\n**5.3 调优建议**\n\n- **Trade Off：**与 CAP 注定要缺一角一样，GC 优化要在延迟（Latency）、吞吐量（Throughput）、容量（Capacity）三者之间进行权衡。\n- **最终手段：**GC 发生问题不是一定要对 JVM 的 GC 参数进行调优，大部分情况下是通过 GC 的情况找出一些业务问题，切记上来就对 GC 参数进行调整，当然有明确配置错误的场景除外。\n- **控制变量：**控制变量法是在蒙特卡洛（Monte Carlo）方法中用于减少方差的一种技术方法，我们调优的时候尽量也要使用，每次调优过程尽可能只调整一个变量。\n- **善用搜索：**理论上 99.99% 的 GC 问题基本都被遇到了，我们要学会使用搜索引擎的高级技巧，重点关注 StackOverFlow、Github 上的 Issue、以及各种论坛博客，先看看其他人是怎么解决的，会让解决问题事半功倍。能看到这篇文章，你的搜索能力基本过关了~\n- **调优重点：**总体上来讲，我们开发的过程中遇到的问题类型也基本都符合正态分布，太简单或太复杂的基本遇到的概率很低，笔者这里将中间最重要的三个场景添加了“*”标识，希望阅读完本文之后可以观察下自己负责的系统，是否存在上述问题。\n- **GC 参数：**如果堆、栈确实无法第一时间保留，一定要保留 GC 日志，这样我们最起码可以看到 GC Cause，有一个大概的排查方向。关于 GC 日志相关参数，最基本的 -XX:+HeapDumpOnOutOfMemoryError 等一些参数就不再提了，笔者建议添加以下参数，可以提高我们分析问题的效率。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-1f760f2fac0548b6dd872614fb506dc1_1440w.png)\n\n- **其他建议：**上文场景中没有提到，但是对 GC 性能也有提升的一些建议。\n- **主动式 GC：**也有另开生面的做法，通过监控手段监控观测 Old 区的使用情况，即将到达阈值时将应用服务摘掉流量，手动触发一次 Major GC，减少 CMS GC 带来的停顿，但随之系统的健壮性也会减少，如非必要不建议引入。\n- **禁用偏向锁：**偏向锁在只有一个线程使用到该锁的时候效率很高，但是在竞争激烈情况会升级成轻量级锁，此时就需要先**消除偏向锁，这个过程是 STW**的。如果每个同步资源都走这个升级过程，开销会非常大，所以在已知并发激烈的前提下，一般会禁用偏向锁 -XX:-UseBiasedLocking 来提高性能。\n- **虚拟内存：**启动初期有些操作系统（例如 Linux）并没有真正分配物理内存给 JVM ，而是在虚拟内存中分配，使用的时候才会在物理内存中分配内存页，这样也会导致 GC 时间较长。这种情况可以添加 -XX:+AlwaysPreTouch 参数，让 VM 在 commit 内存时跑个循环来强制保证申请的内存真的 commit，避免运行时触发缺页异常。在一些大内存的场景下，有时候能将前几次的 GC 时间降一个数量级，但是添加这个参数后，启动的过程可能会变慢。\n\n## 6. 写在最后\n\n最后，再说笔者个人的一些小建议，遇到一些 GC 问题，如果有精力，一定要探本穷源，找出最深层次的原因。另外，在这个信息泛滥的时代，有一些被“奉为圭臬”的经验可能都是错误的，尽量养成看源码的习惯，有一句话说到“源码面前，了无秘密”，也就意味着遇到搞不懂的问题，我们可以从源码中一窥究竟，某些场景下确有奇效。但也不是只靠读源码来学习，如果硬啃源码但不理会其背后可能蕴含的理论基础，那很容易“捡芝麻丢西瓜”，“只见树木，不见森林”，让“了无秘密”变成了一句空话，我们还是要结合一些实际的业务场景去针对性地学习。\n\n**你的时间在哪里，你的成就就会在哪里**。笔者也是在前两年才开始逐步地在 GC 方向上不断深入，查问题、看源码、做总结，每个 Case 形成一个小的闭环，目前初步摸到了 GC 问题处理的一些门道，同时将经验总结应用于生产环境实践，慢慢地形成一个良性循环。\n\n本篇文章主要是介绍了 CMS GC 的一些常见场景分析，另外一些，如 CodeCache 问题导致 JIT 失效、SafePoint 就绪时间长、Card Table 扫描耗时等问题不太常见就没有花太多篇幅去讲解。Java GC 是在“分代”的思想下内卷了很多年才突破到了“分区”，目前在美团也已经开始使用 G1 来替换使用了多年的 CMS，虽然在小的堆方面 G1 还略逊色于 CMS，但这是一个趋势，短时间无法升级到 ZGC，所以未来遇到的 G1 的问题可能会逐渐增多。目前已经收集到 Remember Set 粗化、Humongous 分配、Ergonomics 异常、Mixed GC 中 Evacuation Failure 等问题，除此之外也会给出 CMS 升级到 G1 的一些建议，接下来笔者将继续完成这部分文章整理，敬请期待。\n\n“防火”永远要胜于“救火”，**不放过任何一个异常的小指标**（一般来说，任何**不平滑的曲线**都是值得怀疑的） ，就有可能避免一次故障的发生。作为 Java 程序员基本都会遇到一些 GC 的问题，独立解决 GC 问题是我们必须迈过的一道坎。开篇中也提到过 GC 作为经典的技术，非常值得我们学习，一些 GC 的学习材料，如《The Garbage Collection Handbook》、《深入理解Java虚拟机》等也是常读常新，赶紧动起来，苦练 GC 基本功吧。\n\n最后的最后，再多啰嗦一句，目前所有 GC 调优相关的文章，第一句讲的就是“不要过早优化”，使得很多同学对 GC 优化望而却步。在这里笔者提出不一样的观点，熵增定律（在一个孤立系统里，如果没有外力做功，其总混乱度（即熵）会不断增大）在计算机系统同样适用，**如果不主动做功使熵减，系统终究会脱离你的掌控**，在我们对业务系统和 GC 原理掌握得足够深的时候，可以放心大胆地做优化，因为我们基本可以预测到每一个操作的结果，放手一搏吧，少年！', '![Java中9种常见的CMS GC问题分析与解决（下）](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-4053612fa65cc0e94680cb8038dc68f2_1440w.png)', b'1', b'1', b'0', b'0', '2024-12-24 14:45:52', '2024-12-24 14:45:52', 0, 8818, 44, 10, b'0', '', 1);
INSERT INTO `blog` VALUES (14, 'Java中的SPI', 'https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/20201206231416917.png', '## 前言\n\n最近在面试的时候被问到SPI了，没回答上来，主要也是自己的原因，把自己给带沟里去了，因为讲到了类加载器的双亲委派模型，后面就被问到了有哪些是破坏了双亲委派模型的场景，然后我就说到了SPI，JNDI，以及JDK9的模块化都破坏了双亲委派。\n然后就被问，那你说说对Java中的SPI的理解吧。然后我就一脸懵逼了，之前只是知道它会破坏双亲委派，也知道是个怎么回事，但是并没有深入了解，那么这次我就好好的来总结一下这个知识吧。\n\n## 什么是SPI\n\nSPI全称Service Provider Interface，字面意思是提供服务的接口，再解释详细一下就是**Java提供的一套用来被第三方实现或扩展的接口，实现了接口的动态扩展，让第三方的实现类能像插件一样嵌入到系统中。**\n\n咦。。。\n这个解释感觉还是有点绕口。\n那就说一下它的本质。\n\n> 将接口的实现类的全限定名配置在文件中（文件名是接口的全限定名），由服务加载器读取配置文件，加载实现类。实现了运行时动态为接口替换实现类。\n\n## SPI示例\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/20201206231416917.png)\n\n```java\n/**\n * @author jimoer\n **/\npublic interface SpiInterfaceService {\n\n    /**\n     * 打印参数\n     * @param parameter 参数\n     */\n    void printParameter(String parameter);\n}\n```\n\n再定义一个module，名字叫spi-service-one，pom.xml中依赖spi-interface。\n在spi-service-one中定义一个实现类，实现SpiInterfaceService 接口。\n\n```java\npackage com.jimoer.spi.service.one;\nimport com.jimoer.spi.app.SpiInterfaceService;\n\n/**\n * @author jimoer\n **/\npublic class SpiOneService implements SpiInterfaceService {\n    /**\n     * 打印参数\n     *\n     * @param parameter 参数\n     */\n    @Override\n    public void printParameter(String parameter) {\n        System.out.println(\"我是SpiOneService:\"+parameter);\n    }\n}\n```\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/20201206230909117.png)\n\n```java\npackage com.jimoer.spi.service.two;\nimport com.jimoer.spi.app.SpiInterfaceService;\n/**\n * @author jimoer\n **/\npublic class SpiTwoService implements SpiInterfaceService {\n    /**\n     * 打印参数\n     *\n     * @param parameter 参数\n     */\n    @Override\n    public void printParameter(String parameter) {\n        System.out.println(\"我是SpiTwoService:\"+parameter);\n    }\n}\n```\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/20201206231315234.png)\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>com.jimoer.spi</groupId>\n        <artifactId>spi-service-one</artifactId>\n        <version>1.0-SNAPSHOT</version>\n    </dependency>\n    <dependency>\n        <groupId>com.jimoer.spi</groupId>\n        <artifactId>spi-service-two</artifactId>\n        <version>1.0-SNAPSHOT</version>\n    </dependency>\n</dependencies>\n```\n\n创建测试类\n\n```java\n/**\n * @author jimoer\n **/\npublic class SpiService {\n\n    public static void main(String[] args) {\n\n        ServiceLoader<SpiInterfaceService> spiInterfaceServices = ServiceLoader.load(SpiInterfaceService.class);\n        Iterator<SpiInterfaceService> iterator = spiInterfaceServices.iterator();\n        while (iterator.hasNext()){\n            SpiInterfaceService sip = iterator.next();\n            sip.printParameter(\"参数\");\n        }\n    }\n}\n```\n\n执行结果：\n\n```log\n我是SpiTwoService:参数\n我是SpiOneService:参数\n```\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/2020120700453760.png)\n\n## SPI的实现\n\n那么我们来看一下SPI具体是如何实现的呢？\n通过上面的例子，我们可以看到，SPI机制的核心代码是下面这段：\n\n```java\nServiceLoader<SpiInterfaceService> spiInterfaceServices = ServiceLoader.load(SpiInterfaceService.class);\n```\n\n那么我们来看一下`ServiceLoader.load()`方法的源码：\n\n```java\npublic static <S> ServiceLoader<S> load(Class<S> service) {\n    ClassLoader cl = Thread.currentThread().getContextClassLoader();\n    return ServiceLoader.load(service, cl);\n}\n```\n\n看到`Thread.currentThread().getContextClassLoader()`；我就明白是怎么回事了，这个就是**线程上下文类加载器**，因为**线程上下文类加载器**就是为了做类加载双亲委派模型的逆序而创建的。\n\n> 使用这个线程上下文类加载器去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了，双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但也是无可奈何的事情。\n> 《深入理解Java虚拟机（第三版）》\n\n虽然知道了它是破坏双亲委派的了，但是具体实现，还是需要具体往下看的。\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/20201207000120134.png)\n\n```java\n// 固定路径\nprivate static final String PREFIX = \"META-INF/services/\";\n\nprivate boolean hasNextService() {\n     if (nextName != null) {\n         return true;\n     }\n     if (configs == null) {\n         try {\n         	// 固定路径+接口全限定名称\n             String fullName = PREFIX + service.getName();\n             // 如果当前线程上下文类加载器为空，会用父类加载器（默认是应用程序类加载器）\n             if (loader == null)\n                 configs = ClassLoader.getSystemResources(fullName);\n             else\n                 configs = loader.getResources(fullName);\n         } catch (IOException x) {\n             fail(service, \"Error locating configuration files\", x);\n         }\n     }\n     while ((pending == null) || !pending.hasNext()) {\n         if (!configs.hasMoreElements()) {\n             return false;\n         }\n         pending = parse(service, configs.nextElement());\n     }\n     // 后面next()方法中判断当前类是否已经出现化的时候要用\n     nextName = pending.next();\n     return true;\n }\n```\n\n主要就是去加载META-INF/services/路径下的接口全限定名称的文件然后去里面找到实现类的类路径将实现类进行类加载。\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/20201207001419765.png)\n\n```java\nprivate S nextService() {\n     if (!hasNextService())\n         throw new NoSuchElementException();\n     String cn = nextName;\n     nextName = null;\n     Class<?> c = null;\n     try {\n     // 直接加载类，无需初始化（因为上面hasNext()已经初始化了）。\n         c = Class.forName(cn, false, loader);\n     } catch (ClassNotFoundException x) {\n         fail(service,\n              \"Provider \" + cn + \" not found\");\n     }\n     if (!service.isAssignableFrom(c)) {\n         fail(service,\n              \"Provider \" + cn  + \" not a subtype\");\n     }\n     try {\n     	// 将加载好的类实例化出对象。\n         S p = service.cast(c.newInstance());\n         providers.put(cn, p);\n         return p;\n     } catch (Throwable x) {\n         fail(service,\n              \"Provider \" + cn + \" could not be instantiated\",\n              x);\n     }\n     throw new Error();          // This cannot happen\n }\n```\n\n看到这里就可以明白了，是如何创建出对象的了。先在hasNext()将接口的实现类进行加载并判断是否存在接口的实现类，然后在next()方法中将实现类进实例化。\n\n### 总结\n\nJava中使用SPI机制的功能其实有很多，像JDBC、JNDI、以及Spring中也有使用，甚至RPC框架（Dubbo）中也有使用SPI机制来实现功能。\n这次就总结到这里了，以后起码也能在面试的时候说出点内容了。', '![Java中的SPI](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/20201206231416917.png)', b'1', b'1', b'0', b'0', '2024-12-24 14:49:32', '2024-12-24 14:49:32', 0, 1373, 7, 10, b'0', '', 1);
INSERT INTO `blog` VALUES (15, 'Java中的ThreadLocal', 'https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/20200909231451433.png', '## 前言\n\n面试的时候被问到ThreadLocal的相关知识，没有回答好（奶奶的，现在感觉问啥都能被问倒），所以我决定先解决这几次面试中都遇到的高频问题，把这几个硬骨头都能理解的透彻的说出来了，感觉最起码不能总是一轮游。\n\n### ThreadLocal介绍\n\nThreadLocal是JDK1.2开始就提供的一个用来存储线程本地变量的类。ThreadLocal中的变量是在每个线程中独立存在的，当多个线程访问ThreadLocal中的变量的时候，其实都是访问的自己当前线程的内存中的变量，从而保证的变量的线程安全。\n\n我们一般在使用ThreadLocal的时候都是为了解决线程中存在的变量竞争问题。其实解决这类问题，通常大家也会想到使用synchronized来加锁解决。\n\n例如在解决SimpleDateFormat的线程安全的时候。SimpleDateFormat是非线程安全的，它里面无论的是format()方法还是parse()方法，都有使用它自己内部的一个Calendar类的对象，format方法是设置时间，parse()方法里面是先调用Calendar的clear()方法，然后又调用了Calendar的set()方法（赋值），如果一个线程刚调用了set()进行赋值，这个时候又来了一个线程直接调用了clear()方法，那么这个parse()方法执行的结果就会有问题的。\n**解决办法一**\n将使用SimpleDateformat的方法加上synchronized，这样虽然保证了线程安全，但却降低了效率，同一时间只有一个线程能使用格式化时间的方法。\n\n```java\nprivate static SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\npublic static synchronized String formatDate(Date date){\n    return simpleDateFormat.format(date);\n}\n```\n\n**解决办法二**\n将SimpleDateFormat的对象，放到ThreadLocal里面，这样每个线程中都有一个自己的格式对象的副本了。互不干扰，从而保证了线程安全。\n\n```java\nprivate static final ThreadLocal<SimpleDateFormat> simpleDateFormatThreadLocal = ThreadLocal.withInitial(() -> new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"));\n\npublic static String formatDate(Date date){\n   return simpleDateFormatThreadLocal.get().format(date);\n}\n```\n\n### ThreadLocal的原理\n\n我们先看一下ThreadLocal是怎么使用的。\n\n```java\nThreadLocal<Integer> threadLocal99 = new ThreadLocal<Integer>();\nthreadLocal99.set(3);\nint num = threadLocal99.get();\nSystem.out.println(\"数字:\"+num);\nthreadLocal99.remove();\nSystem.out.println(\"数字Empty:\"+threadLocal99.get());\n```\n\n运行结果：\n\n```log\n数字:3\n数字Empty:null\n```\n\n使用起来很简单，主要是将变量放到ThreadLocal里面，在线程执行过程中就可以取到，当执行完成后在remove掉就可以了，只要没有调用remove()当前线程在执行过程中都是可以拿到变量数据的。\n因为是放到了当前执行的线程中，所以ThreadLocal中的变量值只能当前线程来使用，从而保证的了线程安全（当前线程的子线程其实也是可以获取到的）。\n\n来看一下ThreadLocal的set()方法源码\n\n```java\npublic void set(T value) {\n   // 获取当前线程\n   Thread t = Thread.currentThread();\n   // 获取ThreadLocalMap\n   ThreadLocal.ThreadLocalMap map = getMap(t);\n   // ThreadLocalMap 对象是否为空，不为空则直接将数据放入到ThreadLocalMap中\n   if (map != null)\n       map.set(this, value);\n   else\n       createMap(t, value); // ThreadLocalMap对象为空，则先创建对象，再赋值。\n}\n```\n\n我们看到变量都是存放在了ThreadLocalMap这个变量中的。那么ThreadLocalMap又是怎么来的呢？\n\n```java\nThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;\n}\npublic class Thread implements Runnable {\n	... ...\n	/* ThreadLocal values pertaining to this thread. This map is maintained\n     * by the ThreadLocal class. */\n    ThreadLocal.ThreadLocalMap threadLocals = null;\n    ... ...\n}\n```\n\n通过上面的源码，我们发现ThreadLocalMap变量是当前执行线程中的一个变量，所以说，ThreadLocal中存放的数据其实都是放到了当前执行线程中的一个变量里面了。也就是存储在了当前的线程对象里了，别的线程里面是另一个线程对象了，拿不到其他线程对象中的数据，所以数据自然就隔离开了。\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/20200909231451433.png)\n\n```java\n/**\n * Set the value associated with key.\n * @param key the thread local object\n * @param value the value to be set\n */\nprivate void set(ThreadLocal<?> key, Object value) {\n\n    // We don\'t use a fast path as with get() because it is at\n    // least as common to use set() to create new entries as\n    // it is to replace existing ones, in which case, a fast\n    // path would fail more often than not.\n\n    Entry[] tab = table;\n    int len = tab.length;\n    // 定位在数组中的位置\n    int i = key.threadLocalHashCode & (len-1);\n\n    for (Entry e = tab[i];\n         e != null;\n         e = tab[i = nextIndex(i, len)]) {\n        ThreadLocal<?> k = e.get();\n        // 如果当前位置不为空，并且当前位置的key和传过来的key相等，那么就会覆盖当前位置的数据\n        if (k == key) {\n            e.value = value;\n            return;\n        }\n        // 如果当前位置为空，则初始化一个Entry对象，放到当前位置。\n        if (k == null) {\n            replaceStaleEntry(key, value, i);\n            return;\n        }\n    }\n    // 如果当前位置不为空，并且当前位置的key也不等于要赋值的key ，那么将去找下一个空位置，直接将数据放到下一个空位置处。\n    tab[i] = new Entry(key, value);\n    int sz = ++size;\n    if (!cleanSomeSlots(i, sz) && sz >= threshold)\n        rehash();\n}\n```\n\n我们从set()方法中可以看到，处理逻辑有四步。\n\n- 第一步先根据Threadlocal对象的hashcode和数组长度做与运算获取数据应该放在当前数组中的位置。\n- 第二步就是判断当前位置是否为空，为空的话就直接初始化一个Entry对象，放到当前位置。\n- 第三步如果当前位置不为空，而当前位置的Entry中的key和传过来的key一样，那么直接覆盖掉当前位置的数据。\n- 第四步如果当前位置不为空，并且当前位置的Entry中的key和传过来的key\n  也不一样，那么就会去找下一个空位置，然后将数据存放到空位置（**数组超过长度后，会执行扩容的**）；\n\n在get的时候也是类似的逻辑，先通过传入的ThreadLocal的hashcode获取在Entry数组中的位置，然后拿当前位置的Entry的Key和传入的ThreadLocal对比，相等的话，直接把数据返回，如果不相等就去判断和数组中的下一个值的key是否相等。。。\n\n```java\nprivate Entry getEntry(ThreadLocal<?> key) {\n    int i = key.threadLocalHashCode & (table.length - 1);\n    Entry e = table[i];\n    if (e != null && e.get() == key)\n        return e;\n    else\n        return getEntryAfterMiss(key, i, e);\n}\n/**\n * Version of getEntry method for use when key is not found in\n * its direct hash slot.\n *\n * @param  key the thread local object\n * @param  i the table index for key\'s hash code\n * @param  e the entry at table[i]\n * @return the entry associated with key, or null if no such\n */\nprivate Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {\n    Entry[] tab = table;\n    int len = tab.length;\n\n    while (e != null) {\n        ThreadLocal<?> k = e.get();\n        if (k == key)\n            return e;\n        if (k == null)\n            expungeStaleEntry(i);\n        else\n            i = nextIndex(i, len);\n        e = tab[i];\n    }\n    return null;\n}\n```\n\n我们上文一直说，ThreadLocal是保存在单个线程中的数据，每个线程都有自己的数据，但是实际ThreadLocal里面的真正的对象数据，其实是保存在堆里面的，而线程里面只是存储了对象的引用而已。\n并且我们在使用的时候通常需要在上一个线程执行的方法的上下文共享ThreadLocal中的变量。\n例如我的主线程是在某个方法中执行代码呢，但是这个方法中有一段代码时新创建了一个线程，在这个线程里面还使用了我这个正在执行的方法里面的定义的ThreadLocal里面的变量。这个时候，就是需要从新线程里面调用外面线程的数据，这个就需要线程间共享了。这种子父线程共享数据的情况，ThreadLocal也是支持的。\n例如：\n\n```java\nThreadLocal threadLocalMain = new InheritableThreadLocal();\n threadLocalMain.set(\"主线程变量\");\n Thread t = new Thread() {\n     @Override\n     public void run() {\n         super.run();\n         System.out.println( \"现在获取的变量是 =\" + threadLocalMain.get());\n     }\n };\n t.start();\n```\n\n运行结果：\n\n```log\n现在获取的变量是 =主线程变量\n```\n\n上面这样的代码就能实现子父线程共享数据的情况，重点是使用InheritableThreadLocal来实现的共享。\n那么它是怎么实现数据共享的呢？\n在Thread类的init()方法中有这么一段代码：\n\n```java\nif (inheritThreadLocals && parent.inheritableThreadLocals != null)\n            this.inheritableThreadLocals =ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);\n```\n\n这段代码的意思是，在创建线程的时候，如果当前线程的inheritThreadLocals变量和父线程的inheritThreadLocals变量都不为空的时候，会将父线程的inheritThreadLocals变量中的数据，赋给当前线程中的inheritThreadLocals变量。\n\n### ThreadLocal的内存泄漏问题\n\n上文我们也提到过，ThreadLocal中的ThreadLocalMap里面的Entry对象是继承自WeakReference类的，说明Entry的key是一个弱引用。\n\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/20200910083829900.png)\n\n> 弱引用是用来描述那些非必须的对象，弱引用的对象，只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。\n\n**这个弱引用还是ThreadLocal对象本身，所以一般在线程执行完成后，ThreadLocal对象就会变成null了，而为null的弱引用对象，在下一次GC的时候就会被清除掉，这样Entry的Key的内存空间就被释放出来了，但是Entry的value还在占用的内存，如果线程是被复用的（例如线程池中的线程），后面也不使用ThreadLocal存取数据了，那么这里面的value值会一直存在，最终就导致了内存泄漏。**\n\n**防止内存泄漏的办法就是在每次使用完ThreadLocal的时候都去执行以下remove()方法，就可以把key和value的空间都释放了。**\n\n### 那既然容易产生内存泄漏，为什么还要设置成弱引用的呢？\n\n如果正常情况下应该是强引用，但是强引用只要引用关系还在就一直不会被回收，所以如果线程被复用了，那么Entry中的Key和Value都不会被回收，这样就造成了Key和Value都会发生内存泄漏了；\n\n但是设置成弱引用，当ThreadLocal对象，没有被强引用后，就会被回收，回收后，Entry中的key就会被设置成null了，如果Thread被重复使用，只要还会用ThreadLocal存储数据，那么就会调用ThreadLocal的，set、get等方法，在调用set、get、等方法的时候，是会扫描Entry中key为null的数据的。\n当发现Entry中，有key为null的数据时，会将value也设置为null，这样就将value的值也进行了回收，能进一步防止内存泄漏了，并且在进行rehash的时候，也是先清除掉key是null的数据后，如果空间还不够，才进行扩容的。\n\n但是虽然将key设置了弱引用，但是如果一个线程被重复利用，执行完任务后，再也不使用ThreadLocal了，那么最后value值会一直存在，最终也是会导致内存泄漏的，所以使用ThreadLocal的时候，最后一定要执行remove()方法。', '![Java中的ThreadLocal](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/20200909231451433.png)', b'1', b'1', b'0', b'0', '2024-12-24 14:51:39', '2024-12-24 14:51:39', 0, 2848, 14, 10, b'0', '', 1);
INSERT INTO `blog` VALUES (16, 'Java线程池实现原理及其在美团业务中的实践', 'https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/912883e51327e0c7a9d753d11896326511272.png', '随着计算机行业的飞速发展，摩尔定律逐渐失效，多核CPU成为主流。使用多线程并行计算逐渐成为开发人员提升服务器性能的基本武器。J.U.C提供的线程池：ThreadPoolExecutor类，帮助开发人员管理线程并方便地执行并行任务。了解并合理使用线程池，是一个开发人员必修的基本功。\n\n本文开篇简述线程池概念和用途，接着结合线程池的源码，帮助读者领略线程池的设计思路，最后回归实践，通过案例讲述使用线程池遇到的问题，并给出了一种动态化线程池解决方案。\n\n## 一、写在前面\n\n### 1.1 线程池是什么\n\n线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如MySQL。\n\n线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。\n\n而本文描述线程池是JDK中提供的ThreadPoolExecutor类。\n\n当然，使用线程池可以带来一系列好处：\n\n- **降低资源消耗**：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。\n- **提高响应速度**：任务到达时，无需等待线程创建即可立即执行。\n- **提高线程的可管理性**：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。\n- **提供更多更强大的功能**：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。\n\n### 1.2 线程池解决的问题是什么\n\n线程池解决的核心问题就是资源管理问题。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题：\n\n1. 频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。\n2. 对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。\n3. 系统无法合理管理内部的资源分布，会降低系统的稳定性。\n\n为解决资源分配这个问题，线程池采用了“池化”（Pooling）思想。池化，顾名思义，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。\n\nPooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finance, computing and equipment management.——wikipedia\n\n“池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。\n\n在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括：\n\n1. 内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。\n2. 连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。\n3. 实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。\n\n在了解完“是什么”和“为什么”之后，下面我们来一起深入一下线程池的内部实现原理。\n\n## 二、线程池核心设计与实现\n\n在前文中，我们了解到：线程池是一种通过“池化”思想，帮助我们管理线程而获取并发性的工具，在Java中的体现是ThreadPoolExecutor类。那么它的的详细设计与实现是什么样的呢？我们会在本章进行详细介绍。\n\n### 2.1 总体设计\n\nJava中的线程池核心实现类是ThreadPoolExecutor，本章基于JDK 1.8的源码来分析Java线程池的核心设计与实现。我们首先来看一下ThreadPoolExecutor的UML类图，了解下ThreadPoolExecutor的继承关系。\n\n![图1 ThreadPoolExecutor UML类图](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/912883e51327e0c7a9d753d11896326511272.png)\n\n图1 ThreadPoolExecutor UML类图\n\nThreadPoolExecutor实现的顶层接口是Executor，顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。ExecutorService接口增加了一些能力：（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；（2）提供了管控线程池的方法，比如停止线程池的运行。AbstractExecutorService则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。最下层的实现类ThreadPoolExecutor实现最复杂的运行部分，ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。\n\nThreadPoolExecutor是如何运行，如何同时维护线程和执行任务的呢？其运行机制如下图所示：\n\n![图2 ThreadPoolExecutor运行流程](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/77441586f6b312a54264e3fcf5eebe2663494.png)\n\n图2 ThreadPoolExecutor运行流程\n\n线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分：任务管理、线程管理。任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：（1）直接申请线程执行该任务；（2）缓冲到队列中等待线程执行；（3）拒绝该任务。线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。\n\n接下来，我们会按照以下三个部分去详细讲解线程池运行机制：\n\n1. 线程池如何维护自身状态。\n2. 线程池如何管理任务。\n3. 线程池如何管理线程。\n\n### 2.2 生命周期管理\n\n线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。线程池内部使用一个变量维护两个值：运行状态(runState)和线程数量 (workerCount)。在具体实现中，线程池将运行状态(runState)、线程数量 (workerCount)两个关键参数的维护放在了一起，如下代码所示：\n\n```java\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n```\n\n`ctl`这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它同时包含两部分的信息：线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。通过阅读线程池源代码也可以发现，经常出现要同时判断线程池运行状态和线程数量的情况。线程池也提供了若干方法去供用户获得线程池当前的运行状态、线程个数。这里都使用的是位运算的方式，相比于基本运算，速度也会快很多。\n\n关于内部封装的获取生命周期状态、获取线程池线程数量的计算方法如以下代码所示：\n\n```java\nprivate static int runStateOf(int c)     { return c & ~CAPACITY; } //计算当前运行状态\nprivate static int workerCountOf(int c)  { return c & CAPACITY; }  //计算当前线程数量\nprivate static int ctlOf(int rs, int wc) { return rs | wc; }   //通过状态和线程数生成ctl\n```\n\nThreadPoolExecutor的运行状态有5种，分别为：\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/62853fa44bfa47d63143babe3b5a4c6e82532.png)\n\n其生命周期转换如下入所示：\n\n![图3 线程池生命周期](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/582d1606d57ff99aa0e5f8fc59c7819329028.png)\n\n图3 线程池生命周期\n\n### 2.3 任务执行机制\n\n**2.3.1 任务调度**\n\n任务调度是线程池的主要入口，当用户提交了一个任务，接下来这个任务将如何执行都是由这个阶段决定的。了解这部分就相当于了解了线程池的核心运行机制。\n\n首先，所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：\n\n1. 首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。\n2. 如果workerCount < corePoolSize，则创建并启动一个线程来执行新提交的任务。\n3. 如果workerCount >= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。\n4. 如果workerCount >= corePoolSize && workerCount < maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。\n5. 如果workerCount >= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。\n\n其执行流程如下图所示：\n\n![图4 任务调度流程](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/31bad766983e212431077ca8da92762050214.png)\n\n图4 任务调度流程\n\n**2.3.2 任务缓冲**\n\n任务缓冲模块是线程池能够管理任务的核心部分。线程池的本质是对任务和线程的管理，而做到这一点最关键的思想就是将任务和线程两者解耦，不让两者直接关联，才可以做后续的分配工作。线程池中是以生产者消费者模式，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。\n\n阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。\n\n下图中展示了线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素：\n\n![图5 阻塞队列](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/f4d89c87acf102b45be8ccf3ed83352a9497.png)\n\n图5 阻塞队列\n\n使用不同的队列可以实现不一样的任务存取策略。在这里，我们可以再介绍下阻塞队列的成员：\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/725a3db5114d95675f2098c12dc331c3316963.png)\n\n**2.3.3 任务申请**\n\n由上文的任务分配部分可知，任务的执行有两种可能：一种是任务直接由新创建的线程执行。另一种是线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。第一种情况仅出现在线程初始创建的时候，第二种是线程获取任务绝大多数的情况。\n\n线程需要从任务缓存模块中不断地取任务执行，帮助线程从阻塞队列中获取任务，实现线程管理模块和任务管理模块之间的通信。这部分策略由getTask方法实现，其执行流程如下图所示：\n\n![图6 获取任务流程图](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/49d8041f8480aba5ef59079fcc7143b996706.png)\n\n图6 获取任务流程图\n\ngetTask这部分进行了多次判断，为的是控制线程的数量，使其符合线程池的状态。如果线程池现在不应该持有那么多线程，则会返回null值。工作线程Worker会不断接收新任务去执行，而当工作线程Worker接收不到任务的时候，就会开始被回收。\n\n**2.3.4 任务拒绝**\n\n任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。\n\n拒绝策略是一个接口，其设计如下：\n\n```java\npublic interface RejectedExecutionHandler {\n    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);\n}\n```\n\n用户可以通过实现这个接口去定制拒绝策略，也可以选择JDK提供的四种已有拒绝策略，其特点如下：\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/9ffb64cc4c64c0cb8d38dac01c89c905178456.png)\n\n2.4 Worker线程管理\n\n2.4.1 Worker线程\n\n线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程Worker。我们来看一下它的部分代码：\n\n```java\nprivate final class Worker extends AbstractQueuedSynchronizer implements Runnable{\n    final Thread thread;//Worker持有的线程\n    Runnable firstTask;//初始化的任务，可以为null\n}\n```\n\nWorker这个工作线程，实现了Runnable接口，并持有一个线程thread，一个初始化的任务firstTask。thread是在调用构造方法时通过ThreadFactory来创建的线程，可以用来执行任务；firstTask用它来保存传入的第一个任务，这个任务可以有也可以为null。如果这个值是非空的，那么线程就会在启动初期立即执行这个任务，也就对应核心线程创建时的情况；如果这个值是null，那么就需要创建一个线程去执行任务列表（workQueue）中的任务，也就是非核心线程的创建。\n\nWorker执行任务的模型如下图所示：\n\n![图7 Worker执行任务](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/03268b9dc49bd30bb63064421bb036bf90315.png)\n\n图7 Worker执行任务\n\n线程池需要管理线程的生命周期，需要在线程长时间不运行的时候进行回收。线程池使用一张Hash表去持有线程的引用，这样可以通过添加引用、移除引用这样的操作来控制线程的生命周期。这个时候重要的就是如何判断线程是否在运行。\n\nWorker是通过继承AQS，使用AQS来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反应线程现在的执行状态。\n\n1.lock方法一旦获取了独占锁，表示当前线程正在执行任务中。 2.如果正在执行任务，则不应该中断线程。 3.如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。 4.线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。\n\n在线程回收过程中就使用到了这种特性，回收过程如下图所示：\n\n![图8 线程池回收过程](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/9d8dc9cebe59122127460f81a98894bb34085.png)\n\n图8 线程池回收过程\n\n**2.4.2 Worker线程增加**\n\n增加线程是通过线程池中的addWorker方法，该方法的功能就是增加一个线程，该方法不考虑线程池是在哪个阶段增加的该线程，这个分配线程的策略是在上个步骤完成的，该步骤仅仅完成增加线程，并使它运行，最后返回是否成功这个结果。addWorker方法有两个参数：firstTask、core。firstTask参数用于指定新增的线程执行的第一个任务，该参数可以为空；core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize，其执行流程如下图所示：\n\n![图9 申请线程执行流程图](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/49527b1bb385f0f43529e57b614f59ae145454.png)\n\n图9 申请线程执行流程图\n\n**2.4.3 Worker线程回收**\n\n线程池中线程的销毁依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。Worker被创建出来后，就会不断地进行轮询，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。当Worker无法获取到任务，也就是获取的任务为空时，循环会结束，Worker会主动消除自身在线程池内的引用。\n\n```java\ntry {\n  while (task != null || (task = getTask()) != null) {\n    //执行任务\n  }\n} finally {\n  processWorkerExit(w, completedAbruptly);//获取不到任务时，主动回收自己\n}\n```\n\n线程回收的工作是在processWorkerExit方法完成的。\n\n![图10 线程销毁流程](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/90ea093549782945f2c968403fdc39d415386.png)\n\n图10 线程销毁流程\n\n事实上，在这个方法中，将线程引用移出线程池就已经结束了线程销毁的部分。但由于引起线程销毁的可能性有很多，线程池还要判断是什么引发了这次销毁，是否要改变线程池的现阶段状态，是否要根据新状态，重新分配线程。\n\n**2.4.4 Worker线程执行任务**\n\n在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的执行过程如下：\n\n1.while循环不断地通过getTask()方法获取任务。 2.getTask()方法从阻塞队列中取任务。 3.如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。 4.执行任务。 5.如果getTask结果为null则跳出循环，执行processWorkerExit()方法，销毁线程。\n\n执行流程如下图所示：\n\n![图11 执行任务流程](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/879edb4f06043d76cea27a3ff358cb1d45243.png)\n\n图11 执行任务流程\n\n## 三、线程池在业务中的实践\n\n### 3.1 业务背景\n\n在当今的互联网业界，为了最大程度利用CPU的多核性能，并行运算的能力是不可或缺的。通过线程池管理线程获取并发性是一个非常基础的操作，让我们来看两个典型的使用线程池获取并发性的场景。\n\n**场景1：快速响应用户请求**\n\n**描述**：用户发起的实时请求，服务追求响应时间。比如说用户要查看一个商品的信息，那么我们需要将商品维度的一系列信息如商品的价格、优惠、库存、图片等等聚合起来，展示给用户。\n\n**分析**：从用户体验角度看，这个结果响应的越快越好，如果一个页面半天都刷不出，用户可能就放弃查看这个商品了。而面向用户的功能聚合通常非常复杂，伴随着调用与调用之间的级联、多级级联等情况，业务开发同学往往会选择使用线程池这种简单的方式，将调用封装成任务并行的执行，缩短总体响应时间。另外，使用线程池也是有考量的，这种场景最重要的就是获取最大的响应速度去满足用户，所以应该不设置队列去缓冲并发任务，调高corePoolSize和maxPoolSize去尽可能创造多的线程快速执行任务。\n\n![图12 并行执行任务提升任务响应速度](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/e9a363c8577f211577e4962e9110cb0226733.png)\n\n图12 并行执行任务提升任务响应速度\n\n**场景2：快速处理批量任务**\n\n**描述**：离线的大量计算任务，需要快速执行。比如说，统计某个报表，需要计算出全国各个门店中有哪些商品有某种属性，用于后续营销策略的分析，那么我们需要查询全国所有门店中的所有商品，并且记录具有某属性的商品，然后快速生成报表。\n\n**分析**：这种场景需要执行大量的任务，我们也会希望任务执行的越快越好。这种情况下，也应该使用多线程策略，并行计算。但与响应速度优先的场景区别在于，这类场景任务量巨大，并不需要瞬时的完成，而是关注如何使用有限的资源，尽可能在单位时间内处理更多的任务，也就是吞吐量优先的问题。所以应该设置队列去缓冲并发任务，调整合适的corePoolSize去设置处理任务的线程数。在这里，设置的线程数过多可能还会引发线程上下文切换频繁的问题，也会降低处理任务的速度，降低吞吐量。\n\n![图13 并行执行任务提升批量任务执行速度](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/1a1746f33bfdcb03da074d8539ebb2f367563.png)\n\n图13 并行执行任务提升批量任务执行速度\n\n### 3.2 实际问题及方案思考\n\n线程池使用面临的核心的问题在于：**线程池的参数并不好配置**。一方面线程池的运行机制不是很好理解，配置合理需要强依赖开发人员的个人经验和知识；另一方面，线程池执行的情况和任务类型相关性较大，IO密集型和CPU密集型的任务运行起来的情况差异非常大，这导致业界并没有一些成熟的经验策略帮助开发人员参考。\n\n关于线程池配置不合理引发的故障，公司内部有较多记录，下面举一些例子：\n\n**Case1**：2018年XX页面展示接口大量调用降级：\n\n**事故描述**：XX页面展示接口产生大量调用降级，数量级在几十到上百。\n\n**事故原因**：该服务展示接口内部逻辑使用线程池做并行计算，由于没有预估好调用的流量，导致最大核心数设置偏小，大量抛出RejectedExecutionException，触发接口降级条件，示意图如下：\n\n![图14 线程数核心设置过小引发RejectExecutionException](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/1df932840b31f41931bb69e16be2932844240.png)\n\n图14 线程数核心设置过小引发RejectExecutionException\n\n**Case2**：2018年XX业务服务不可用S2级故障\n\n**事故描述**：XX业务提供的服务执行时间过长，作为上游服务整体超时，大量下游服务调用失败。\n\n**事故原因**：该服务处理请求内部逻辑使用线程池做资源隔离，由于队列设置过长，最大线程数设置失效，导致请求数量增加时，大量任务堆积在队列中，任务执行时间过长，最终导致下游服务的大量调用超时失败。示意图如下：\n\n![图15 线程池队列长度设置过长、corePoolSize设置过小导致任务执行速度低](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/668e3c90f4b918bfcead2f4280091e9757284.png)\n\n图15 线程池队列长度设置过长、corePoolSize设置过小导致任务执行速度低\n\n业务中要使用线程池，而使用不当又会导致故障，那么我们怎样才能更好地使用线程池呢？针对这个问题，我们下面延展几个方向：\n\n**1. 能否不用线程池?**\n\n回到最初的问题，业务使用线程池是为了获取并发性，对于获取并发性，是否可以有什么其他的方案呢替代？我们尝试进行了一些其他方案的调研：\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/56ab763273b2c03b2f1c37db7b150338414771.png)\n\n综合考虑，这些新的方案都能在某种情况下提升并行任务的性能，然而本次重点解决的问题是如何更简易、更安全地获得的并发性。另外，Actor模型的应用实际上甚少，只在Scala中使用广泛，协程框架在Java中维护的也不成熟。这三者现阶段都不是足够的易用，也并不能解决业务上现阶段的问题。\n\n**2. 追求参数设置合理性？**\n\n有没有一种计算公式，能够让开发同学很简易地计算出某种场景中的线程池应该是什么参数呢？\n\n带着这样的疑问，我们调研了业界的一些线程池参数配置方案：\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/23a44974ff68a08261fb675242b83648181953.png)\n\n调研了以上业界方案后，我们并没有得出通用的线程池计算方式。并发任务的执行情况和任务类型相关，IO密集型和CPU密集型的任务运行起来的情况差异非常大，但这种占比是较难合理预估的，这导致很难有一个简单有效的通用公式帮我们直接计算出结果。\n\n**3. 线程池参数动态化？**\n\n尽管经过谨慎的评估，仍然不能够保证一次计算出来合适的参数，那么我们是否可以将修改线程池参数的成本降下来，这样至少可以发生故障的时候可以快速调整从而缩短故障恢复的时间呢？基于这个思考，我们是否可以将线程池的参数从代码中迁移到分布式配置中心上，实现线程池参数可动态配置和即时生效，线程池参数动态化前后的参数修改流程对比如下：\n\n![图16 动态修改线程池参数新旧流程对比](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/c6caa5be64f39758ada0593b995d65fd25982.png)\n\n图16 动态修改线程池参数新旧流程对比\n\n基于以上三个方向对比，我们可以看出参数动态化方向简单有效。\n\n### 3.3 动态化线程池\n\n**3.3.1 整体设计**\n\n动态化线程池的核心设计包括以下三个方面：\n\n1. 简化线程池配置：线程池构造参数有8个，但是最核心的是3个：corePoolSize、maximumPoolSize，workQueue，它们最大程度地决定了线程池的任务分配和线程分配策略。考虑到在实际应用中我们获取并发性的场景主要是两种：（1）并行执行子任务，提高响应速度。这种情况下，应该使用同步队列，没有什么任务应该被缓存下来，而是应该立即执行。（2）并行执行大批次任务，提升吞吐量。这种情况下，应该使用有界队列，使用队列去缓冲大批量的任务，队列容量必须声明，防止任务无限制堆积。所以线程池只需要提供这三个关键参数的配置，并且提供两种队列的选择，就可以满足绝大多数的业务需求，Less is More。\n2. 参数可动态修改：为了解决参数不好配，修改参数成本高等问题。在Java线程池留有高扩展性的基础上，封装线程池，允许线程池监听同步外部的消息，根据消息进行修改配置。将线程池的配置放置在平台侧，允许开发同学简单的查看、修改线程池配置。\n3. 增加线程池监控：对某事物缺乏状态的观测，就对其改进无从下手。在线程池执行任务的生命周期添加监控能力，帮助开发同学了解线程池状态。\n\n![图17 动态化线程池整体设计](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/4d5c410ad23782350cc9f980787151fd54144.png)\n\n图17 动态化线程池整体设计\n\n**3.3.2 功能架构**\n\n动态化线程池提供如下功能：\n\n**动态调参**：支持线程池参数动态调整、界面化操作；包括修改线程池核心大小、最大核心大小、队列长度等；参数修改后及时生效。 **任务监控**：支持应用粒度、线程池粒度、任务粒度的Transaction监控；可以看到线程池的任务执行情况、最大任务执行时间、平均任务执行时间、95/99线等。 **负载告警**：线程池队列任务积压到一定值的时候会通过大象（美团内部通讯工具）告知应用开发负责人；当线程池负载数达到一定阈值的时候会通过大象告知应用开发负责人。 **操作监控**：创建/修改和删除线程池都会通知到应用的开发负责人。 **操作日志**：可以查看线程池参数的修改记录，谁在什么时候修改了线程池参数、修改前的参数值是什么。 **权限校验**：只有应用开发负责人才能够修改应用的线程池参数。\n\n![图18 动态化线程池功能架构](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/6c0091e92e90f50f89fd83f3b9eb5472135718.png)\n\n图18 动态化线程池功能架构\n\n**参数动态化**\n\nJDK原生线程池ThreadPoolExecutor提供了如下几个public的setter方法，如下图所示：\n\n![图19 JDK 线程池参数设置接口](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/efd32f1211e9cf0a3ca9d35b0dc5de8588353.png)\n\n图19 JDK 线程池参数设置接口\n\nJDK允许线程池使用方通过ThreadPoolExecutor的实例来动态设置线程池的核心策略，以setCorePoolSize为方法例，在运行期线程池使用方调用此方法设置corePoolSize之后，线程池会直接覆盖原来的corePoolSize值，并且基于当前值和原始值的比较结果采取不同的处理策略。对于当前值小于当前工作线程数的情况，说明有多余的worker线程，此时会向当前idle的worker线程发起中断请求以实现回收，多余的worker在下次idel的时候也会被回收；对于当前值大于原始值且当前队列中有待执行任务，则线程池会创建新的worker线程来执行队列任务，setCorePoolSize具体流程如下：\n\n![图20 setCorePoolSize方法执行流程](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/9379fe1666818237f842138812bf63bd85645.png)\n\n图20 setCorePoolSize方法执行流程\n\n线程池内部会处理好当前状态做到平滑修改，其他几个方法限于篇幅，这里不一一介绍。重点是基于这几个public方法，我们只需要维护ThreadPoolExecutor的实例，并且在需要修改的时候拿到实例修改其参数即可。基于以上的思路，我们实现了线程池参数的动态化、线程池参数在管理平台可配置可修改，其效果图如下图所示：\n\n![图21 可动态修改线程池参数](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/414ba7f3abd11e5f805c58635ae10988166121.png)\n\n图21 可动态修改线程池参数\n\n用户可以在管理平台上通过线程池的名字找到指定的线程池，然后对其参数进行修改，保存后会实时生效。目前支持的动态参数包括核心数、最大值、队列长度等。除此之外，在界面中，我们还能看到用户可以配置是否开启告警、队列等待任务告警阈值、活跃度告警等等。关于监控和告警，我们下面一节会对齐进行介绍。\n\n**线程池监控**\n\n除了参数动态化之外，为了更好地使用线程池，我们需要对线程池的运行状况有感知，比如当前线程池的负载是怎么样的？分配的资源够不够用？任务的执行情况是怎么样的？是长任务还是短任务？基于对这些问题的思考，动态化线程池提供了多个维度的监控和告警能力，包括：线程池活跃度、任务的执行Transaction（频率、耗时）、Reject异常、线程池内部统计信息等等，既能帮助用户从多个维度分析线程池的使用情况，又能在出现问题第一时间通知到用户，从而避免故障或加速故障恢复。\n\n#### 1. 负载监控和告警\n\n线程池负载关注的核心问题是：基于当前线程池参数分配的资源够不够。对于这个问题，我们可以从事前和事中两个角度来看。事前，线程池定义了“活跃度”这个概念，来让用户在发生Reject异常之前能够感知线程池负载问题，线程池活跃度计算公式为：线程池活跃度 = activeCount/maximumPoolSize。这个公式代表当活跃线程数趋向于maximumPoolSize的时候，代表线程负载趋高。事中，也可以从两方面来看线程池的过载判定条件，一个是发生了Reject异常，一个是队列中有等待任务（支持定制阈值）。以上两种情况发生了都会触发告警，告警信息会通过大象推送给服务所关联的负责人。\n\n![图22 大象告警通知](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/04e73f7186a91d99181e1b5615ce9e4a318600.png)\n\n图22 大象告警通知\n\n#### 2. 任务级精细化监控\n\n在传统的线程池应用场景中，线程池中的任务执行情况对于用户来说是透明的。比如在一个具体的业务场景中，业务开发申请了一个线程池同时用于执行两种任务，一个是发消息任务、一个是发短信任务，这两类任务实际执行的频率和时长对于用户来说没有一个直观的感受，很可能这两类任务不适合共享一个线程池，但是由于用户无法感知，因此也无从优化。动态化线程池内部实现了任务级别的埋点，且允许为不同的业务任务指定具有业务含义的名称，线程池内部基于这个名称做Transaction打点，基于这个功能，用户可以看到线程池内部任务级别的执行情况，且区分业务，任务监控示意图如下图所示：\n\n![图23 线程池任务执行监控](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/cd0b9445c3c93a866201b7cfb24d2ce7214776.png)\n\n图23 线程池任务执行监控\n\n#### 3. 运行时状态实时查看\n\n用户基于JDK原生线程池ThreadPoolExecutor提供的几个public的getter方法，可以读取到当前线程池的运行状态以及参数，如下图所示：\n\n![图24 线程池实时运行情况](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/aba8d9c09e6f054c7061ddd720a04a26147951.png)\n\n图24 线程池实时运行情况\n\n动态化线程池基于这几个接口封装了运行时状态实时查看的功能，用户基于这个功能可以了解线程池的实时状态，比如当前有多少个工作线程，执行了多少个任务，队列中等待的任务数等等。效果如下图所示：\n\n![图25 线程池实时运行情况](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/38d5fbeaebd4998f3a30d44bd20b996f113233.png)\n\n图25 线程池实时运行情况\n\n### 3.4 实践总结\n\n面对业务中使用线程池遇到的实际问题，我们曾回到支持并发性问题本身来思考有没有取代线程池的方案，也曾尝试着去追求线程池参数设置的合理性，但面对业界方案具体落地的复杂性、可维护性以及真实运行环境的不确定性，我们在前两个方向上可谓“举步维艰”。最终，我们回到线程池参数动态化方向上探索，得出一个且可以解决业务问题的方案，虽然本质上还是没有逃离使用线程池的范畴，但是在成本和收益之间，算是取得了一个很好的平衡。成本在于实现动态化以及监控成本不高，收益在于：在不颠覆原有线程池使用方式的基础之上，从降低线程池参数修改的成本以及多维度监控这两个方面降低了故障发生的概率。希望本文提供的动态化线程池思路能对大家有帮助。', '![Java线程池实现原理及其在美团业务中的实践](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/912883e51327e0c7a9d753d11896326511272.png)', b'1', b'1', b'0', b'0', '2024-12-24 14:53:56', '2024-12-24 14:53:56', 0, 9870, 49, 10, b'0', '', 1);
INSERT INTO `blog` VALUES (17, 'Java魔法类：Unsafe应用解析', 'https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/f182555953e29cec76497ebaec526fd1297846.png', '## 前言\n\nUnsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此对Unsafe的使用一定要慎重。\n\n注：本文对sun.misc.Unsafe公共API功能及相关应用场景进行介绍。\n\n## 基本介绍\n\n如下Unsafe源码所示，Unsafe类为一单例实现，提供静态方法getUnsafe获取Unsafe实例，当且仅当调用getUnsafe方法的类为引导类加载器所加载时才合法，否则抛出SecurityException异常。\n\n```java\npublic final class Unsafe {\n  // 单例对象\n  private static final Unsafe theUnsafe;\n\n  private Unsafe() {\n  }\n  @CallerSensitive\n  public static Unsafe getUnsafe() {\n    Class var0 = Reflection.getCallerClass();\n    // 仅在引导类加载器`BootstrapClassLoader`加载时才合法\n    if(!VM.isSystemDomainLoader(var0.getClassLoader())) {    \n      throw new SecurityException(\"Unsafe\");\n    } else {\n      return theUnsafe;\n    }\n  }\n}\n```\n\n那如若想使用这个类，该如何获取其实例？有如下两个可行方案。\n\n其一，从`getUnsafe`方法的使用限制条件出发，通过Java命令行命令`-Xbootclasspath/a`把调用Unsafe相关方法的类A所在jar包路径追加到默认的bootstrap路径中，使得A被引导类加载器加载，从而通过`Unsafe.getUnsafe`方法安全的获取Unsafe实例。\n\n```bash\njava -Xbootclasspath/a: ${path}   // 其中path为调用Unsafe相关方法的类所在jar包路径\n```\n\n其二，通过反射获取单例对象theUnsafe。\n\n```java\nprivate static Unsafe reflectGetUnsafe() {\n    try {\n      Field field = Unsafe.class.getDeclaredField(\"theUnsafe\");\n      field.setAccessible(true);\n      return (Unsafe) field.get(null);\n    } catch (Exception e) {\n      log.error(e.getMessage(), e);\n      return null;\n    }\n}\n```\n\n## 功能介绍\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/f182555953e29cec76497ebaec526fd1297846.png)\n\n如上图所示，Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障、数组操作等几类，下面将对其相关方法和应用场景进行详细介绍。\n\n### 内存操作\n\n这部分主要包含堆外内存的分配、拷贝、释放、给定地址值操作等方法。\n\n```java\n//分配内存, 相当于C++的malloc函数\npublic native long allocateMemory(long bytes);\n//扩充内存\npublic native long reallocateMemory(long address, long bytes);\n//释放内存\npublic native void freeMemory(long address);\n//在给定的内存块中设置值\npublic native void setMemory(Object o, long offset, long bytes, byte value);\n//内存拷贝\npublic native void copyMemory(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes);\n//获取给定地址值，忽略修饰限定符的访问限制。与此类似操作还有: getInt，getDouble，getLong，getChar等\npublic native Object getObject(Object o, long offset);\n//为给定地址设置值，忽略修饰限定符的访问限制，与此类似操作还有: putInt,putDouble，putLong，putChar等\npublic native void putObject(Object o, long offset, Object x);\n//获取给定地址的byte类型的值（当且仅当该内存地址为allocateMemory分配时，此方法结果为确定的）\npublic native byte getByte(long address);\n//为给定地址设置byte类型的值（当且仅当该内存地址为allocateMemory分配时，此方法结果才是确定的）\npublic native void putByte(long address, byte x);\n```\n\n通常，我们在Java中创建的对象都处于堆内内存（heap）中，堆内内存是由JVM所管控的Java进程内存，并且它们遵循JVM的内存管理机制，JVM会采用垃圾回收机制统一管理堆内存。与之相对的是堆外内存，存在于JVM管控之外的内存区域，Java中对堆外内存的操作，依赖于Unsafe提供的操作堆外内存的native方法。\n\n#### 使用堆外内存的原因\n\n- 对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在GC时减少回收停顿对于应用的影响。\n- 提升程序I/O操作的性能。通常在I/O通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。\n\n#### 典型应用\n\nDirectByteBuffer是Java用于实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，如在Netty、MINA等NIO框架中应用广泛。DirectByteBuffer对于堆外内存的创建、使用、销毁等逻辑均由Unsafe提供的堆外内存API来实现。\n\n下图为DirectByteBuffer构造函数，创建DirectByteBuffer的时候，通过Unsafe.allocateMemory分配内存、Unsafe.setMemory进行内存初始化，而后构建Cleaner对象用于跟踪DirectByteBuffer对象的垃圾回收，以实现当DirectByteBuffer被垃圾回收时，分配的堆外内存一起被释放。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/5eb082d2e4baf2d993ce75747fc35de6486751.png)\n\n那么如何通过构建垃圾回收追踪对象Cleaner实现堆外内存释放呢？\n\nCleaner继承自Java四大引用类型之一的虚引用PhantomReference（众所周知，无法通过虚引用获取与之关联的对象实例，且当对象仅被虚引用引用时，在任何发生GC的时候，其均可被回收），通常PhantomReference与引用队列ReferenceQueue结合使用，可以实现虚引用关联对象被垃圾回收时能够进行系统通知、资源清理等功能。如下图所示，当某个被Cleaner引用的对象将被回收时，JVM垃圾收集器会将此对象的引用放入到对象引用中的pending链表中，等待Reference-Handler进行相关处理。其中，Reference-Handler为一个拥有最高优先级的守护线程，会循环不断的处理pending链表中的对象引用，执行Cleaner的clean方法进行相关清理工作。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/9efac865a875c32cf570489332be5d0f131298.png)\n\n所以当DirectByteBuffer仅被Cleaner引用（即为虚引用）时，其可以在任意GC时段被回收。当DirectByteBuffer实例对象被回收时，在Reference-Handler线程操作中，会调用Cleaner的clean方法根据创建Cleaner时传入的Deallocator来进行堆外内存的释放。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/66e616c6db18202578c561649facac8d387390.png)\n\n### CAS相关\n\n如下源代码释义所示，这部分主要为CAS相关操作的方法。\n\n```java\n/**\n	*  CAS\n  * @param o         包含要修改field的对象\n  * @param offset    对象中某field的偏移量\n  * @param expected  期望值\n  * @param update    更新值\n  * @return          true | false\n  */\npublic final native boolean compareAndSwapObject(Object o, long offset,  Object expected, Object update);\n\npublic final native boolean compareAndSwapInt(Object o, long offset, int expected,int update);\n  \npublic final native boolean compareAndSwapLong(Object o, long offset, long expected, long update);\n```\n\n什么是CAS? 即比较并替换，实现并发算法时常用到的一种技术。CAS操作包含三个操作数——内存位置、预期原值及新值。执行CAS操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。我们都知道，CAS是一条CPU的原子指令（cmpxchg指令），不会造成所谓的数据不一致问题，Unsafe提供的CAS方法（如compareAndSwapXXX）底层实现即为CPU指令cmpxchg。\n\n#### 典型应用\n\nCAS在java.util.concurrent.atomic相关类、Java AQS、CurrentHashMap等实现上有非常广泛的应用。如下图所示，AtomicInteger的实现中，静态字段valueOffset即为字段value的内存偏移地址，valueOffset的值在AtomicInteger初始化时，在静态代码块中通过Unsafe的objectFieldOffset方法获取。在AtomicInteger中提供的线程安全方法中，通过字段valueOffset的值可以定位到AtomicInteger对象中value的内存地址，从而可以根据CAS实现对value字段的原子操作。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/3bacb938ca6e63d6c79c2bb48d3f608f189412.png)\n\n下图为某个AtomicInteger对象自增操作前后的内存示意图，对象的基地址baseAddress=“0x110000”，通过baseAddress+valueOffset得到value的内存地址valueAddress=“0x11000c”；然后通过CAS进行原子性的更新操作，成功则返回，否则继续重试，直到更新成功为止。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/6e8b1fe5d5993d17a4c5b69bb72ac51d89826.png)\n\n### 线程调度\n\n这部分，包括线程挂起、恢复、锁机制等方法。\n\n```java\n//取消阻塞线程\npublic native void unpark(Object thread);\n//阻塞线程\npublic native void park(boolean isAbsolute, long time);\n//获得对象锁（可重入锁）\n@Deprecated\npublic native void monitorEnter(Object o);\n//释放对象锁\n@Deprecated\npublic native void monitorExit(Object o);\n//尝试获取对象锁\n@Deprecated\npublic native boolean tryMonitorEnter(Object o);\n```\n\n如上源码说明中，方法park、unpark即可实现线程的挂起与恢复，将一个线程进行挂起是通过park方法实现的，调用park方法后，线程将一直阻塞直到超时或者中断等条件出现；unpark可以终止一个挂起的线程，使其恢复正常。\n\n#### 典型应用\n\nJava锁和同步器框架的核心类AbstractQueuedSynchronizer，就是通过调用`LockSupport.park()`和`LockSupport.unpark()`实现线程的阻塞和唤醒的，而LockSupport的park、unpark方法实际是调用Unsafe的park、unpark方式来实现。\n\n### Class相关\n\n此部分主要提供Class和它的静态字段的操作相关方法，包含静态字段内存定位、定义类、定义匿名类、检验&确保初始化等。\n\n```java\n//获取给定静态字段的内存地址偏移量，这个值对于给定的字段是唯一且固定不变的\npublic native long staticFieldOffset(Field f);\n//获取一个静态类中给定字段的对象指针\npublic native Object staticFieldBase(Field f);\n//判断是否需要初始化一个类，通常在获取一个类的静态属性的时候（因为一个类如果没初始化，它的静态属性也不会初始化）使用。 当且仅当ensureClassInitialized方法不生效时返回false。\npublic native boolean shouldBeInitialized(Class<?> c);\n//检测给定的类是否已经初始化。通常在获取一个类的静态属性的时候（因为一个类如果没初始化，它的静态属性也不会初始化）使用。\npublic native void ensureClassInitialized(Class<?> c);\n//定义一个类，此方法会跳过JVM的所有安全检查，默认情况下，ClassLoader（类加载器）和ProtectionDomain（保护域）实例来源于调用者\npublic native Class<?> defineClass(String name, byte[] b, int off, int len, ClassLoader loader, ProtectionDomain protectionDomain);\n//定义一个匿名类\npublic native Class<?> defineAnonymousClass(Class<?> hostClass, byte[] data, Object[] cpPatches);\n```\n\n#### 典型应用\n\n从Java 8开始，JDK使用invokedynamic及VM Anonymous Class结合来实现Java语言层面上的Lambda表达式。\n\n- **invokedynamic**： invokedynamic是Java 7为了实现在JVM上运行动态语言而引入的一条新的虚拟机指令，它可以实现在运行期动态解析出调用点限定符所引用的方法，然后再执行该方法，invokedynamic指令的分派逻辑是由用户设定的引导方法决定。\n- **VM Anonymous Class**：可以看做是一种模板机制，针对于程序动态生成很多结构相同、仅若干常量不同的类时，可以先创建包含常量占位符的模板类，而后通过Unsafe.defineAnonymousClass方法定义具体类时填充模板的占位符生成具体的匿名类。生成的匿名类不显式挂在任何ClassLoader下面，只要当该类没有存在的实例对象、且没有强引用来引用该类的Class对象时，该类就会被GC回收。故而VM Anonymous Class相比于Java语言层面的匿名内部类无需通过ClassClassLoader进行类加载且更易回收。\n\n在Lambda表达式实现中，通过invokedynamic指令调用引导方法生成调用点，在此过程中，会通过ASM动态生成字节码，而后利用Unsafe的defineAnonymousClass方法定义实现相应的函数式接口的匿名类，然后再实例化此匿名类，并返回与此匿名类中函数式方法的方法句柄关联的调用点；而后可以通过此调用点实现调用相应Lambda表达式定义逻辑的功能。下面以如下图所示的Test类来举例说明。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/7707d035eb5f04314b3684ff91dddb1663516.png)\n\nTest类编译后的class文件反编译后的结果如下图一所示（删除了对本文说明无意义的部分），我们可以从中看到main方法的指令实现、invokedynamic指令调用的引导方法BootstrapMethods、及静态方法`lambda$main$0`（实现了Lambda表达式中字符串打印逻辑）等。在引导方法执行过程中，会通过Unsafe.defineAnonymousClass生成如下图二所示的实现Consumer接口的匿名类。其中，accept方法通过调用Test类中的静态方法`lambda$main$0`来实现Lambda表达式中定义的逻辑。而后执行语句`consumer.accept（\"lambda\"）`其实就是调用下图二所示的匿名类的accept方法。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/1038d53959701093db6c655e4a342e30456249.png)\n\n### 对象操作\n\n此部分主要包含对象成员属性相关操作及非常规的对象实例化方式等相关方法。\n\n```java\n//返回对象成员属性在内存地址相对于此对象的内存地址的偏移量\npublic native long objectFieldOffset(Field f);\n//获得给定对象的指定地址偏移量的值，与此类似操作还有：getInt，getDouble，getLong，getChar等\npublic native Object getObject(Object o, long offset);\n//给定对象的指定地址偏移量设值，与此类似操作还有：putInt，putDouble，putLong，putChar等\npublic native void putObject(Object o, long offset, Object x);\n//从对象的指定偏移量处获取变量的引用，使用volatile的加载语义\npublic native Object getObjectVolatile(Object o, long offset);\n//存储变量的引用到对象的指定的偏移量处，使用volatile的存储语义\npublic native void putObjectVolatile(Object o, long offset, Object x);\n//有序、延迟版本的putObjectVolatile方法，不保证值的改变被其他线程立即看到。只有在field被volatile修饰符修饰时有效\npublic native void putOrderedObject(Object o, long offset, Object x);\n//绕过构造方法、初始化代码来创建对象\npublic native Object allocateInstance(Class<?> cls) throws InstantiationException;\n```\n\n#### 典型应用\n\n- **常规对象实例化方式**：我们通常所用到的创建对象的方式，从本质上来讲，都是通过new机制来实现对象的创建。但是，new机制有个特点就是当类只提供有参的构造函数且无显示声明无参构造函数时，则必须使用有参构造函数进行对象构造，而使用有参构造函数时，必须传递相应个数的参数才能完成对象实例化。\n- **非常规的实例化方式**：而Unsafe中提供allocateInstance方法，仅通过Class对象就可以创建此类的实例对象，而且不需要调用其构造函数、初始化代码、JVM安全检查等。它抑制修饰符检测，也就是即使构造器是private修饰的也能通过此方法实例化，只需提类对象即可创建相应的对象。由于这种特性，allocateInstance在java.lang.invoke、Objenesis（提供绕过类构造器的对象生成方式）、Gson（反序列化时用到）中都有相应的应用。\n\n如下图所示，在Gson反序列化时，如果类有默认构造函数，则通过反射调用默认构造函数创建实例，否则通过UnsafeAllocator来实现对象实例的构造，UnsafeAllocator通过调用Unsafe的allocateInstance实现对象的实例化，保证在目标类无默认构造函数时，反序列化不够影响。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/b9fe6ab772d03f30cd48009920d56948514676.png)\n\n### 数组相关\n\n这部分主要介绍与数据操作相关的arrayBaseOffset与arrayIndexScale这两个方法，两者配合起来使用，即可定位数组中每个元素在内存中的位置。\n\n```java\n//返回数组中第一个元素的偏移地址\npublic native int arrayBaseOffset(Class<?> arrayClass);\n//返回数组中一个元素占用的大小\npublic native int arrayIndexScale(Class<?> arrayClass);\n```\n\n#### 典型应用\n\n这两个与数据操作相关的方法，在java.util.concurrent.atomic 包下的AtomicIntegerArray（可以实现对Integer数组中每个元素的原子性操作）中有典型的应用，如下图AtomicIntegerArray源码所示，通过Unsafe的arrayBaseOffset、arrayIndexScale分别获取数组首元素的偏移地址base及单个元素大小因子scale。后续相关原子性操作，均依赖于这两个值进行数组中元素的定位，如下图二所示的getAndAdd方法即通过checkedByteOffset方法获取某数组元素的偏移地址，而后通过CAS实现原子性操作。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/160366b0fb2079ad897f6d6b1cb349cd426237.png)\n\n### 内存屏障\n\n在Java 8中引入，用于定义内存屏障（也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作），避免代码重排序。\n\n```java\n//内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前\npublic native void loadFence();\n//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前\npublic native void storeFence();\n//内存屏障，禁止load、store操作重排序\npublic native void fullFence();\n```\n\n#### 典型应用\n\n在Java 8中引入了一种锁的新机制——StampedLock，它可以看成是读写锁的一个改进版本。StampedLock提供了一种乐观读锁的实现，这种乐观读锁类似于无锁的操作，完全不会阻塞写线程获取写锁，从而缓解读多写少时写线程“饥饿”现象。由于StampedLock提供的乐观读锁不阻塞写线程获取读锁，当线程共享变量从主内存load到线程工作内存时，会存在数据不一致问题，所以当使用StampedLock的乐观读锁时，需要遵从如下图用例中使用的模式来确保数据的一致性。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/839ad79686d06583296f3abf1bec27e3320222.png)\n\n如上图用例所示计算坐标点Point对象，包含点移动方法move及计算此点到原点的距离的方法distanceFromOrigin。在方法distanceFromOrigin中，首先，通过tryOptimisticRead方法获取乐观读标记；然后从主内存中加载点的坐标值 (x,y)；而后通过StampedLock的validate方法校验锁状态，判断坐标点(x,y)从主内存加载到线程工作内存过程中，主内存的值是否已被其他线程通过move方法修改，如果validate返回值为true，证明(x, y)的值未被修改，可参与后续计算；否则，需加悲观读锁，再次从主内存加载(x,y)的最新值，然后再进行距离计算。其中，校验锁状态这步操作至关重要，需要判断锁状态是否发生改变，从而判断之前copy到线程工作内存中的值是否与主内存的值存在不一致。\n\n下图为StampedLock.validate方法的源码实现，通过锁标记与相关常量进行位运算、比较来校验锁状态，在校验逻辑之前，会通过Unsafe的loadFence方法加入一个load内存屏障，目的是避免上图用例中步骤②和StampedLock.validate中锁状态校验运算发生重排序导致锁状态校验不准确的问题。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/256f54b037d07df53408b5eea9436b34135955.png)\n\n### 系统相关\n\n这部分包含两个获取系统相关信息的方法。\n\n```java\n//返回系统指针的大小。返回值为4（32位系统）或 8（64位系统）。\npublic native int addressSize();  \n//内存页的大小，此值为2的幂次方。\npublic native int pageSize();\n```\n\n#### 典型应用\n\n如下图所示的代码片段，为java.nio下的工具类Bits中计算待申请内存所需内存页数量的静态方法，其依赖于Unsafe中pageSize方法获取系统内存页大小实现后续计算逻辑。\n\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/262470b0c3e79b8f4f7b0c0280b1cc5362454.png)\n\n## 结语\n\n本文对Java中的sun.misc.Unsafe的用法及应用场景进行了基本介绍，我们可以看到Unsafe提供了很多便捷、有趣的API方法。即便如此，由于Unsafe中包含大量自主操作内存的方法，如若使用不当，会对程序带来许多不可控的灾难。因此对它的使用我们需要慎之又慎。', '![Java魔法类：Unsafe应用解析](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/f182555953e29cec76497ebaec526fd1297846.png)', b'1', b'1', b'0', b'0', '2024-12-24 14:57:53', '2024-12-24 14:57:53', 0, 5376, 27, 10, b'0', '', 1);

-- ----------------------------
-- Table structure for blog_tag
-- ----------------------------
DROP TABLE IF EXISTS `blog_tag`;
CREATE TABLE `blog_tag`  (
  `blog_id` bigint NOT NULL,
  `tag_id` bigint NOT NULL
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of blog_tag
-- ----------------------------
INSERT INTO `blog_tag` VALUES (6, 1);
INSERT INTO `blog_tag` VALUES (5, 2);
INSERT INTO `blog_tag` VALUES (8, 2);
INSERT INTO `blog_tag` VALUES (9, 2);
INSERT INTO `blog_tag` VALUES (7, 5);
INSERT INTO `blog_tag` VALUES (7, 6);
INSERT INTO `blog_tag` VALUES (10, 2);
INSERT INTO `blog_tag` VALUES (11, 2);
INSERT INTO `blog_tag` VALUES (12, 2);
INSERT INTO `blog_tag` VALUES (13, 2);
INSERT INTO `blog_tag` VALUES (14, 2);
INSERT INTO `blog_tag` VALUES (15, 2);
INSERT INTO `blog_tag` VALUES (16, 2);
INSERT INTO `blog_tag` VALUES (17, 2);

-- ----------------------------
-- Table structure for category
-- ----------------------------
DROP TABLE IF EXISTS `category`;
CREATE TABLE `category`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `category_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 16 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of category
-- ----------------------------
INSERT INTO `category` VALUES (10, '专栏');
INSERT INTO `category` VALUES (12, '其他');
INSERT INTO `category` VALUES (13, '文章');
INSERT INTO `category` VALUES (14, '后端');
INSERT INTO `category` VALUES (15, '前端');

-- ----------------------------
-- Table structure for city_visitor
-- ----------------------------
DROP TABLE IF EXISTS `city_visitor`;
CREATE TABLE `city_visitor`  (
  `city` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '城市名称',
  `uv` int NOT NULL COMMENT '独立访客数量',
  PRIMARY KEY (`city`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of city_visitor
-- ----------------------------

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `nickname` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '昵称',
  `email` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '邮箱',
  `content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '评论内容',
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '头像(图片路径)',
  `create_time` datetime NULL DEFAULT NULL COMMENT '评论时间',
  `ip` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '评论者ip地址',
  `is_published` bit(1) NOT NULL COMMENT '公开或回收站',
  `is_admin_comment` bit(1) NOT NULL COMMENT '博主回复',
  `page` int NOT NULL COMMENT '0普通文章，1关于我页面，2友链页面',
  `is_notice` bit(1) NOT NULL COMMENT '接收邮件提醒',
  `blog_id` bigint NULL DEFAULT NULL COMMENT '所属的文章',
  `parent_comment_id` bigint NOT NULL COMMENT '父评论id，-1为根评论',
  `website` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '个人网站',
  `qq` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '如果评论昵称为QQ号，则将昵称和头像置为QQ昵称和QQ头像，并将此字段置为QQ号备份',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of comment
-- ----------------------------

-- ----------------------------
-- Table structure for exception_log
-- ----------------------------
DROP TABLE IF EXISTS `exception_log`;
CREATE TABLE `exception_log`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `uri` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '请求接口',
  `method` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '请求方式',
  `param` varchar(2000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '请求参数',
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '操作描述',
  `error` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '异常信息',
  `ip` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'ip',
  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'ip来源',
  `os` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '操作系统',
  `browser` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '浏览器',
  `create_time` datetime NOT NULL COMMENT '操作时间',
  `user_agent` varchar(2000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'user-agent用户代理',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of exception_log
-- ----------------------------
INSERT INTO `exception_log` VALUES (1, '/blog', 'GET', '{\"id\":3}', '查看博客', 'top.naccl.exception.NotFoundException: 该博客不存在\r\n	at top.naccl.service.impl.BlogServiceImpl.getBlogByIdAndIsPublished(BlogServiceImpl.java:358)\r\n	at top.naccl.service.impl.BlogServiceImpl$$FastClassBySpringCGLIB$$5890a2ac.invoke(<generated>)\r\n	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\r\n	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:687)\r\n	at top.naccl.service.impl.BlogServiceImpl$$EnhancerBySpringCGLIB$$4d07b227.getBlogByIdAndIsPublished(<generated>)\r\n	at top.naccl.controller.BlogController.getBlog(BlogController.java:63)\r\n	at top.naccl.controller.BlogController$$FastClassBySpringCGLIB$$942814c2.invoke(<generated>)\r\n	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:771)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:88)\r\n	at top.naccl.aspect.VisitLogAspect.logAround(VisitLogAspect.java:67)\r\n	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\r\n	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n	at java.base/java.lang.reflect.Method.invoke(Method.java:568)\r\n	at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:644)\r\n	at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:633)\r\n	at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:70)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:62)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:95)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691)\r\n	at top.naccl.controller.BlogController$$EnhancerBySpringCGLIB$$bb442eb0.getBlog(<generated>)\r\n	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\r\n	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n	at java.base/java.lang.reflect.Method.invoke(Method.java:568)\r\n	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190)\r\n	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138)\r\n	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105)\r\n	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:879)\r\n	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793)\r\n	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\r\n	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040)\r\n	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)\r\n	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)\r\n	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898)\r\n	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634)\r\n	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)\r\n	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:320)\r\n	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:126)\r\n	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:90)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:118)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:158)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at top.naccl.config.JwtFilter.doFilter(JwtFilter.java:35)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:200)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.web.filter.CorsFilter.doFilterInternal(CorsFilter.java:92)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:92)\r\n	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:77)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:215)\r\n	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178)\r\n	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358)\r\n	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)\r\n	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)\r\n	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541)\r\n	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139)\r\n	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\r\n	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)\r\n	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)\r\n	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373)\r\n	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\r\n	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868)\r\n	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1590)\r\n	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\r\n	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)\r\n	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)\r\n	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\r\n	at java.base/java.lang.Thread.run(Thread.java:842)\r\n', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', '2024-12-18 13:58:28', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `exception_log` VALUES (2, '/blog', 'GET', '{\"id\":3}', '查看博客', 'top.naccl.exception.NotFoundException: 该博客不存在\r\n	at top.naccl.service.impl.BlogServiceImpl.getBlogByIdAndIsPublished(BlogServiceImpl.java:358)\r\n	at top.naccl.service.impl.BlogServiceImpl$$FastClassBySpringCGLIB$$5890a2ac.invoke(<generated>)\r\n	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\r\n	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:687)\r\n	at top.naccl.service.impl.BlogServiceImpl$$EnhancerBySpringCGLIB$$4d07b227.getBlogByIdAndIsPublished(<generated>)\r\n	at top.naccl.controller.BlogController.getBlog(BlogController.java:63)\r\n	at top.naccl.controller.BlogController$$FastClassBySpringCGLIB$$942814c2.invoke(<generated>)\r\n	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:771)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:88)\r\n	at top.naccl.aspect.VisitLogAspect.logAround(VisitLogAspect.java:67)\r\n	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\r\n	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n	at java.base/java.lang.reflect.Method.invoke(Method.java:568)\r\n	at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:644)\r\n	at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:633)\r\n	at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:70)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:62)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:95)\r\n	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\n	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\n	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691)\r\n	at top.naccl.controller.BlogController$$EnhancerBySpringCGLIB$$bb442eb0.getBlog(<generated>)\r\n	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\r\n	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n	at java.base/java.lang.reflect.Method.invoke(Method.java:568)\r\n	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190)\r\n	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138)\r\n	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105)\r\n	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:879)\r\n	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793)\r\n	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\r\n	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040)\r\n	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)\r\n	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)\r\n	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898)\r\n	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634)\r\n	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)\r\n	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:320)\r\n	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:126)\r\n	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:90)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:118)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:158)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at top.naccl.config.JwtFilter.doFilter(JwtFilter.java:35)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:200)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.web.filter.CorsFilter.doFilterInternal(CorsFilter.java:92)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:92)\r\n	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:77)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\r\n	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:215)\r\n	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178)\r\n	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358)\r\n	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\r\n	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\r\n	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\r\n	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)\r\n	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)\r\n	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541)\r\n	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139)\r\n	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\r\n	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)\r\n	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)\r\n	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373)\r\n	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\r\n	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868)\r\n	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1590)\r\n	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\r\n	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)\r\n	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)\r\n	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\r\n	at java.base/java.lang.Thread.run(Thread.java:842)\r\n', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', '2024-12-18 13:58:41', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');

-- ----------------------------
-- Table structure for friend
-- ----------------------------
DROP TABLE IF EXISTS `friend`;
CREATE TABLE `friend`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `nickname` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '昵称',
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '描述',
  `website` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '站点',
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '头像',
  `is_published` bit(1) NOT NULL COMMENT '公开或隐藏',
  `views` int NOT NULL COMMENT '点击次数',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of friend
-- ----------------------------

-- ----------------------------
-- Table structure for login_log
-- ----------------------------
DROP TABLE IF EXISTS `login_log`;
CREATE TABLE `login_log`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `username` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '用户名称',
  `ip` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'ip',
  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'ip来源',
  `os` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '操作系统',
  `browser` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '浏览器',
  `status` bit(1) NULL DEFAULT NULL COMMENT '登录状态',
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '操作描述',
  `create_time` datetime NOT NULL COMMENT '登录时间',
  `user_agent` varchar(2000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'user-agent用户代理',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 10 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of login_log
-- ----------------------------
INSERT INTO `login_log` VALUES (1, 'Admin', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', b'1', '登录成功', '2024-12-17 15:04:05', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `login_log` VALUES (2, 'admin', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', b'1', '登录成功', '2024-12-17 15:32:35', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `login_log` VALUES (3, 'admin', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', b'1', '登录成功', '2024-12-18 08:37:28', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `login_log` VALUES (4, 'admin', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', b'1', '登录成功', '2024-12-18 09:45:06', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `login_log` VALUES (5, 'admin', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', b'1', '登录成功', '2024-12-18 11:04:50', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `login_log` VALUES (6, 'admin', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', b'1', '登录成功', '2024-12-20 16:03:09', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `login_log` VALUES (7, 'admin', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', b'1', '登录成功', '2024-12-23 10:39:57', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `login_log` VALUES (8, 'admin', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', b'1', '登录成功', '2024-12-24 09:54:22', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `login_log` VALUES (9, 'admin', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 134', b'1', '登录成功', '2025-03-20 15:08:25', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36');

-- ----------------------------
-- Table structure for moment
-- ----------------------------
DROP TABLE IF EXISTS `moment`;
CREATE TABLE `moment`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '动态内容',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `likes` int NULL DEFAULT NULL COMMENT '点赞数量',
  `is_published` bit(1) NOT NULL COMMENT '是否公开',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of moment
-- ----------------------------

-- ----------------------------
-- Table structure for operation_log
-- ----------------------------
DROP TABLE IF EXISTS `operation_log`;
CREATE TABLE `operation_log`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `username` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '操作者用户名',
  `uri` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '请求接口',
  `method` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '请求方式',
  `param` varchar(2000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '请求参数',
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '操作描述',
  `ip` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'ip',
  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'ip来源',
  `os` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '操作系统',
  `browser` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '浏览器',
  `times` int NOT NULL COMMENT '请求耗时（毫秒）',
  `create_time` datetime NOT NULL COMMENT '操作时间',
  `user_agent` varchar(2000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'user-agent用户代理',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 110 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of operation_log
-- ----------------------------
INSERT INTO `operation_log` VALUES (1, 'Admin', '/admin/siteSettings', 'POST', '{\"map\":{\"settings\":[{\"id\":1,\"nameEn\":\"blogName\",\"nameZh\":\"博客名称\",\"value\":\"Youta\'s Blog\",\"type\":1},{\"id\":2,\"nameEn\":\"webTitleSuffix\",\"nameZh\":\"网页标题后缀\",\"value\":\" - Youta\'s Blog\",\"type\":1},{\"id\":3,\"nameEn\":\"footerImgTitle\",\"nameZh\":\"页脚图片标题\",\"value\":\"手机看本站\",\"type\":1},{\"id\":4,\"nameEn\":\"footerImgUrl\",\"nameZh\":\"页脚图片路径\",\"value\":\"/img/qr.png\",\"type\":1},{\"id\":5,\"nameEn\":\"copyright\",\"nameZh\":\"Copyright\",\"value\":\"{\\\"title\\\":\\\"Copyright © 2024 - 2025\\\",\\\"siteName\\\":\\\"YOUTA\'S BLOG\\\"}\",\"type\":1},{\"id\":6,\"nameEn\":\"beian\",\"nameZh\":\"ICP备案号\",\"value\":\"\",\"type\":1},{\"id\":7,\"nameEn\":\"reward\",\"nameZh\":\"赞赏码\",\"value\":\"/img/reward.jpg\",\"type\":1},{\"id\":8,\"nameEn\":\"commentAdminFlag\",\"nameZh\":\"博主评论标识\",\"value\":\"咕咕\",\"type\":1},{\"id\":9,\"nameEn\":\"playlistServer\",\"nameZh\":\"播放器平台\",\"value\":\"netease\",\"type\":1},{\"id\":10,\"nameEn\":\"playlistId\",\"nameZh\":\"播放器歌单\",\"value\":\"3071528549\",\"type\":1},{\"id\":11,\"nameEn\":\"avatar\",\"nameZh\":\"头像\",\"value\":\"/img/avatar.jpg\",\"type\":2},{\"id\":12,\"nameEn\":\"name\",\"nameZh\":\"昵称\",\"value\":\"Youta\",\"type\":2},{\"id\":13,\"nameEn\":\"rollText\",\"nameZh\":\"滚动个签\",\"value\":\"\\\"云鹤当归天，天不迎我妙木仙；\\\",\\\"游龙当归海，海不迎我自来也。\\\"\",\"type\":2},{\"id\":14,\"nameEn\":\"github\",\"nameZh\":\"GitHub\",\"value\":\"https://github.com/\",\"type\":2},{\"id\":15,\"nameEn\":\"telegram\",\"nameZh\":\"Telegram\",\"value\":\"https://t.me/\",\"type\":2},{\"id\":16,\"nameEn\":\"qq\",\"nameZh\":\"QQ\",\"value\":\"http://sighttp.qq.com/authd?IDKEY=\",\"type\":2},{\"id\":17,\"nameEn\":\"bilibili\",\"nameZh\":\"bilibili\",\"value\":\"https://space.bilibili.com/\",\"type\":2},{\"id\":18,\"nameEn\":\"netease\",\"nameZh\":\"网易云音乐\",\"value\":\"https://music.163.com/#/user/home?id=\",\"type\":2},{\"id\":19,\"nameEn\":\"email\",\"nameZh\":\"email\",\"value\":\"mailto:youta@163.com\",\"type\":2},{\"id\":20,\"nameEn\":\"favorite\",\"nameZh\":\"自定义\",\"value\":\"{\\\"title\\\":\\\"最喜欢的动漫 📺\\\",\\\"content\\\":\\\"异度侵入、春物语、NO GAME NO LIFE、实力至上主义的教室、辉夜大小姐、青春猪头少年不会梦到兔女郎学姐、路人女主、Re0、魔禁、超炮、俺妹、在下坂本、散华礼弥、OVERLORD、慎勇、人渣的本愿、白色相簿2、死亡笔记、DARLING in the FRANXX、鬼灭之刃\\\"}\",\"type\":2},{\"id\":21,\"nameEn\":\"favorite\",\"nameZh\":\"自定义\",\"value\":\"{\\\"title\\\":\\\"最喜欢我的女孩子们 🤤\\\",\\\"content\\\":\\\"芙兰达、土间埋、', '更新站点配置信息', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 30, '2024-12-17 15:05:50', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (2, 'admin', '/admin/blog', 'POST', '{\"blog\":{\"id\":null,\"title\":\"ElasticSearch 小白从入门到精通\",\"firstPicture\":\"/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.png\",\"content\":\"# ElasticSearch 小白从入门到精通\\n\\n### 什么是 ElasticSearch\\n\\nElasticSearch 简称为 ES，网址为：\\n\\n> https://www.elastic.co/\\n\\nES 是一个分布式的开源搜索和分析引擎，适用于文本、数字、地理空间、结构化数据、非结构化数据等数据的搜索。ES 是在 Apache Lucene 的基础上完成开发。由 Elastic 于 2010 年发布。ES 通过其简单的 REST 风格的 API、分布式特性、速度和可扩容闻名世界。是 Elastic Stack 的核心组件。Elastic Stack 是一套用于数据采集、扩充、保存、分析、可视化的开源工具。Elastic Stack 称之为 ELK。目前 ELK 包含一系列丰富的轻量数据采集代理，这些代理被称之为 Beats。\\n\\n#### ES 的用途\\n\\n主要有以下的用途：\\n\\n- 应用程序搜索\\n- 网站搜索\\n- 企业搜索\\n- 日志处理\\n- 基础设施指标和容器监测\\n- 应用程序性能监测\\n- 地理空间数据分析和可视化\\n- 安全分析\\n- 业务分析\\n\\n#### 工作原理\\n\\n从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，在 Kibana 中，用户可以创建数据可视化面板，并对 ELK 进行管理。\\n\\n#### 索引\\n\\nES 索引是指相互关联的文档集合。ES 是会以 JSON 文档的形式保存数据，每个文档都会在一组键值对中建立联系。\\n\\nES 使用的是一种倒排序索引的数据结构。这个结构可以允许十分快速的进行全文本的搜索。\\n\\n在索引的过程中，ES 会保存文档并构建倒排序索引，这样用户就可以实时的对文档数据进行搜索。索引是在添加过程中就启动的。\\n\\n#### Logstash\\n\\nLogstash 是 ELK 的核心菜品，可以对数据进行聚合和处理。并将数据发送到 ES 中。Logstash 是一个开源的服务器端数据处理管道。\\n\\n#### Kibana\\n\\nKibana 是一款 ES 的数据可视化和管理工具，可以提供直方图，线形图，饼状图，地图。Kibana 还包含 Canvas 和 Elastic Maps 等应用程序。Canvas 可以基于用户创建动态信息。Elastic Maps 可以对空间数据进行可视化处理。\\n\\n#### 为什么要使用 ES\\n\\n- **ES 很快**：ES 是在 Lucene 基础上构建，所以全文本搜索相当的出色。ES 还是一个实时搜索平台。文档索引操作到文档变为可搜索之间速度很快。\\n- **ES 具有分布式的特征**：ES 中保存的文档分布在不同的容器中，这些容器为分片，可以对分片进行复制并形成冗余副本。ES 可以扩充到数百台，并处理 PB 级别的数据。\\n- **ES 包含一系列广泛的功能**：ES 拥有大量的内置功能，方便用户管理数据。\\n- **ES 简化了数据采集，可视化报告的过程**：通过与 Beats 和 Logstash 集成，用户可以在 ES 中索引数据并处理数据，\\n\\n### ES 搭建\\n\\n安装镜像：\\n\\n```\\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n启动容器：\\n\\n```\\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \\\"discovery.type=single-node\\\" docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n修改配置：\\n\\n```\\n#进入 docker 容器内部\\n\\ndocker exec -it es /bin/bash\\n\\n#打开配置文件\\n\\nvim config/elasticsearch.yml\\n\\n### 加入跨域配置\\n\\nhttp.cors.enabled: true\\n\\nhttp.cors.allow-origin: \\\"*\\\"\\n```\\n\\n进入容器，安装分词器：\\n\\n```\\ndocker exec -it es /bin/bash\\n.', '发布博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-17 16:08:22', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (3, 'admin', '/admin/category', 'POST', '{\"category\":{\"id\":1,\"name\":\"专栏\",\"blogs\":[]}}', '添加分类', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 69, '2024-12-17 16:53:45', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (4, 'admin', '/admin/tag', 'POST', '{\"tag\":{\"id\":1,\"name\":\"ElasticSearch\",\"color\":\"teal\",\"blogs\":[]}}', '添加标签', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-17 16:53:59', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (5, 'admin', '/admin/category', 'POST', '{\"category\":{\"id\":2,\"name\":\"Java\",\"blogs\":[]}}', '添加分类', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-17 16:54:30', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (6, 'admin', '/admin/category', 'POST', '{\"category\":{\"id\":3,\"name\":\"Python\",\"blogs\":[]}}', '添加分类', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-17 16:54:37', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (7, 'admin', '/admin/category', 'DELETE', '{\"id\":2}', '删除分类', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-17 16:54:50', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (8, 'admin', '/admin/category', 'DELETE', '{\"id\":3}', '删除分类', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-17 16:54:52', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (9, 'admin', '/admin/category', 'POST', '{\"category\":{\"id\":4,\"name\":\"前端\",\"blogs\":[]}}', '添加分类', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 10, '2024-12-17 16:54:58', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (10, 'admin', '/admin/category', 'POST', '{\"category\":{\"id\":5,\"name\":\"后端\",\"blogs\":[]}}', '添加分类', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-17 16:55:04', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (11, 'admin', '/admin/category', 'POST', '{\"category\":{\"id\":6,\"name\":\"其他\",\"blogs\":[]}}', '添加分类', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-17 16:55:33', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (12, 'admin', '/admin/category', 'POST', '{\"category\":{\"id\":7,\"name\":\"技术文章\",\"blogs\":[]}}', '添加分类', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-17 16:55:49', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (13, 'admin', '/admin/tag', 'POST', '{\"tag\":{\"id\":2,\"name\":\"Java\",\"color\":\"red\",\"blogs\":[]}}', '添加标签', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-17 16:56:00', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (14, 'admin', '/admin/tag', 'POST', '{\"tag\":{\"id\":3,\"name\":\"Python\",\"color\":\"blue\",\"blogs\":[]}}', '添加标签', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 12, '2024-12-17 16:56:09', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (15, 'admin', '/admin/tag', 'POST', '{\"tag\":{\"id\":4,\"name\":\"mysql\",\"color\":\"purple\",\"blogs\":[]}}', '添加标签', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-17 16:56:19', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (16, 'admin', '/admin/blog', 'POST', '{\"blog\":{\"id\":null,\"title\":\"ElasticSearch 小白从入门到精通\",\"firstPicture\":\"/专栏/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.png\",\"content\":\"### 什么是 ElasticSearch\\n\\nElasticSearch 简称为 ES，网址为：\\n\\n> https://www.elastic.co/\\n\\nES 是一个分布式的开源搜索和分析引擎，适用于文本、数字、地理空间、结构化数据、非结构化数据等数据的搜索。ES 是在 Apache Lucene 的基础上完成开发。由 Elastic 于 2010 年发布。ES 通过其简单的 REST 风格的 API、分布式特性、速度和可扩容闻名世界。是 Elastic Stack 的核心组件。Elastic Stack 是一套用于数据采集、扩充、保存、分析、可视化的开源工具。Elastic Stack 称之为 ELK。目前 ELK 包含一系列丰富的轻量数据采集代理，这些代理被称之为 Beats。\\n\\n#### ES 的用途\\n\\n主要有以下的用途：\\n\\n- 应用程序搜索\\n- 网站搜索\\n- 企业搜索\\n- 日志处理\\n- 基础设施指标和容器监测\\n- 应用程序性能监测\\n- 地理空间数据分析和可视化\\n- 安全分析\\n- 业务分析\\n\\n#### 工作原理\\n\\n从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，在 Kibana 中，用户可以创建数据可视化面板，并对 ELK 进行管理。\\n\\n#### 索引\\n\\nES 索引是指相互关联的文档集合。ES 是会以 JSON 文档的形式保存数据，每个文档都会在一组键值对中建立联系。\\n\\nES 使用的是一种倒排序索引的数据结构。这个结构可以允许十分快速的进行全文本的搜索。\\n\\n在索引的过程中，ES 会保存文档并构建倒排序索引，这样用户就可以实时的对文档数据进行搜索。索引是在添加过程中就启动的。\\n\\n#### Logstash\\n\\nLogstash 是 ELK 的核心菜品，可以对数据进行聚合和处理。并将数据发送到 ES 中。Logstash 是一个开源的服务器端数据处理管道。\\n\\n#### Kibana\\n\\nKibana 是一款 ES 的数据可视化和管理工具，可以提供直方图，线形图，饼状图，地图。Kibana 还包含 Canvas 和 Elastic Maps 等应用程序。Canvas 可以基于用户创建动态信息。Elastic Maps 可以对空间数据进行可视化处理。\\n\\n#### 为什么要使用 ES\\n\\n- **ES 很快**：ES 是在 Lucene 基础上构建，所以全文本搜索相当的出色。ES 还是一个实时搜索平台。文档索引操作到文档变为可搜索之间速度很快。\\n- **ES 具有分布式的特征**：ES 中保存的文档分布在不同的容器中，这些容器为分片，可以对分片进行复制并形成冗余副本。ES 可以扩充到数百台，并处理 PB 级别的数据。\\n- **ES 包含一系列广泛的功能**：ES 拥有大量的内置功能，方便用户管理数据。\\n- **ES 简化了数据采集，可视化报告的过程**：通过与 Beats 和 Logstash 集成，用户可以在 ES 中索引数据并处理数据，\\n\\n### ES 搭建\\n\\n安装镜像：\\n\\n```\\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n启动容器：\\n\\n```\\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \\\"discovery.type=single-node\\\" docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n修改配置：\\n\\n```\\n#进入 docker 容器内部\\n\\ndocker exec -it es /bin/bash\\n\\n#打开配置文件\\n\\nvim config/elasticsearch.yml\\n\\n### 加入跨域配置\\n\\nhttp.cors.enabled: true\\n\\nhttp.cors.allow-origin: \\\"*\\\"\\n```\\n\\n进入容器，安装分词器：\\n\\n```\\ndocker exec -it es /bin/bash\\n./bin/elasticsearch-plugin', '发布博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 0, '2024-12-17 16:57:54', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (17, 'admin', '/admin/blog', 'POST', '{\"blog\":{\"id\":null,\"title\":\"ElasticSearch 小白从入门到精通\",\"firstPicture\":\"/专栏/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.png\",\"content\":\"### 什么是 ElasticSearch\\n\\nElasticSearch 简称为 ES，网址为：\\n\\n> https://www.elastic.co/\\n\\nES 是一个分布式的开源搜索和分析引擎，适用于文本、数字、地理空间、结构化数据、非结构化数据等数据的搜索。ES 是在 Apache Lucene 的基础上完成开发。由 Elastic 于 2010 年发布。ES 通过其简单的 REST 风格的 API、分布式特性、速度和可扩容闻名世界。是 Elastic Stack 的核心组件。Elastic Stack 是一套用于数据采集、扩充、保存、分析、可视化的开源工具。Elastic Stack 称之为 ELK。目前 ELK 包含一系列丰富的轻量数据采集代理，这些代理被称之为 Beats。\\n\\n#### ES 的用途\\n\\n主要有以下的用途：\\n\\n- 应用程序搜索\\n- 网站搜索\\n- 企业搜索\\n- 日志处理\\n- 基础设施指标和容器监测\\n- 应用程序性能监测\\n- 地理空间数据分析和可视化\\n- 安全分析\\n- 业务分析\\n\\n#### 工作原理\\n\\n从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，在 Kibana 中，用户可以创建数据可视化面板，并对 ELK 进行管理。\\n\\n#### 索引\\n\\nES 索引是指相互关联的文档集合。ES 是会以 JSON 文档的形式保存数据，每个文档都会在一组键值对中建立联系。\\n\\nES 使用的是一种倒排序索引的数据结构。这个结构可以允许十分快速的进行全文本的搜索。\\n\\n在索引的过程中，ES 会保存文档并构建倒排序索引，这样用户就可以实时的对文档数据进行搜索。索引是在添加过程中就启动的。\\n\\n#### Logstash\\n\\nLogstash 是 ELK 的核心菜品，可以对数据进行聚合和处理。并将数据发送到 ES 中。Logstash 是一个开源的服务器端数据处理管道。\\n\\n#### Kibana\\n\\nKibana 是一款 ES 的数据可视化和管理工具，可以提供直方图，线形图，饼状图，地图。Kibana 还包含 Canvas 和 Elastic Maps 等应用程序。Canvas 可以基于用户创建动态信息。Elastic Maps 可以对空间数据进行可视化处理。\\n\\n#### 为什么要使用 ES\\n\\n- **ES 很快**：ES 是在 Lucene 基础上构建，所以全文本搜索相当的出色。ES 还是一个实时搜索平台。文档索引操作到文档变为可搜索之间速度很快。\\n- **ES 具有分布式的特征**：ES 中保存的文档分布在不同的容器中，这些容器为分片，可以对分片进行复制并形成冗余副本。ES 可以扩充到数百台，并处理 PB 级别的数据。\\n- **ES 包含一系列广泛的功能**：ES 拥有大量的内置功能，方便用户管理数据。\\n- **ES 简化了数据采集，可视化报告的过程**：通过与 Beats 和 Logstash 集成，用户可以在 ES 中索引数据并处理数据，\\n\\n### ES 搭建\\n\\n安装镜像：\\n\\n```\\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n启动容器：\\n\\n```\\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \\\"discovery.type=single-node\\\" docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n修改配置：\\n\\n```\\n#进入 docker 容器内部\\n\\ndocker exec -it es /bin/bash\\n\\n#打开配置文件\\n\\nvim config/elasticsearch.yml\\n\\n### 加入跨域配置\\n\\nhttp.cors.enabled: true\\n\\nhttp.cors.allow-origin: \\\"*\\\"\\n```\\n\\n进入容器，安装分词器：\\n\\n```\\ndocker exec -it es /bin/bash\\n./bin/elasticsearch-plugin', '发布博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 0, '2024-12-17 16:57:56', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (18, 'admin', '/admin/blog', 'POST', '{\"blog\":{\"id\":null,\"title\":\"ElasticSearch 小白从入门到精通\",\"firstPicture\":\"./专栏/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.png\",\"content\":\"### 什么是 ElasticSearch\\n\\nElasticSearch 简称为 ES，网址为：\\n\\n> https://www.elastic.co/\\n\\nES 是一个分布式的开源搜索和分析引擎，适用于文本、数字、地理空间、结构化数据、非结构化数据等数据的搜索。ES 是在 Apache Lucene 的基础上完成开发。由 Elastic 于 2010 年发布。ES 通过其简单的 REST 风格的 API、分布式特性、速度和可扩容闻名世界。是 Elastic Stack 的核心组件。Elastic Stack 是一套用于数据采集、扩充、保存、分析、可视化的开源工具。Elastic Stack 称之为 ELK。目前 ELK 包含一系列丰富的轻量数据采集代理，这些代理被称之为 Beats。\\n\\n#### ES 的用途\\n\\n主要有以下的用途：\\n\\n- 应用程序搜索\\n- 网站搜索\\n- 企业搜索\\n- 日志处理\\n- 基础设施指标和容器监测\\n- 应用程序性能监测\\n- 地理空间数据分析和可视化\\n- 安全分析\\n- 业务分析\\n\\n#### 工作原理\\n\\n从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，在 Kibana 中，用户可以创建数据可视化面板，并对 ELK 进行管理。\\n\\n#### 索引\\n\\nES 索引是指相互关联的文档集合。ES 是会以 JSON 文档的形式保存数据，每个文档都会在一组键值对中建立联系。\\n\\nES 使用的是一种倒排序索引的数据结构。这个结构可以允许十分快速的进行全文本的搜索。\\n\\n在索引的过程中，ES 会保存文档并构建倒排序索引，这样用户就可以实时的对文档数据进行搜索。索引是在添加过程中就启动的。\\n\\n#### Logstash\\n\\nLogstash 是 ELK 的核心菜品，可以对数据进行聚合和处理。并将数据发送到 ES 中。Logstash 是一个开源的服务器端数据处理管道。\\n\\n#### Kibana\\n\\nKibana 是一款 ES 的数据可视化和管理工具，可以提供直方图，线形图，饼状图，地图。Kibana 还包含 Canvas 和 Elastic Maps 等应用程序。Canvas 可以基于用户创建动态信息。Elastic Maps 可以对空间数据进行可视化处理。\\n\\n#### 为什么要使用 ES\\n\\n- **ES 很快**：ES 是在 Lucene 基础上构建，所以全文本搜索相当的出色。ES 还是一个实时搜索平台。文档索引操作到文档变为可搜索之间速度很快。\\n- **ES 具有分布式的特征**：ES 中保存的文档分布在不同的容器中，这些容器为分片，可以对分片进行复制并形成冗余副本。ES 可以扩充到数百台，并处理 PB 级别的数据。\\n- **ES 包含一系列广泛的功能**：ES 拥有大量的内置功能，方便用户管理数据。\\n- **ES 简化了数据采集，可视化报告的过程**：通过与 Beats 和 Logstash 集成，用户可以在 ES 中索引数据并处理数据，\\n\\n### ES 搭建\\n\\n安装镜像：\\n\\n```\\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n启动容器：\\n\\n```\\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \\\"discovery.type=single-node\\\" docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n修改配置：\\n\\n```\\n#进入 docker 容器内部\\n\\ndocker exec -it es /bin/bash\\n\\n#打开配置文件\\n\\nvim config/elasticsearch.yml\\n\\n### 加入跨域配置\\n\\nhttp.cors.enabled: true\\n\\nhttp.cors.allow-origin: \\\"*\\\"\\n```\\n\\n进入容器，安装分词器：\\n\\n```\\ndocker exec -it es /bin/bash\\n./bin/elasticsearch-plugi', '发布博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 0, '2024-12-17 16:58:16', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (19, 'admin', '/admin/blog', 'POST', '{\"blog\":{\"id\":null,\"title\":\"ElasticSearch 小白从入门到精通\",\"firstPicture\":\"专栏/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.png\",\"content\":\"### 什么是 ElasticSearch\\n\\nElasticSearch 简称为 ES，网址为：\\n\\n> https://www.elastic.co/\\n\\nES 是一个分布式的开源搜索和分析引擎，适用于文本、数字、地理空间、结构化数据、非结构化数据等数据的搜索。ES 是在 Apache Lucene 的基础上完成开发。由 Elastic 于 2010 年发布。ES 通过其简单的 REST 风格的 API、分布式特性、速度和可扩容闻名世界。是 Elastic Stack 的核心组件。Elastic Stack 是一套用于数据采集、扩充、保存、分析、可视化的开源工具。Elastic Stack 称之为 ELK。目前 ELK 包含一系列丰富的轻量数据采集代理，这些代理被称之为 Beats。\\n\\n#### ES 的用途\\n\\n主要有以下的用途：\\n\\n- 应用程序搜索\\n- 网站搜索\\n- 企业搜索\\n- 日志处理\\n- 基础设施指标和容器监测\\n- 应用程序性能监测\\n- 地理空间数据分析和可视化\\n- 安全分析\\n- 业务分析\\n\\n#### 工作原理\\n\\n从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，在 Kibana 中，用户可以创建数据可视化面板，并对 ELK 进行管理。\\n\\n#### 索引\\n\\nES 索引是指相互关联的文档集合。ES 是会以 JSON 文档的形式保存数据，每个文档都会在一组键值对中建立联系。\\n\\nES 使用的是一种倒排序索引的数据结构。这个结构可以允许十分快速的进行全文本的搜索。\\n\\n在索引的过程中，ES 会保存文档并构建倒排序索引，这样用户就可以实时的对文档数据进行搜索。索引是在添加过程中就启动的。\\n\\n#### Logstash\\n\\nLogstash 是 ELK 的核心菜品，可以对数据进行聚合和处理。并将数据发送到 ES 中。Logstash 是一个开源的服务器端数据处理管道。\\n\\n#### Kibana\\n\\nKibana 是一款 ES 的数据可视化和管理工具，可以提供直方图，线形图，饼状图，地图。Kibana 还包含 Canvas 和 Elastic Maps 等应用程序。Canvas 可以基于用户创建动态信息。Elastic Maps 可以对空间数据进行可视化处理。\\n\\n#### 为什么要使用 ES\\n\\n- **ES 很快**：ES 是在 Lucene 基础上构建，所以全文本搜索相当的出色。ES 还是一个实时搜索平台。文档索引操作到文档变为可搜索之间速度很快。\\n- **ES 具有分布式的特征**：ES 中保存的文档分布在不同的容器中，这些容器为分片，可以对分片进行复制并形成冗余副本。ES 可以扩充到数百台，并处理 PB 级别的数据。\\n- **ES 包含一系列广泛的功能**：ES 拥有大量的内置功能，方便用户管理数据。\\n- **ES 简化了数据采集，可视化报告的过程**：通过与 Beats 和 Logstash 集成，用户可以在 ES 中索引数据并处理数据，\\n\\n### ES 搭建\\n\\n安装镜像：\\n\\n```\\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n启动容器：\\n\\n```\\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \\\"discovery.type=single-node\\\" docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n修改配置：\\n\\n```\\n#进入 docker 容器内部\\n\\ndocker exec -it es /bin/bash\\n\\n#打开配置文件\\n\\nvim config/elasticsearch.yml\\n\\n### 加入跨域配置\\n\\nhttp.cors.enabled: true\\n\\nhttp.cors.allow-origin: \\\"*\\\"\\n```\\n\\n进入容器，安装分词器：\\n\\n```\\ndocker exec -it es /bin/bash\\n./bin/elasticsearch-plugin ', '发布博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 0, '2024-12-17 16:58:54', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (20, 'admin', '/admin/blog', 'POST', '{\"blog\":{\"id\":null,\"title\":\"ElasticSearch 小白从入门到精通\",\"firstPicture\":\"专栏/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.png\",\"content\":\"### 什么是 ElasticSearch\\n\\nElasticSearch 简称为 ES，网址为：\\n\\n> https://www.elastic.co/\\n\\nES 是一个分布式的开源搜索和分析引擎，适用于文本、数字、地理空间、结构化数据、非结构化数据等数据的搜索。ES 是在 Apache Lucene 的基础上完成开发。由 Elastic 于 2010 年发布。ES 通过其简单的 REST 风格的 API、分布式特性、速度和可扩容闻名世界。是 Elastic Stack 的核心组件。Elastic Stack 是一套用于数据采集、扩充、保存、分析、可视化的开源工具。Elastic Stack 称之为 ELK。目前 ELK 包含一系列丰富的轻量数据采集代理，这些代理被称之为 Beats。\\n\\n#### ES 的用途\\n\\n主要有以下的用途：\\n\\n- 应用程序搜索\\n- 网站搜索\\n- 企业搜索\\n- 日志处理\\n- 基础设施指标和容器监测\\n- 应用程序性能监测\\n- 地理空间数据分析和可视化\\n- 安全分析\\n- 业务分析\\n\\n#### 工作原理\\n\\n从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，在 Kibana 中，用户可以创建数据可视化面板，并对 ELK 进行管理。\\n\\n#### 索引\\n\\nES 索引是指相互关联的文档集合。ES 是会以 JSON 文档的形式保存数据，每个文档都会在一组键值对中建立联系。\\n\\nES 使用的是一种倒排序索引的数据结构。这个结构可以允许十分快速的进行全文本的搜索。\\n\\n在索引的过程中，ES 会保存文档并构建倒排序索引，这样用户就可以实时的对文档数据进行搜索。索引是在添加过程中就启动的。\\n\\n#### Logstash\\n\\nLogstash 是 ELK 的核心菜品，可以对数据进行聚合和处理。并将数据发送到 ES 中。Logstash 是一个开源的服务器端数据处理管道。\\n\\n#### Kibana\\n\\nKibana 是一款 ES 的数据可视化和管理工具，可以提供直方图，线形图，饼状图，地图。Kibana 还包含 Canvas 和 Elastic Maps 等应用程序。Canvas 可以基于用户创建动态信息。Elastic Maps 可以对空间数据进行可视化处理。\\n\\n#### 为什么要使用 ES\\n\\n- **ES 很快**：ES 是在 Lucene 基础上构建，所以全文本搜索相当的出色。ES 还是一个实时搜索平台。文档索引操作到文档变为可搜索之间速度很快。\\n- **ES 具有分布式的特征**：ES 中保存的文档分布在不同的容器中，这些容器为分片，可以对分片进行复制并形成冗余副本。ES 可以扩充到数百台，并处理 PB 级别的数据。\\n- **ES 包含一系列广泛的功能**：ES 拥有大量的内置功能，方便用户管理数据。\\n- **ES 简化了数据采集，可视化报告的过程**：通过与 Beats 和 Logstash 集成，用户可以在 ES 中索引数据并处理数据，\\n\\n### ES 搭建\\n\\n安装镜像：\\n\\n```\\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n启动容器：\\n\\n```\\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \\\"discovery.type=single-node\\\" docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n修改配置：\\n\\n```\\n#进入 docker 容器内部\\n\\ndocker exec -it es /bin/bash\\n\\n#打开配置文件\\n\\nvim config/elasticsearch.yml\\n\\n### 加入跨域配置\\n\\nhttp.cors.enabled: true\\n\\nhttp.cors.allow-origin: \\\"*\\\"\\n```\\n\\n进入容器，安装分词器：\\n\\n```\\ndocker exec -it es /bin/bash\\n./bin/elasticsearch-plugin ', '发布博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 0, '2024-12-17 16:58:55', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (21, 'admin', '/admin/blog', 'POST', '{\"blog\":{\"id\":null,\"title\":\"ElasticSearch 小白从入门到精通\",\"firstPicture\":\"专栏/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.png\",\"content\":\"### 什么是 ElasticSearch\\n\\nElasticSearch 简称为 ES，网址为：\\n\\n> https://www.elastic.co/\\n\\nES 是一个分布式的开源搜索和分析引擎，适用于文本、数字、地理空间、结构化数据、非结构化数据等数据的搜索。ES 是在 Apache Lucene 的基础上完成开发。由 Elastic 于 2010 年发布。ES 通过其简单的 REST 风格的 API、分布式特性、速度和可扩容闻名世界。是 Elastic Stack 的核心组件。Elastic Stack 是一套用于数据采集、扩充、保存、分析、可视化的开源工具。Elastic Stack 称之为 ELK。目前 ELK 包含一系列丰富的轻量数据采集代理，这些代理被称之为 Beats。\\n\\n#### ES 的用途\\n\\n主要有以下的用途：\\n\\n- 应用程序搜索\\n- 网站搜索\\n- 企业搜索\\n- 日志处理\\n- 基础设施指标和容器监测\\n- 应用程序性能监测\\n- 地理空间数据分析和可视化\\n- 安全分析\\n- 业务分析\\n\\n#### 工作原理\\n\\n从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，在 Kibana 中，用户可以创建数据可视化面板，并对 ELK 进行管理。\\n\\n#### 索引\\n\\nES 索引是指相互关联的文档集合。ES 是会以 JSON 文档的形式保存数据，每个文档都会在一组键值对中建立联系。\\n\\nES 使用的是一种倒排序索引的数据结构。这个结构可以允许十分快速的进行全文本的搜索。\\n\\n在索引的过程中，ES 会保存文档并构建倒排序索引，这样用户就可以实时的对文档数据进行搜索。索引是在添加过程中就启动的。\\n\\n#### Logstash\\n\\nLogstash 是 ELK 的核心菜品，可以对数据进行聚合和处理。并将数据发送到 ES 中。Logstash 是一个开源的服务器端数据处理管道。\\n\\n#### Kibana\\n\\nKibana 是一款 ES 的数据可视化和管理工具，可以提供直方图，线形图，饼状图，地图。Kibana 还包含 Canvas 和 Elastic Maps 等应用程序。Canvas 可以基于用户创建动态信息。Elastic Maps 可以对空间数据进行可视化处理。\\n\\n#### 为什么要使用 ES\\n\\n- **ES 很快**：ES 是在 Lucene 基础上构建，所以全文本搜索相当的出色。ES 还是一个实时搜索平台。文档索引操作到文档变为可搜索之间速度很快。\\n- **ES 具有分布式的特征**：ES 中保存的文档分布在不同的容器中，这些容器为分片，可以对分片进行复制并形成冗余副本。ES 可以扩充到数百台，并处理 PB 级别的数据。\\n- **ES 包含一系列广泛的功能**：ES 拥有大量的内置功能，方便用户管理数据。\\n- **ES 简化了数据采集，可视化报告的过程**：通过与 Beats 和 Logstash 集成，用户可以在 ES 中索引数据并处理数据，\\n\\n### ES 搭建\\n\\n安装镜像：\\n\\n```\\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n启动容器：\\n\\n```\\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \\\"discovery.type=single-node\\\" docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n修改配置：\\n\\n```\\n#进入 docker 容器内部\\n\\ndocker exec -it es /bin/bash\\n\\n#打开配置文件\\n\\nvim config/elasticsearch.yml\\n\\n### 加入跨域配置\\n\\nhttp.cors.enabled: true\\n\\nhttp.cors.allow-origin: \\\"*\\\"\\n```\\n\\n进入容器，安装分词器：\\n\\n```\\ndocker exec -it es /bin/bash\\n./bin/elasticsearch-plugin ', '发布博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 0, '2024-12-17 16:59:06', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (22, 'admin', '/admin/blog', 'POST', '{\"blog\":{\"id\":null,\"title\":\"ElasticSearch 小白从入门到精通\",\"firstPicture\":\"专栏/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.png\",\"content\":\"### 什么是 ElasticSearch\\n\\nElasticSearch 简称为 ES，网址为：\\n\\n> https://www.elastic.co/\\n\\nES 是一个分布式的开源搜索和分析引擎，适用于文本、数字、地理空间、结构化数据、非结构化数据等数据的搜索。ES 是在 Apache Lucene 的基础上完成开发。由 Elastic 于 2010 年发布。ES 通过其简单的 REST 风格的 API、分布式特性、速度和可扩容闻名世界。是 Elastic Stack 的核心组件。Elastic Stack 是一套用于数据采集、扩充、保存、分析、可视化的开源工具。Elastic Stack 称之为 ELK。目前 ELK 包含一系列丰富的轻量数据采集代理，这些代理被称之为 Beats。\\n\\n#### ES 的用途\\n\\n主要有以下的用途：\\n\\n- 应用程序搜索\\n- 网站搜索\\n- 企业搜索\\n- 日志处理\\n- 基础设施指标和容器监测\\n- 应用程序性能监测\\n- 地理空间数据分析和可视化\\n- 安全分析\\n- 业务分析\\n\\n#### 工作原理\\n\\n从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，在 Kibana 中，用户可以创建数据可视化面板，并对 ELK 进行管理。\\n\\n#### 索引\\n\\nES 索引是指相互关联的文档集合。ES 是会以 JSON 文档的形式保存数据，每个文档都会在一组键值对中建立联系。\\n\\nES 使用的是一种倒排序索引的数据结构。这个结构可以允许十分快速的进行全文本的搜索。\\n\\n在索引的过程中，ES 会保存文档并构建倒排序索引，这样用户就可以实时的对文档数据进行搜索。索引是在添加过程中就启动的。\\n\\n#### Logstash\\n\\nLogstash 是 ELK 的核心菜品，可以对数据进行聚合和处理。并将数据发送到 ES 中。Logstash 是一个开源的服务器端数据处理管道。\\n\\n#### Kibana\\n\\nKibana 是一款 ES 的数据可视化和管理工具，可以提供直方图，线形图，饼状图，地图。Kibana 还包含 Canvas 和 Elastic Maps 等应用程序。Canvas 可以基于用户创建动态信息。Elastic Maps 可以对空间数据进行可视化处理。\\n\\n#### 为什么要使用 ES\\n\\n- **ES 很快**：ES 是在 Lucene 基础上构建，所以全文本搜索相当的出色。ES 还是一个实时搜索平台。文档索引操作到文档变为可搜索之间速度很快。\\n- **ES 具有分布式的特征**：ES 中保存的文档分布在不同的容器中，这些容器为分片，可以对分片进行复制并形成冗余副本。ES 可以扩充到数百台，并处理 PB 级别的数据。\\n- **ES 包含一系列广泛的功能**：ES 拥有大量的内置功能，方便用户管理数据。\\n- **ES 简化了数据采集，可视化报告的过程**：通过与 Beats 和 Logstash 集成，用户可以在 ES 中索引数据并处理数据，\\n\\n### ES 搭建\\n\\n安装镜像：\\n\\n```\\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n启动容器：\\n\\n```\\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \\\"discovery.type=single-node\\\" docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n修改配置：\\n\\n```\\n#进入 docker 容器内部\\n\\ndocker exec -it es /bin/bash\\n\\n#打开配置文件\\n\\nvim config/elasticsearch.yml\\n\\n### 加入跨域配置\\n\\nhttp.cors.enabled: true\\n\\nhttp.cors.allow-origin: \\\"*\\\"\\n```\\n\\n进入容器，安装分词器：\\n\\n```\\ndocker exec -it es /bin/bash\\n./bin/elasticsearch-plugin ', '发布博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 0, '2024-12-17 17:00:12', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (23, 'admin', '/admin/blog', 'POST', '{\"blog\":{\"id\":null,\"title\":\"ElasticSearch 小白从入门到精通\",\"firstPicture\":\"199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.png\",\"content\":\"### 什么是 ElasticSearch\\n\\nElasticSearch 简称为 ES，网址为：\\n\\n> https://www.elastic.co/\\n\\nES 是一个分布式的开源搜索和分析引擎，适用于文本、数字、地理空间、结构化数据、非结构化数据等数据的搜索。ES 是在 Apache Lucene 的基础上完成开发。由 Elastic 于 2010 年发布。ES 通过其简单的 REST 风格的 API、分布式特性、速度和可扩容闻名世界。是 Elastic Stack 的核心组件。Elastic Stack 是一套用于数据采集、扩充、保存、分析、可视化的开源工具。Elastic Stack 称之为 ELK。目前 ELK 包含一系列丰富的轻量数据采集代理，这些代理被称之为 Beats。\\n\\n#### ES 的用途\\n\\n主要有以下的用途：\\n\\n- 应用程序搜索\\n- 网站搜索\\n- 企业搜索\\n- 日志处理\\n- 基础设施指标和容器监测\\n- 应用程序性能监测\\n- 地理空间数据分析和可视化\\n- 安全分析\\n- 业务分析\\n\\n#### 工作原理\\n\\n从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，在 Kibana 中，用户可以创建数据可视化面板，并对 ELK 进行管理。\\n\\n#### 索引\\n\\nES 索引是指相互关联的文档集合。ES 是会以 JSON 文档的形式保存数据，每个文档都会在一组键值对中建立联系。\\n\\nES 使用的是一种倒排序索引的数据结构。这个结构可以允许十分快速的进行全文本的搜索。\\n\\n在索引的过程中，ES 会保存文档并构建倒排序索引，这样用户就可以实时的对文档数据进行搜索。索引是在添加过程中就启动的。\\n\\n#### Logstash\\n\\nLogstash 是 ELK 的核心菜品，可以对数据进行聚合和处理。并将数据发送到 ES 中。Logstash 是一个开源的服务器端数据处理管道。\\n\\n#### Kibana\\n\\nKibana 是一款 ES 的数据可视化和管理工具，可以提供直方图，线形图，饼状图，地图。Kibana 还包含 Canvas 和 Elastic Maps 等应用程序。Canvas 可以基于用户创建动态信息。Elastic Maps 可以对空间数据进行可视化处理。\\n\\n#### 为什么要使用 ES\\n\\n- **ES 很快**：ES 是在 Lucene 基础上构建，所以全文本搜索相当的出色。ES 还是一个实时搜索平台。文档索引操作到文档变为可搜索之间速度很快。\\n- **ES 具有分布式的特征**：ES 中保存的文档分布在不同的容器中，这些容器为分片，可以对分片进行复制并形成冗余副本。ES 可以扩充到数百台，并处理 PB 级别的数据。\\n- **ES 包含一系列广泛的功能**：ES 拥有大量的内置功能，方便用户管理数据。\\n- **ES 简化了数据采集，可视化报告的过程**：通过与 Beats 和 Logstash 集成，用户可以在 ES 中索引数据并处理数据，\\n\\n### ES 搭建\\n\\n安装镜像：\\n\\n```\\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n启动容器：\\n\\n```\\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \\\"discovery.type=single-node\\\" docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n修改配置：\\n\\n```\\n#进入 docker 容器内部\\n\\ndocker exec -it es /bin/bash\\n\\n#打开配置文件\\n\\nvim config/elasticsearch.yml\\n\\n### 加入跨域配置\\n\\nhttp.cors.enabled: true\\n\\nhttp.cors.allow-origin: \\\"*\\\"\\n```\\n\\n进入容器，安装分词器：\\n\\n```\\ndocker exec -it es /bin/bash\\n./bin/elasticsearch-plugin ins', '发布博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 0, '2024-12-17 17:00:25', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (24, 'admin', '/admin/blog', 'POST', '{\"blog\":{\"id\":null,\"title\":\"ElasticSearch 小白从入门到精通\",\"firstPicture\":\"/专栏/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3\",\"content\":\"### 什么是 ElasticSearch\\n\\nElasticSearch 简称为 ES，网址为：\\n\\n> https://www.elastic.co/\\n\\nES 是一个分布式的开源搜索和分析引擎，适用于文本、数字、地理空间、结构化数据、非结构化数据等数据的搜索。ES 是在 Apache Lucene 的基础上完成开发。由 Elastic 于 2010 年发布。ES 通过其简单的 REST 风格的 API、分布式特性、速度和可扩容闻名世界。是 Elastic Stack 的核心组件。Elastic Stack 是一套用于数据采集、扩充、保存、分析、可视化的开源工具。Elastic Stack 称之为 ELK。目前 ELK 包含一系列丰富的轻量数据采集代理，这些代理被称之为 Beats。\\n\\n#### ES 的用途\\n\\n主要有以下的用途：\\n\\n- 应用程序搜索\\n- 网站搜索\\n- 企业搜索\\n- 日志处理\\n- 基础设施指标和容器监测\\n- 应用程序性能监测\\n- 地理空间数据分析和可视化\\n- 安全分析\\n- 业务分析\\n\\n#### 工作原理\\n\\n从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，在 Kibana 中，用户可以创建数据可视化面板，并对 ELK 进行管理。\\n\\n#### 索引\\n\\nES 索引是指相互关联的文档集合。ES 是会以 JSON 文档的形式保存数据，每个文档都会在一组键值对中建立联系。\\n\\nES 使用的是一种倒排序索引的数据结构。这个结构可以允许十分快速的进行全文本的搜索。\\n\\n在索引的过程中，ES 会保存文档并构建倒排序索引，这样用户就可以实时的对文档数据进行搜索。索引是在添加过程中就启动的。\\n\\n#### Logstash\\n\\nLogstash 是 ELK 的核心菜品，可以对数据进行聚合和处理。并将数据发送到 ES 中。Logstash 是一个开源的服务器端数据处理管道。\\n\\n#### Kibana\\n\\nKibana 是一款 ES 的数据可视化和管理工具，可以提供直方图，线形图，饼状图，地图。Kibana 还包含 Canvas 和 Elastic Maps 等应用程序。Canvas 可以基于用户创建动态信息。Elastic Maps 可以对空间数据进行可视化处理。\\n\\n#### 为什么要使用 ES\\n\\n- **ES 很快**：ES 是在 Lucene 基础上构建，所以全文本搜索相当的出色。ES 还是一个实时搜索平台。文档索引操作到文档变为可搜索之间速度很快。\\n- **ES 具有分布式的特征**：ES 中保存的文档分布在不同的容器中，这些容器为分片，可以对分片进行复制并形成冗余副本。ES 可以扩充到数百台，并处理 PB 级别的数据。\\n- **ES 包含一系列广泛的功能**：ES 拥有大量的内置功能，方便用户管理数据。\\n- **ES 简化了数据采集，可视化报告的过程**：通过与 Beats 和 Logstash 集成，用户可以在 ES 中索引数据并处理数据，\\n\\n### ES 搭建\\n\\n安装镜像：\\n\\n```\\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n启动容器：\\n\\n```\\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \\\"discovery.type=single-node\\\" docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n修改配置：\\n\\n```\\n#进入 docker 容器内部\\n\\ndocker exec -it es /bin/bash\\n\\n#打开配置文件\\n\\nvim config/elasticsearch.yml\\n\\n### 加入跨域配置\\n\\nhttp.cors.enabled: true\\n\\nhttp.cors.allow-origin: \\\"*\\\"\\n```\\n\\n进入容器，安装分词器：\\n\\n```\\ndocker exec -it es /bin/bash\\n./bin/elasticsearch-plugin ins', '发布博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 1, '2024-12-17 17:00:55', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (25, 'admin', '/admin/blog', 'POST', '{\"blog\":{\"id\":null,\"title\":\"ElasticSearch 小白从入门到精通\",\"firstPicture\":\"http://专栏/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.jpg\",\"content\":\"### 什么是 ElasticSearch\\n\\nElasticSearch 简称为 ES，网址为：\\n\\n> https://www.elastic.co/\\n\\nES 是一个分布式的开源搜索和分析引擎，适用于文本、数字、地理空间、结构化数据、非结构化数据等数据的搜索。ES 是在 Apache Lucene 的基础上完成开发。由 Elastic 于 2010 年发布。ES 通过其简单的 REST 风格的 API、分布式特性、速度和可扩容闻名世界。是 Elastic Stack 的核心组件。Elastic Stack 是一套用于数据采集、扩充、保存、分析、可视化的开源工具。Elastic Stack 称之为 ELK。目前 ELK 包含一系列丰富的轻量数据采集代理，这些代理被称之为 Beats。\\n\\n#### ES 的用途\\n\\n主要有以下的用途：\\n\\n- 应用程序搜索\\n- 网站搜索\\n- 企业搜索\\n- 日志处理\\n- 基础设施指标和容器监测\\n- 应用程序性能监测\\n- 地理空间数据分析和可视化\\n- 安全分析\\n- 业务分析\\n\\n#### 工作原理\\n\\n从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，在 Kibana 中，用户可以创建数据可视化面板，并对 ELK 进行管理。\\n\\n#### 索引\\n\\nES 索引是指相互关联的文档集合。ES 是会以 JSON 文档的形式保存数据，每个文档都会在一组键值对中建立联系。\\n\\nES 使用的是一种倒排序索引的数据结构。这个结构可以允许十分快速的进行全文本的搜索。\\n\\n在索引的过程中，ES 会保存文档并构建倒排序索引，这样用户就可以实时的对文档数据进行搜索。索引是在添加过程中就启动的。\\n\\n#### Logstash\\n\\nLogstash 是 ELK 的核心菜品，可以对数据进行聚合和处理。并将数据发送到 ES 中。Logstash 是一个开源的服务器端数据处理管道。\\n\\n#### Kibana\\n\\nKibana 是一款 ES 的数据可视化和管理工具，可以提供直方图，线形图，饼状图，地图。Kibana 还包含 Canvas 和 Elastic Maps 等应用程序。Canvas 可以基于用户创建动态信息。Elastic Maps 可以对空间数据进行可视化处理。\\n\\n#### 为什么要使用 ES\\n\\n- **ES 很快**：ES 是在 Lucene 基础上构建，所以全文本搜索相当的出色。ES 还是一个实时搜索平台。文档索引操作到文档变为可搜索之间速度很快。\\n- **ES 具有分布式的特征**：ES 中保存的文档分布在不同的容器中，这些容器为分片，可以对分片进行复制并形成冗余副本。ES 可以扩充到数百台，并处理 PB 级别的数据。\\n- **ES 包含一系列广泛的功能**：ES 拥有大量的内置功能，方便用户管理数据。\\n- **ES 简化了数据采集，可视化报告的过程**：通过与 Beats 和 Logstash 集成，用户可以在 ES 中索引数据并处理数据，\\n\\n### ES 搭建\\n\\n安装镜像：\\n\\n```\\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n启动容器：\\n\\n```\\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \\\"discovery.type=single-node\\\" docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n修改配置：\\n\\n```\\n#进入 docker 容器内部\\n\\ndocker exec -it es /bin/bash\\n\\n#打开配置文件\\n\\nvim config/elasticsearch.yml\\n\\n### 加入跨域配置\\n\\nhttp.cors.enabled: true\\n\\nhttp.cors.allow-origin: \\\"*\\\"\\n```\\n\\n进入容器，安装分词器：\\n\\n```\\ndocker exec -it es /bin/bash\\n./bin/elasticsearch-', '发布博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 0, '2024-12-17 17:01:21', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (26, 'admin', '/admin/blog', 'POST', '{\"blog\":{\"id\":null,\"title\":\"ElasticSearch 小白从入门到精通\",\"firstPicture\":\"https://github.com/youtatu-hub/photo/专栏/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.jpg\",\"content\":\"### 什么是 ElasticSearch\\n\\nElasticSearch 简称为 ES，网址为：\\n\\n> https://www.elastic.co/\\n\\nES 是一个分布式的开源搜索和分析引擎，适用于文本、数字、地理空间、结构化数据、非结构化数据等数据的搜索。ES 是在 Apache Lucene 的基础上完成开发。由 Elastic 于 2010 年发布。ES 通过其简单的 REST 风格的 API、分布式特性、速度和可扩容闻名世界。是 Elastic Stack 的核心组件。Elastic Stack 是一套用于数据采集、扩充、保存、分析、可视化的开源工具。Elastic Stack 称之为 ELK。目前 ELK 包含一系列丰富的轻量数据采集代理，这些代理被称之为 Beats。\\n\\n#### ES 的用途\\n\\n主要有以下的用途：\\n\\n- 应用程序搜索\\n- 网站搜索\\n- 企业搜索\\n- 日志处理\\n- 基础设施指标和容器监测\\n- 应用程序性能监测\\n- 地理空间数据分析和可视化\\n- 安全分析\\n- 业务分析\\n\\n#### 工作原理\\n\\n从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，在 Kibana 中，用户可以创建数据可视化面板，并对 ELK 进行管理。\\n\\n#### 索引\\n\\nES 索引是指相互关联的文档集合。ES 是会以 JSON 文档的形式保存数据，每个文档都会在一组键值对中建立联系。\\n\\nES 使用的是一种倒排序索引的数据结构。这个结构可以允许十分快速的进行全文本的搜索。\\n\\n在索引的过程中，ES 会保存文档并构建倒排序索引，这样用户就可以实时的对文档数据进行搜索。索引是在添加过程中就启动的。\\n\\n#### Logstash\\n\\nLogstash 是 ELK 的核心菜品，可以对数据进行聚合和处理。并将数据发送到 ES 中。Logstash 是一个开源的服务器端数据处理管道。\\n\\n#### Kibana\\n\\nKibana 是一款 ES 的数据可视化和管理工具，可以提供直方图，线形图，饼状图，地图。Kibana 还包含 Canvas 和 Elastic Maps 等应用程序。Canvas 可以基于用户创建动态信息。Elastic Maps 可以对空间数据进行可视化处理。\\n\\n#### 为什么要使用 ES\\n\\n- **ES 很快**：ES 是在 Lucene 基础上构建，所以全文本搜索相当的出色。ES 还是一个实时搜索平台。文档索引操作到文档变为可搜索之间速度很快。\\n- **ES 具有分布式的特征**：ES 中保存的文档分布在不同的容器中，这些容器为分片，可以对分片进行复制并形成冗余副本。ES 可以扩充到数百台，并处理 PB 级别的数据。\\n- **ES 包含一系列广泛的功能**：ES 拥有大量的内置功能，方便用户管理数据。\\n- **ES 简化了数据采集，可视化报告的过程**：通过与 Beats 和 Logstash 集成，用户可以在 ES 中索引数据并处理数据，\\n\\n### ES 搭建\\n\\n安装镜像：\\n\\n```\\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n启动容器：\\n\\n```\\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \\\"discovery.type=single-node\\\" docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n修改配置：\\n\\n```\\n#进入 docker 容器内部\\n\\ndocker exec -it es /bin/bash\\n\\n#打开配置文件\\n\\nvim config/elasticsearch.yml\\n\\n### 加入跨域配置\\n\\nhttp.cors.enabled: true\\n\\nhttp.cors.allow-origin: \\\"*\\\"\\n```\\n\\n进入容器，安装分词器：\\n\\n```\\ndocker exec -it es /', '发布博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 0, '2024-12-17 17:02:10', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (27, 'admin', '/admin/blog', 'POST', '{\"blog\":{\"id\":null,\"title\":\"ElasticSearch 小白从入门到精通\",\"firstPicture\":\"https://github.com/youtatu-hub/photo/专栏/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.png\",\"content\":\"### 什么是 ElasticSearch\\n\\nElasticSearch 简称为 ES，网址为：\\n\\n> https://www.elastic.co/\\n\\nES 是一个分布式的开源搜索和分析引擎，适用于文本、数字、地理空间、结构化数据、非结构化数据等数据的搜索。ES 是在 Apache Lucene 的基础上完成开发。由 Elastic 于 2010 年发布。ES 通过其简单的 REST 风格的 API、分布式特性、速度和可扩容闻名世界。是 Elastic Stack 的核心组件。Elastic Stack 是一套用于数据采集、扩充、保存、分析、可视化的开源工具。Elastic Stack 称之为 ELK。目前 ELK 包含一系列丰富的轻量数据采集代理，这些代理被称之为 Beats。\\n\\n#### ES 的用途\\n\\n主要有以下的用途：\\n\\n- 应用程序搜索\\n- 网站搜索\\n- 企业搜索\\n- 日志处理\\n- 基础设施指标和容器监测\\n- 应用程序性能监测\\n- 地理空间数据分析和可视化\\n- 安全分析\\n- 业务分析\\n\\n#### 工作原理\\n\\n从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，在 Kibana 中，用户可以创建数据可视化面板，并对 ELK 进行管理。\\n\\n#### 索引\\n\\nES 索引是指相互关联的文档集合。ES 是会以 JSON 文档的形式保存数据，每个文档都会在一组键值对中建立联系。\\n\\nES 使用的是一种倒排序索引的数据结构。这个结构可以允许十分快速的进行全文本的搜索。\\n\\n在索引的过程中，ES 会保存文档并构建倒排序索引，这样用户就可以实时的对文档数据进行搜索。索引是在添加过程中就启动的。\\n\\n#### Logstash\\n\\nLogstash 是 ELK 的核心菜品，可以对数据进行聚合和处理。并将数据发送到 ES 中。Logstash 是一个开源的服务器端数据处理管道。\\n\\n#### Kibana\\n\\nKibana 是一款 ES 的数据可视化和管理工具，可以提供直方图，线形图，饼状图，地图。Kibana 还包含 Canvas 和 Elastic Maps 等应用程序。Canvas 可以基于用户创建动态信息。Elastic Maps 可以对空间数据进行可视化处理。\\n\\n#### 为什么要使用 ES\\n\\n- **ES 很快**：ES 是在 Lucene 基础上构建，所以全文本搜索相当的出色。ES 还是一个实时搜索平台。文档索引操作到文档变为可搜索之间速度很快。\\n- **ES 具有分布式的特征**：ES 中保存的文档分布在不同的容器中，这些容器为分片，可以对分片进行复制并形成冗余副本。ES 可以扩充到数百台，并处理 PB 级别的数据。\\n- **ES 包含一系列广泛的功能**：ES 拥有大量的内置功能，方便用户管理数据。\\n- **ES 简化了数据采集，可视化报告的过程**：通过与 Beats 和 Logstash 集成，用户可以在 ES 中索引数据并处理数据，\\n\\n### ES 搭建\\n\\n安装镜像：\\n\\n```\\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n启动容器：\\n\\n```\\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \\\"discovery.type=single-node\\\" docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n修改配置：\\n\\n```\\n#进入 docker 容器内部\\n\\ndocker exec -it es /bin/bash\\n\\n#打开配置文件\\n\\nvim config/elasticsearch.yml\\n\\n### 加入跨域配置\\n\\nhttp.cors.enabled: true\\n\\nhttp.cors.allow-origin: \\\"*\\\"\\n```\\n\\n进入容器，安装分词器：\\n\\n```\\ndocker exec -it es /', '发布博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 0, '2024-12-17 17:02:43', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (28, 'admin', '/admin/blog', 'POST', '{\"blog\":{\"id\":1,\"title\":\"ElasticSearch 小白从入门到精通\",\"firstPicture\":\"https://github.com/youtatu-hub/photo/专栏/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.png\",\"content\":\"### 什么是 ElasticSearch\\n\\nElasticSearch 简称为 ES，网址为：\\n\\n> https://www.elastic.co/\\n\\nES 是一个分布式的开源搜索和分析引擎，适用于文本、数字、地理空间、结构化数据、非结构化数据等数据的搜索。ES 是在 Apache Lucene 的基础上完成开发。由 Elastic 于 2010 年发布。ES 通过其简单的 REST 风格的 API、分布式特性、速度和可扩容闻名世界。是 Elastic Stack 的核心组件。Elastic Stack 是一套用于数据采集、扩充、保存、分析、可视化的开源工具。Elastic Stack 称之为 ELK。目前 ELK 包含一系列丰富的轻量数据采集代理，这些代理被称之为 Beats。\\n\\n#### ES 的用途\\n\\n主要有以下的用途：\\n\\n- 应用程序搜索\\n- 网站搜索\\n- 企业搜索\\n- 日志处理\\n- 基础设施指标和容器监测\\n- 应用程序性能监测\\n- 地理空间数据分析和可视化\\n- 安全分析\\n- 业务分析\\n\\n#### 工作原理\\n\\n从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，在 Kibana 中，用户可以创建数据可视化面板，并对 ELK 进行管理。\\n\\n#### 索引\\n\\nES 索引是指相互关联的文档集合。ES 是会以 JSON 文档的形式保存数据，每个文档都会在一组键值对中建立联系。\\n\\nES 使用的是一种倒排序索引的数据结构。这个结构可以允许十分快速的进行全文本的搜索。\\n\\n在索引的过程中，ES 会保存文档并构建倒排序索引，这样用户就可以实时的对文档数据进行搜索。索引是在添加过程中就启动的。\\n\\n#### Logstash\\n\\nLogstash 是 ELK 的核心菜品，可以对数据进行聚合和处理。并将数据发送到 ES 中。Logstash 是一个开源的服务器端数据处理管道。\\n\\n#### Kibana\\n\\nKibana 是一款 ES 的数据可视化和管理工具，可以提供直方图，线形图，饼状图，地图。Kibana 还包含 Canvas 和 Elastic Maps 等应用程序。Canvas 可以基于用户创建动态信息。Elastic Maps 可以对空间数据进行可视化处理。\\n\\n#### 为什么要使用 ES\\n\\n- **ES 很快**：ES 是在 Lucene 基础上构建，所以全文本搜索相当的出色。ES 还是一个实时搜索平台。文档索引操作到文档变为可搜索之间速度很快。\\n- **ES 具有分布式的特征**：ES 中保存的文档分布在不同的容器中，这些容器为分片，可以对分片进行复制并形成冗余副本。ES 可以扩充到数百台，并处理 PB 级别的数据。\\n- **ES 包含一系列广泛的功能**：ES 拥有大量的内置功能，方便用户管理数据。\\n- **ES 简化了数据采集，可视化报告的过程**：通过与 Beats 和 Logstash 集成，用户可以在 ES 中索引数据并处理数据，\\n\\n### ES 搭建\\n\\n安装镜像：\\n\\n```\\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n启动容器：\\n\\n```\\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \\\"discovery.type=single-node\\\" docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n修改配置：\\n\\n```\\n#进入 docker 容器内部\\n\\ndocker exec -it es /bin/bash\\n\\n#打开配置文件\\n\\nvim config/elasticsearch.yml\\n\\n### 加入跨域配置\\n\\nhttp.cors.enabled: true\\n\\nhttp.cors.allow-origin: \\\"*\\\"\\n```\\n\\n进入容器，安装分词器：\\n\\n```\\ndocker exec -it es /bin', '发布博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 35, '2024-12-17 17:03:03', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (29, 'admin', '/admin/blog', 'PUT', '{\"blog\":{\"id\":1,\"title\":\"ElasticSearch 小白从入门到精通\",\"firstPicture\":\"https://github.com/youtatu-hub/photo/专栏/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.png\",\"content\":\"### 什么是 ElasticSearch\\n\\nElasticSearch 简称为 ES，网址为：\\n\\n> https://www.elastic.co/\\n\\nES 是一个分布式的开源搜索和分析引擎，适用于文本、数字、地理空间、结构化数据、非结构化数据等数据的搜索。ES 是在 Apache Lucene 的基础上完成开发。由 Elastic 于 2010 年发布。ES 通过其简单的 REST 风格的 API、分布式特性、速度和可扩容闻名世界。是 Elastic Stack 的核心组件。Elastic Stack 是一套用于数据采集、扩充、保存、分析、可视化的开源工具。Elastic Stack 称之为 ELK。目前 ELK 包含一系列丰富的轻量数据采集代理，这些代理被称之为 Beats。\\n\\n#### ES 的用途\\n\\n主要有以下的用途：\\n\\n- 应用程序搜索\\n- 网站搜索\\n- 企业搜索\\n- 日志处理\\n- 基础设施指标和容器监测\\n- 应用程序性能监测\\n- 地理空间数据分析和可视化\\n- 安全分析\\n- 业务分析\\n\\n#### 工作原理\\n\\n从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，在 Kibana 中，用户可以创建数据可视化面板，并对 ELK 进行管理。\\n\\n#### 索引\\n\\nES 索引是指相互关联的文档集合。ES 是会以 JSON 文档的形式保存数据，每个文档都会在一组键值对中建立联系。\\n\\nES 使用的是一种倒排序索引的数据结构。这个结构可以允许十分快速的进行全文本的搜索。\\n\\n在索引的过程中，ES 会保存文档并构建倒排序索引，这样用户就可以实时的对文档数据进行搜索。索引是在添加过程中就启动的。\\n\\n#### Logstash\\n\\nLogstash 是 ELK 的核心菜品，可以对数据进行聚合和处理。并将数据发送到 ES 中。Logstash 是一个开源的服务器端数据处理管道。\\n\\n#### Kibana\\n\\nKibana 是一款 ES 的数据可视化和管理工具，可以提供直方图，线形图，饼状图，地图。Kibana 还包含 Canvas 和 Elastic Maps 等应用程序。Canvas 可以基于用户创建动态信息。Elastic Maps 可以对空间数据进行可视化处理。\\n\\n#### 为什么要使用 ES\\n\\n- **ES 很快**：ES 是在 Lucene 基础上构建，所以全文本搜索相当的出色。ES 还是一个实时搜索平台。文档索引操作到文档变为可搜索之间速度很快。\\n- **ES 具有分布式的特征**：ES 中保存的文档分布在不同的容器中，这些容器为分片，可以对分片进行复制并形成冗余副本。ES 可以扩充到数百台，并处理 PB 级别的数据。\\n- **ES 包含一系列广泛的功能**：ES 拥有大量的内置功能，方便用户管理数据。\\n- **ES 简化了数据采集，可视化报告的过程**：通过与 Beats 和 Logstash 集成，用户可以在 ES 中索引数据并处理数据，\\n\\n### ES 搭建\\n\\n安装镜像：\\n\\n```\\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n启动容器：\\n\\n```\\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \\\"discovery.type=single-node\\\" docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n修改配置：\\n\\n```\\n#进入 docker 容器内部\\n\\ndocker exec -it es /bin/bash\\n\\n#打开配置文件\\n\\nvim config/elasticsearch.yml\\n\\n### 加入跨域配置\\n\\nhttp.cors.enabled: true\\n\\nhttp.cors.allow-origin: \\\"*\\\"\\n```\\n\\n进入容器，安装分词器：\\n\\n```\\ndocker exec -it es /bin', '更新博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 24, '2024-12-17 17:08:08', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (30, 'admin', '/admin/blog', 'PUT', '{\"blog\":{\"id\":1,\"title\":\"ElasticSearch 小白从入门到精通\",\"firstPicture\":\"专栏/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.png\",\"content\":\"### 什么是 ElasticSearch\\n\\nElasticSearch 简称为 ES，网址为：\\n\\n> https://www.elastic.co/\\n\\nES 是一个分布式的开源搜索和分析引擎，适用于文本、数字、地理空间、结构化数据、非结构化数据等数据的搜索。ES 是在 Apache Lucene 的基础上完成开发。由 Elastic 于 2010 年发布。ES 通过其简单的 REST 风格的 API、分布式特性、速度和可扩容闻名世界。是 Elastic Stack 的核心组件。Elastic Stack 是一套用于数据采集、扩充、保存、分析、可视化的开源工具。Elastic Stack 称之为 ELK。目前 ELK 包含一系列丰富的轻量数据采集代理，这些代理被称之为 Beats。\\n\\n#### ES 的用途\\n\\n主要有以下的用途：\\n\\n- 应用程序搜索\\n- 网站搜索\\n- 企业搜索\\n- 日志处理\\n- 基础设施指标和容器监测\\n- 应用程序性能监测\\n- 地理空间数据分析和可视化\\n- 安全分析\\n- 业务分析\\n\\n#### 工作原理\\n\\n从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，在 Kibana 中，用户可以创建数据可视化面板，并对 ELK 进行管理。\\n\\n#### 索引\\n\\nES 索引是指相互关联的文档集合。ES 是会以 JSON 文档的形式保存数据，每个文档都会在一组键值对中建立联系。\\n\\nES 使用的是一种倒排序索引的数据结构。这个结构可以允许十分快速的进行全文本的搜索。\\n\\n在索引的过程中，ES 会保存文档并构建倒排序索引，这样用户就可以实时的对文档数据进行搜索。索引是在添加过程中就启动的。\\n\\n#### Logstash\\n\\nLogstash 是 ELK 的核心菜品，可以对数据进行聚合和处理。并将数据发送到 ES 中。Logstash 是一个开源的服务器端数据处理管道。\\n\\n#### Kibana\\n\\nKibana 是一款 ES 的数据可视化和管理工具，可以提供直方图，线形图，饼状图，地图。Kibana 还包含 Canvas 和 Elastic Maps 等应用程序。Canvas 可以基于用户创建动态信息。Elastic Maps 可以对空间数据进行可视化处理。\\n\\n#### 为什么要使用 ES\\n\\n- **ES 很快**：ES 是在 Lucene 基础上构建，所以全文本搜索相当的出色。ES 还是一个实时搜索平台。文档索引操作到文档变为可搜索之间速度很快。\\n- **ES 具有分布式的特征**：ES 中保存的文档分布在不同的容器中，这些容器为分片，可以对分片进行复制并形成冗余副本。ES 可以扩充到数百台，并处理 PB 级别的数据。\\n- **ES 包含一系列广泛的功能**：ES 拥有大量的内置功能，方便用户管理数据。\\n- **ES 简化了数据采集，可视化报告的过程**：通过与 Beats 和 Logstash 集成，用户可以在 ES 中索引数据并处理数据，\\n\\n### ES 搭建\\n\\n安装镜像：\\n\\n```\\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n启动容器：\\n\\n```\\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \\\"discovery.type=single-node\\\" docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n修改配置：\\n\\n```\\n#进入 docker 容器内部\\n\\ndocker exec -it es /bin/bash\\n\\n#打开配置文件\\n\\nvim config/elasticsearch.yml\\n\\n### 加入跨域配置\\n\\nhttp.cors.enabled: true\\n\\nhttp.cors.allow-origin: \\\"*\\\"\\n```\\n\\n进入容器，安装分词器：\\n\\n```\\ndocker exec -it es /bin/bash\\n./bin/elasticsearch-plugin ins', '更新博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 26, '2024-12-18 08:46:01', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (31, 'admin', '/admin/blog', 'PUT', '{\"blog\":{\"id\":1,\"title\":\"ElasticSearch 小白从入门到精通\",\"firstPicture\":\"/专栏/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.png\",\"content\":\"#### ES 的用途\\n\\n主要有以下的用途：\\n\\n- 应用程序搜索\\n- 网站搜索\\n- 企业搜索\\n- 日志处理\\n- 基础设施指标和容器监测\\n- 应用程序性能监测\\n- 地理空间数据分析和可视化\\n- 安全分析\\n- 业务分析\\n\\n#### 工作原理\\n\\n从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，在 Kibana 中，用户可以创建数据可视化面板，并对 ELK 进行管理。\\n\\n#### 索引\\n\\nES 索引是指相互关联的文档集合。ES 是会以 JSON 文档的形式保存数据，每个文档都会在一组键值对中建立联系。\\n\\nES 使用的是一种倒排序索引的数据结构。这个结构可以允许十分快速的进行全文本的搜索。\\n\\n在索引的过程中，ES 会保存文档并构建倒排序索引，这样用户就可以实时的对文档数据进行搜索。索引是在添加过程中就启动的。\\n\\n#### Logstash\\n\\nLogstash 是 ELK 的核心菜品，可以对数据进行聚合和处理。并将数据发送到 ES 中。Logstash 是一个开源的服务器端数据处理管道。\\n\\n#### Kibana\\n\\nKibana 是一款 ES 的数据可视化和管理工具，可以提供直方图，线形图，饼状图，地图。Kibana 还包含 Canvas 和 Elastic Maps 等应用程序。Canvas 可以基于用户创建动态信息。Elastic Maps 可以对空间数据进行可视化处理。\\n\\n#### 为什么要使用 ES\\n\\n- **ES 很快**：ES 是在 Lucene 基础上构建，所以全文本搜索相当的出色。ES 还是一个实时搜索平台。文档索引操作到文档变为可搜索之间速度很快。\\n- **ES 具有分布式的特征**：ES 中保存的文档分布在不同的容器中，这些容器为分片，可以对分片进行复制并形成冗余副本。ES 可以扩充到数百台，并处理 PB 级别的数据。\\n- **ES 包含一系列广泛的功能**：ES 拥有大量的内置功能，方便用户管理数据。\\n- **ES 简化了数据采集，可视化报告的过程**：通过与 Beats 和 Logstash 集成，用户可以在 ES 中索引数据并处理数据，\\n\\n### ES 搭建\\n\\n安装镜像：\\n\\n```\\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n启动容器：\\n\\n```\\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \\\"discovery.type=single-node\\\" docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n修改配置：\\n\\n```\\n#进入 docker 容器内部\\n\\ndocker exec -it es /bin/bash\\n\\n#打开配置文件\\n\\nvim config/elasticsearch.yml\\n\\n### 加入跨域配置\\n\\nhttp.cors.enabled: true\\n\\nhttp.cors.allow-origin: \\\"*\\\"\\n```\\n\\n进入容器，安装分词器：\\n\\n```\\ndocker exec -it es /bin/bash\\n./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.3.2/elasticsearch-analysis-ik-7.3.2.zip\\n```\\n\\n重启 ES：\\n\\n```\\ndocker restart es\\n```\\n\\n测试：\\n\\n![在这里插入图片描述](/专栏/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.png)\\n\\n查看分词器是否安装上：\\n\\n![在这里插入图片描述](/assets/25ebc030-cee2-11eb-ac3e-190fba44d759)\\n\\n### ES 查询\\n\\n#### 空查询\\n\\n空查询将会返回一个索引库中所有文档', '更新博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 22, '2024-12-18 08:47:26', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (32, 'admin', '/admin/blog', 'DELETE', '{\"id\":1}', '删除博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 21, '2024-12-18 08:50:43', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (33, 'admin', '/admin/blog', 'POST', '{\"blog\":{\"id\":2,\"title\":\"ElasticSearch 小白从入门到精通\",\"firstPicture\":\"youtatu-hub/photo/column/assets/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.png\",\"content\":\"### 什么是 ElasticSearch\\n\\nElasticSearch 简称为 ES，网址为：\\n\\n> https://www.elastic.co/\\n\\nES 是一个分布式的开源搜索和分析引擎，适用于文本、数字、地理空间、结构化数据、非结构化数据等数据的搜索。ES 是在 Apache Lucene 的基础上完成开发。由 Elastic 于 2010 年发布。ES 通过其简单的 REST 风格的 API、分布式特性、速度和可扩容闻名世界。是 Elastic Stack 的核心组件。Elastic Stack 是一套用于数据采集、扩充、保存、分析、可视化的开源工具。Elastic Stack 称之为 ELK。目前 ELK 包含一系列丰富的轻量数据采集代理，这些代理被称之为 Beats。\\n\\n#### ES 的用途\\n\\n主要有以下的用途：\\n\\n- 应用程序搜索\\n- 网站搜索\\n- 企业搜索\\n- 日志处理\\n- 基础设施指标和容器监测\\n- 应用程序性能监测\\n- 地理空间数据分析和可视化\\n- 安全分析\\n- 业务分析\\n\\n#### 工作原理\\n\\n从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，在 Kibana 中，用户可以创建数据可视化面板，并对 ELK 进行管理。\\n\\n#### 索引\\n\\nES 索引是指相互关联的文档集合。ES 是会以 JSON 文档的形式保存数据，每个文档都会在一组键值对中建立联系。\\n\\nES 使用的是一种倒排序索引的数据结构。这个结构可以允许十分快速的进行全文本的搜索。\\n\\n在索引的过程中，ES 会保存文档并构建倒排序索引，这样用户就可以实时的对文档数据进行搜索。索引是在添加过程中就启动的。\\n\\n#### Logstash\\n\\nLogstash 是 ELK 的核心菜品，可以对数据进行聚合和处理。并将数据发送到 ES 中。Logstash 是一个开源的服务器端数据处理管道。\\n\\n#### Kibana\\n\\nKibana 是一款 ES 的数据可视化和管理工具，可以提供直方图，线形图，饼状图，地图。Kibana 还包含 Canvas 和 Elastic Maps 等应用程序。Canvas 可以基于用户创建动态信息。Elastic Maps 可以对空间数据进行可视化处理。\\n\\n#### 为什么要使用 ES\\n\\n- **ES 很快**：ES 是在 Lucene 基础上构建，所以全文本搜索相当的出色。ES 还是一个实时搜索平台。文档索引操作到文档变为可搜索之间速度很快。\\n- **ES 具有分布式的特征**：ES 中保存的文档分布在不同的容器中，这些容器为分片，可以对分片进行复制并形成冗余副本。ES 可以扩充到数百台，并处理 PB 级别的数据。\\n- **ES 包含一系列广泛的功能**：ES 拥有大量的内置功能，方便用户管理数据。\\n- **ES 简化了数据采集，可视化报告的过程**：通过与 Beats 和 Logstash 集成，用户可以在 ES 中索引数据并处理数据，\\n\\n### ES 搭建\\n\\n安装镜像：\\n\\n```\\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n启动容器：\\n\\n```\\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \\\"discovery.type=single-node\\\" docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n修改配置：\\n\\n```\\n#进入 docker 容器内部\\n\\ndocker exec -it es /bin/bash\\n\\n#打开配置文件\\n\\nvim config/elasticsearch.yml\\n\\n### 加入跨域配置\\n\\nhttp.cors.enabled: true\\n\\nhttp.cors.allow-origin: \\\"*\\\"\\n```\\n\\n进入容器，安装分词器：\\n\\n```\\ndocker exec -it es /bin/bash\\n.', '发布博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 65, '2024-12-18 09:37:18', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (34, 'admin', '/admin/blog', 'PUT', '{\"blog\":{\"id\":2,\"title\":\"ElasticSearch 小白从入门到精通\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.png\",\"content\":\"### 什么是 ElasticSearch\\n\\nElasticSearch 简称为 ES，网址为：\\n\\n> https://www.elastic.co/\\n\\nES 是一个分布式的开源搜索和分析引擎，适用于文本、数字、地理空间、结构化数据、非结构化数据等数据的搜索。ES 是在 Apache Lucene 的基础上完成开发。由 Elastic 于 2010 年发布。ES 通过其简单的 REST 风格的 API、分布式特性、速度和可扩容闻名世界。是 Elastic Stack 的核心组件。Elastic Stack 是一套用于数据采集、扩充、保存、分析、可视化的开源工具。Elastic Stack 称之为 ELK。目前 ELK 包含一系列丰富的轻量数据采集代理，这些代理被称之为 Beats。\\n\\n#### ES 的用途\\n\\n主要有以下的用途：\\n\\n- 应用程序搜索\\n- 网站搜索\\n- 企业搜索\\n- 日志处理\\n- 基础设施指标和容器监测\\n- 应用程序性能监测\\n- 地理空间数据分析和可视化\\n- 安全分析\\n- 业务分析\\n\\n#### 工作原理\\n\\n从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，在 Kibana 中，用户可以创建数据可视化面板，并对 ELK 进行管理。\\n\\n#### 索引\\n\\nES 索引是指相互关联的文档集合。ES 是会以 JSON 文档的形式保存数据，每个文档都会在一组键值对中建立联系。\\n\\nES 使用的是一种倒排序索引的数据结构。这个结构可以允许十分快速的进行全文本的搜索。\\n\\n在索引的过程中，ES 会保存文档并构建倒排序索引，这样用户就可以实时的对文档数据进行搜索。索引是在添加过程中就启动的。\\n\\n#### Logstash\\n\\nLogstash 是 ELK 的核心菜品，可以对数据进行聚合和处理。并将数据发送到 ES 中。Logstash 是一个开源的服务器端数据处理管道。\\n\\n#### Kibana\\n\\nKibana 是一款 ES 的数据可视化和管理工具，可以提供直方图，线形图，饼状图，地图。Kibana 还包含 Canvas 和 Elastic Maps 等应用程序。Canvas 可以基于用户创建动态信息。Elastic Maps 可以对空间数据进行可视化处理。\\n\\n#### 为什么要使用 ES\\n\\n- **ES 很快**：ES 是在 Lucene 基础上构建，所以全文本搜索相当的出色。ES 还是一个实时搜索平台。文档索引操作到文档变为可搜索之间速度很快。\\n- **ES 具有分布式的特征**：ES 中保存的文档分布在不同的容器中，这些容器为分片，可以对分片进行复制并形成冗余副本。ES 可以扩充到数百台，并处理 PB 级别的数据。\\n- **ES 包含一系列广泛的功能**：ES 拥有大量的内置功能，方便用户管理数据。\\n- **ES 简化了数据采集，可视化报告的过程**：通过与 Beats 和 Logstash 集成，用户可以在 ES 中索引数据并处理数据，\\n\\n### ES 搭建\\n\\n安装镜像：\\n\\n```\\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n启动容器：\\n\\n```\\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \\\"discovery.type=single-node\\\" docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n修改配置：\\n\\n```\\n#进入 docker 容器内部\\n\\ndocker exec -it es /bin/bash\\n\\n#打开配置文件\\n\\nvim config/elasticsearch.yml\\n\\n### 加入跨域配置\\n\\nhttp.cors.enabled: true\\n\\nhttp.cors.allow-origin: \\\"*\\\"\\n```\\n\\n进入容器，安装分词器：\\n\\n```\\n', '更新博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 19, '2024-12-18 09:39:32', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (35, 'admin', '/admin/blog', 'PUT', '{\"blog\":{\"id\":2,\"title\":\"ElasticSearch 小白从入门到精通\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.png\",\"content\":\"### 什么是 ElasticSearch\\n\\nElasticSearch 简称为 ES，网址为：\\n\\n> https://www.elastic.co/\\n\\nES 是一个分布式的开源搜索和分析引擎，适用于文本、数字、地理空间、结构化数据、非结构化数据等数据的搜索。ES 是在 Apache Lucene 的基础上完成开发。由 Elastic 于 2010 年发布。ES 通过其简单的 REST 风格的 API、分布式特性、速度和可扩容闻名世界。是 Elastic Stack 的核心组件。Elastic Stack 是一套用于数据采集、扩充、保存、分析、可视化的开源工具。Elastic Stack 称之为 ELK。目前 ELK 包含一系列丰富的轻量数据采集代理，这些代理被称之为 Beats。\\n\\n#### ES 的用途\\n\\n主要有以下的用途：\\n\\n- 应用程序搜索\\n- 网站搜索\\n- 企业搜索\\n- 日志处理\\n- 基础设施指标和容器监测\\n- 应用程序性能监测\\n- 地理空间数据分析和可视化\\n- 安全分析\\n- 业务分析\\n\\n#### 工作原理\\n\\n从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，在 Kibana 中，用户可以创建数据可视化面板，并对 ELK 进行管理。\\n\\n#### 索引\\n\\nES 索引是指相互关联的文档集合。ES 是会以 JSON 文档的形式保存数据，每个文档都会在一组键值对中建立联系。\\n\\nES 使用的是一种倒排序索引的数据结构。这个结构可以允许十分快速的进行全文本的搜索。\\n\\n在索引的过程中，ES 会保存文档并构建倒排序索引，这样用户就可以实时的对文档数据进行搜索。索引是在添加过程中就启动的。\\n\\n#### Logstash\\n\\nLogstash 是 ELK 的核心菜品，可以对数据进行聚合和处理。并将数据发送到 ES 中。Logstash 是一个开源的服务器端数据处理管道。\\n\\n#### Kibana\\n\\nKibana 是一款 ES 的数据可视化和管理工具，可以提供直方图，线形图，饼状图，地图。Kibana 还包含 Canvas 和 Elastic Maps 等应用程序。Canvas 可以基于用户创建动态信息。Elastic Maps 可以对空间数据进行可视化处理。\\n\\n#### 为什么要使用 ES\\n\\n- **ES 很快**：ES 是在 Lucene 基础上构建，所以全文本搜索相当的出色。ES 还是一个实时搜索平台。文档索引操作到文档变为可搜索之间速度很快。\\n- **ES 具有分布式的特征**：ES 中保存的文档分布在不同的容器中，这些容器为分片，可以对分片进行复制并形成冗余副本。ES 可以扩充到数百台，并处理 PB 级别的数据。\\n- **ES 包含一系列广泛的功能**：ES 拥有大量的内置功能，方便用户管理数据。\\n- **ES 简化了数据采集，可视化报告的过程**：通过与 Beats 和 Logstash 集成，用户可以在 ES 中索引数据并处理数据，\\n\\n### ES 搭建\\n\\n安装镜像：\\n\\n```\\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n启动容器：\\n\\n```\\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \\\"discovery.type=single-node\\\" docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n修改配置：\\n\\n```\\n#进入 docker 容器内部\\n\\ndocker exec -it es /bin/bash\\n\\n#打开配置文件\\n\\nvim config/elasticsearch.yml\\n\\n### 加入跨域配置\\n\\nhttp.cors.enabled: true\\n\\nhttp.cors.allow-origin: \\\"*\\\"\\n```\\n\\n进入容器，安装分词器：\\n\\n```\\n', '更新博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 23, '2024-12-18 09:40:43', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (36, 'admin', '/admin/blog', 'PUT', '{\"blog\":{\"id\":2,\"title\":\"ElasticSearch 小白从入门到精通\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.png\",\"content\":\"### 什么是 ElasticSearch\\n\\nElasticSearch 简称为 ES，网址为：\\n\\n> https://www.elastic.co/\\n\\nES 是一个分布式的开源搜索和分析引擎，适用于文本、数字、地理空间、结构化数据、非结构化数据等数据的搜索。ES 是在 Apache Lucene 的基础上完成开发。由 Elastic 于 2010 年发布。ES 通过其简单的 REST 风格的 API、分布式特性、速度和可扩容闻名世界。是 Elastic Stack 的核心组件。Elastic Stack 是一套用于数据采集、扩充、保存、分析、可视化的开源工具。Elastic Stack 称之为 ELK。目前 ELK 包含一系列丰富的轻量数据采集代理，这些代理被称之为 Beats。\\n\\n#### ES 的用途\\n\\n主要有以下的用途：\\n\\n- 应用程序搜索\\n- 网站搜索\\n- 企业搜索\\n- 日志处理\\n- 基础设施指标和容器监测\\n- 应用程序性能监测\\n- 地理空间数据分析和可视化\\n- 安全分析\\n- 业务分析\\n\\n#### 工作原理\\n\\n从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，在 Kibana 中，用户可以创建数据可视化面板，并对 ELK 进行管理。\\n\\n#### 索引\\n\\nES 索引是指相互关联的文档集合。ES 是会以 JSON 文档的形式保存数据，每个文档都会在一组键值对中建立联系。\\n\\nES 使用的是一种倒排序索引的数据结构。这个结构可以允许十分快速的进行全文本的搜索。\\n\\n在索引的过程中，ES 会保存文档并构建倒排序索引，这样用户就可以实时的对文档数据进行搜索。索引是在添加过程中就启动的。\\n\\n#### Logstash\\n\\nLogstash 是 ELK 的核心菜品，可以对数据进行聚合和处理。并将数据发送到 ES 中。Logstash 是一个开源的服务器端数据处理管道。\\n\\n#### Kibana\\n\\nKibana 是一款 ES 的数据可视化和管理工具，可以提供直方图，线形图，饼状图，地图。Kibana 还包含 Canvas 和 Elastic Maps 等应用程序。Canvas 可以基于用户创建动态信息。Elastic Maps 可以对空间数据进行可视化处理。\\n\\n#### 为什么要使用 ES\\n\\n- **ES 很快**：ES 是在 Lucene 基础上构建，所以全文本搜索相当的出色。ES 还是一个实时搜索平台。文档索引操作到文档变为可搜索之间速度很快。\\n- **ES 具有分布式的特征**：ES 中保存的文档分布在不同的容器中，这些容器为分片，可以对分片进行复制并形成冗余副本。ES 可以扩充到数百台，并处理 PB 级别的数据。\\n- **ES 包含一系列广泛的功能**：ES 拥有大量的内置功能，方便用户管理数据。\\n- **ES 简化了数据采集，可视化报告的过程**：通过与 Beats 和 Logstash 集成，用户可以在 ES 中索引数据并处理数据，\\n\\n### ES 搭建\\n\\n安装镜像：\\n\\n```\\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n启动容器：\\n\\n```\\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \\\"discovery.type=single-node\\\" docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n修改配置：\\n\\n```\\n#进入 docker 容器内部\\n\\ndocker exec -it es /bin/bash\\n\\n#打开配置文件\\n\\nvim config/elasticsearch.yml\\n\\n### 加入跨域配置\\n\\nhttp.cors.enabled: true\\n\\nhttp.cors.allow-origin: \\\"*\\\"\\n```\\n\\n进入容器，安装分词器：\\n\\n```\\n', '更新博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 20, '2024-12-18 09:42:25', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (37, 'admin', '/admin/blog', 'PUT', '{\"blog\":{\"id\":2,\"title\":\"ElasticSearch 小白从入门到精通\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.png\",\"content\":\"### 什么是 ElasticSearch\\n\\nElasticSearch 简称为 ES，网址为：\\n\\n> https://www.elastic.co/\\n\\nES 是一个分布式的开源搜索和分析引擎，适用于文本、数字、地理空间、结构化数据、非结构化数据等数据的搜索。ES 是在 Apache Lucene 的基础上完成开发。由 Elastic 于 2010 年发布。ES 通过其简单的 REST 风格的 API、分布式特性、速度和可扩容闻名世界。是 Elastic Stack 的核心组件。Elastic Stack 是一套用于数据采集、扩充、保存、分析、可视化的开源工具。Elastic Stack 称之为 ELK。目前 ELK 包含一系列丰富的轻量数据采集代理，这些代理被称之为 Beats。\\n\\n#### ES 的用途\\n\\n主要有以下的用途：\\n\\n- 应用程序搜索\\n- 网站搜索\\n- 企业搜索\\n- 日志处理\\n- 基础设施指标和容器监测\\n- 应用程序性能监测\\n- 地理空间数据分析和可视化\\n- 安全分析\\n- 业务分析\\n\\n#### 工作原理\\n\\n从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，在 Kibana 中，用户可以创建数据可视化面板，并对 ELK 进行管理。\\n\\n#### 索引\\n\\nES 索引是指相互关联的文档集合。ES 是会以 JSON 文档的形式保存数据，每个文档都会在一组键值对中建立联系。\\n\\nES 使用的是一种倒排序索引的数据结构。这个结构可以允许十分快速的进行全文本的搜索。\\n\\n在索引的过程中，ES 会保存文档并构建倒排序索引，这样用户就可以实时的对文档数据进行搜索。索引是在添加过程中就启动的。\\n\\n#### Logstash\\n\\nLogstash 是 ELK 的核心菜品，可以对数据进行聚合和处理。并将数据发送到 ES 中。Logstash 是一个开源的服务器端数据处理管道。\\n\\n#### Kibana\\n\\nKibana 是一款 ES 的数据可视化和管理工具，可以提供直方图，线形图，饼状图，地图。Kibana 还包含 Canvas 和 Elastic Maps 等应用程序。Canvas 可以基于用户创建动态信息。Elastic Maps 可以对空间数据进行可视化处理。\\n\\n#### 为什么要使用 ES\\n\\n- **ES 很快**：ES 是在 Lucene 基础上构建，所以全文本搜索相当的出色。ES 还是一个实时搜索平台。文档索引操作到文档变为可搜索之间速度很快。\\n- **ES 具有分布式的特征**：ES 中保存的文档分布在不同的容器中，这些容器为分片，可以对分片进行复制并形成冗余副本。ES 可以扩充到数百台，并处理 PB 级别的数据。\\n- **ES 包含一系列广泛的功能**：ES 拥有大量的内置功能，方便用户管理数据。\\n- **ES 简化了数据采集，可视化报告的过程**：通过与 Beats 和 Logstash 集成，用户可以在 ES 中索引数据并处理数据，\\n\\n### ES 搭建\\n\\n安装镜像：\\n\\n```\\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n启动容器：\\n\\n```\\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \\\"discovery.type=single-node\\\" docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n修改配置：\\n\\n```\\n#进入 docker 容器内部\\n\\ndocker exec -it es /bin/bash\\n\\n#打开配置文件\\n\\nvim config/elasticsearch.yml\\n\\n### 加入跨域配置\\n\\nhttp.cors.enabled: true\\n\\nhttp.cors.allow-origin: \\\"*\\\"\\n```\\n\\n进入容器，安装分词器：\\n\\n```\\n', '更新博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 27, '2024-12-18 09:45:59', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (38, 'admin', '/admin/blog', 'PUT', '{\"blog\":{\"id\":2,\"title\":\"ElasticSearch 小白从入门到精通\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.png\",\"content\":\"### 什么是 ElasticSearch\\n\\nElasticSearch 简称为 ES，网址为：\\n\\n> https://www.elastic.co/\\n\\nES 是一个分布式的开源搜索和分析引擎，适用于文本、数字、地理空间、结构化数据、非结构化数据等数据的搜索。ES 是在 Apache Lucene 的基础上完成开发。由 Elastic 于 2010 年发布。ES 通过其简单的 REST 风格的 API、分布式特性、速度和可扩容闻名世界。是 Elastic Stack 的核心组件。Elastic Stack 是一套用于数据采集、扩充、保存、分析、可视化的开源工具。Elastic Stack 称之为 ELK。目前 ELK 包含一系列丰富的轻量数据采集代理，这些代理被称之为 Beats。\\n\\n#### ES 的用途\\n\\n主要有以下的用途：\\n\\n- 应用程序搜索\\n- 网站搜索\\n- 企业搜索\\n- 日志处理\\n- 基础设施指标和容器监测\\n- 应用程序性能监测\\n- 地理空间数据分析和可视化\\n- 安全分析\\n- 业务分析\\n\\n#### 工作原理\\n\\n从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，在 Kibana 中，用户可以创建数据可视化面板，并对 ELK 进行管理。\\n\\n#### 索引\\n\\nES 索引是指相互关联的文档集合。ES 是会以 JSON 文档的形式保存数据，每个文档都会在一组键值对中建立联系。\\n\\nES 使用的是一种倒排序索引的数据结构。这个结构可以允许十分快速的进行全文本的搜索。\\n\\n在索引的过程中，ES 会保存文档并构建倒排序索引，这样用户就可以实时的对文档数据进行搜索。索引是在添加过程中就启动的。\\n\\n#### Logstash\\n\\nLogstash 是 ELK 的核心菜品，可以对数据进行聚合和处理。并将数据发送到 ES 中。Logstash 是一个开源的服务器端数据处理管道。\\n\\n#### Kibana\\n\\nKibana 是一款 ES 的数据可视化和管理工具，可以提供直方图，线形图，饼状图，地图。Kibana 还包含 Canvas 和 Elastic Maps 等应用程序。Canvas 可以基于用户创建动态信息。Elastic Maps 可以对空间数据进行可视化处理。\\n\\n#### 为什么要使用 ES\\n\\n- **ES 很快**：ES 是在 Lucene 基础上构建，所以全文本搜索相当的出色。ES 还是一个实时搜索平台。文档索引操作到文档变为可搜索之间速度很快。\\n- **ES 具有分布式的特征**：ES 中保存的文档分布在不同的容器中，这些容器为分片，可以对分片进行复制并形成冗余副本。ES 可以扩充到数百台，并处理 PB 级别的数据。\\n- **ES 包含一系列广泛的功能**：ES 拥有大量的内置功能，方便用户管理数据。\\n- **ES 简化了数据采集，可视化报告的过程**：通过与 Beats 和 Logstash 集成，用户可以在 ES 中索引数据并处理数据，\\n\\n### ES 搭建\\n\\n安装镜像：\\n\\n```\\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n启动容器：\\n\\n```\\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \\\"discovery.type=single-node\\\" docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n修改配置：\\n\\n```\\n#进入 docker 容器内部\\n\\ndocker exec -it es /bin/bash\\n\\n#打开配置文件\\n\\nvim config/elasticsearch.yml\\n\\n### 加入跨域配置\\n\\nhttp.cors.enabled: true\\n\\nhttp.cors.allow-origin: \\\"*\\\"\\n```\\n\\n进入容器，安装分词器：\\n\\n```\\n', '更新博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 18, '2024-12-18 09:46:44', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (39, 'admin', '/admin/blog', 'PUT', '{\"blog\":{\"id\":2,\"title\":\"ElasticSearch 小白从入门到精通\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.png\",\"content\":\"### 什么是 ElasticSearch\\n\\nElasticSearch 简称为 ES，网址为：\\n\\n> https://www.elastic.co/\\n\\nES 是一个分布式的开源搜索和分析引擎，适用于文本、数字、地理空间、结构化数据、非结构化数据等数据的搜索。ES 是在 Apache Lucene 的基础上完成开发。由 Elastic 于 2010 年发布。ES 通过其简单的 REST 风格的 API、分布式特性、速度和可扩容闻名世界。是 Elastic Stack 的核心组件。Elastic Stack 是一套用于数据采集、扩充、保存、分析、可视化的开源工具。Elastic Stack 称之为 ELK。目前 ELK 包含一系列丰富的轻量数据采集代理，这些代理被称之为 Beats。\\n\\n#### ES 的用途\\n\\n主要有以下的用途：\\n\\n- 应用程序搜索\\n- 网站搜索\\n- 企业搜索\\n- 日志处理\\n- 基础设施指标和容器监测\\n- 应用程序性能监测\\n- 地理空间数据分析和可视化\\n- 安全分析\\n- 业务分析\\n\\n#### 工作原理\\n\\n从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，在 Kibana 中，用户可以创建数据可视化面板，并对 ELK 进行管理。\\n\\n#### 索引\\n\\nES 索引是指相互关联的文档集合。ES 是会以 JSON 文档的形式保存数据，每个文档都会在一组键值对中建立联系。\\n\\nES 使用的是一种倒排序索引的数据结构。这个结构可以允许十分快速的进行全文本的搜索。\\n\\n在索引的过程中，ES 会保存文档并构建倒排序索引，这样用户就可以实时的对文档数据进行搜索。索引是在添加过程中就启动的。\\n\\n#### Logstash\\n\\nLogstash 是 ELK 的核心菜品，可以对数据进行聚合和处理。并将数据发送到 ES 中。Logstash 是一个开源的服务器端数据处理管道。\\n\\n#### Kibana\\n\\nKibana 是一款 ES 的数据可视化和管理工具，可以提供直方图，线形图，饼状图，地图。Kibana 还包含 Canvas 和 Elastic Maps 等应用程序。Canvas 可以基于用户创建动态信息。Elastic Maps 可以对空间数据进行可视化处理。\\n\\n#### 为什么要使用 ES\\n\\n- **ES 很快**：ES 是在 Lucene 基础上构建，所以全文本搜索相当的出色。ES 还是一个实时搜索平台。文档索引操作到文档变为可搜索之间速度很快。\\n- **ES 具有分布式的特征**：ES 中保存的文档分布在不同的容器中，这些容器为分片，可以对分片进行复制并形成冗余副本。ES 可以扩充到数百台，并处理 PB 级别的数据。\\n- **ES 包含一系列广泛的功能**：ES 拥有大量的内置功能，方便用户管理数据。\\n- **ES 简化了数据采集，可视化报告的过程**：通过与 Beats 和 Logstash 集成，用户可以在 ES 中索引数据并处理数据，\\n\\n### ES 搭建\\n\\n安装镜像：\\n\\n```\\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n启动容器：\\n\\n```\\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \\\"discovery.type=single-node\\\" docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n修改配置：\\n\\n```\\n#进入 docker 容器内部\\n\\ndocker exec -it es /bin/bash\\n\\n#打开配置文件\\n\\nvim config/elasticsearch.yml\\n\\n### 加入跨域配置\\n\\nhttp.cors.enabled: true\\n\\nhttp.cors.allow-origin: \\\"*\\\"\\n```\\n\\n进入容器，安装分词器：\\n\\n```\\n', '更新博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 25, '2024-12-18 10:14:39', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (40, 'admin', '/admin/blog', 'PUT', '{\"blog\":{\"id\":2,\"title\":\"ElasticSearch 小白从入门到精通\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.png\",\"content\":\"### 什么是 ElasticSearch\\n\\nElasticSearch 简称为 ES，网址为：\\n\\n> https://www.elastic.co/\\n\\nES 是一个分布式的开源搜索和分析引擎，适用于文本、数字、地理空间、结构化数据、非结构化数据等数据的搜索。ES 是在 Apache Lucene 的基础上完成开发。由 Elastic 于 2010 年发布。ES 通过其简单的 REST 风格的 API、分布式特性、速度和可扩容闻名世界。是 Elastic Stack 的核心组件。Elastic Stack 是一套用于数据采集、扩充、保存、分析、可视化的开源工具。Elastic Stack 称之为 ELK。目前 ELK 包含一系列丰富的轻量数据采集代理，这些代理被称之为 Beats。\\n\\n#### ES 的用途\\n\\n主要有以下的用途：\\n\\n- 应用程序搜索\\n- 网站搜索\\n- 企业搜索\\n- 日志处理\\n- 基础设施指标和容器监测\\n- 应用程序性能监测\\n- 地理空间数据分析和可视化\\n- 安全分析\\n- 业务分析\\n\\n#### 工作原理\\n\\n从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，在 Kibana 中，用户可以创建数据可视化面板，并对 ELK 进行管理。\\n\\n#### 索引\\n\\nES 索引是指相互关联的文档集合。ES 是会以 JSON 文档的形式保存数据，每个文档都会在一组键值对中建立联系。\\n\\nES 使用的是一种倒排序索引的数据结构。这个结构可以允许十分快速的进行全文本的搜索。\\n\\n在索引的过程中，ES 会保存文档并构建倒排序索引，这样用户就可以实时的对文档数据进行搜索。索引是在添加过程中就启动的。\\n\\n#### Logstash\\n\\nLogstash 是 ELK 的核心菜品，可以对数据进行聚合和处理。并将数据发送到 ES 中。Logstash 是一个开源的服务器端数据处理管道。\\n\\n#### Kibana\\n\\nKibana 是一款 ES 的数据可视化和管理工具，可以提供直方图，线形图，饼状图，地图。Kibana 还包含 Canvas 和 Elastic Maps 等应用程序。Canvas 可以基于用户创建动态信息。Elastic Maps 可以对空间数据进行可视化处理。\\n\\n#### 为什么要使用 ES\\n\\n- **ES 很快**：ES 是在 Lucene 基础上构建，所以全文本搜索相当的出色。ES 还是一个实时搜索平台。文档索引操作到文档变为可搜索之间速度很快。\\n- **ES 具有分布式的特征**：ES 中保存的文档分布在不同的容器中，这些容器为分片，可以对分片进行复制并形成冗余副本。ES 可以扩充到数百台，并处理 PB 级别的数据。\\n- **ES 包含一系列广泛的功能**：ES 拥有大量的内置功能，方便用户管理数据。\\n- **ES 简化了数据采集，可视化报告的过程**：通过与 Beats 和 Logstash 集成，用户可以在 ES 中索引数据并处理数据，\\n\\n### ES 搭建\\n\\n安装镜像：\\n\\n```bash\\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n启动容器：\\n\\n```bash\\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \\\"discovery.type=single-node\\\" docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n修改配置：\\n\\n```\\n#进入 docker 容器内部\\n\\ndocker exec -it es /bin/bash\\n\\n#打开配置文件\\n\\nvim config/elasticsearch.yml\\n\\n### 加入跨域配置\\n\\nhttp.cors.enabled: true\\n\\nhttp.cors.allow-origin: \\\"*\\\"\\n```\\n\\n进入容器，安装分词器：\\', '更新博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 35, '2024-12-18 13:36:05', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (41, 'admin', '/admin/blog', 'PUT', '{\"blog\":{\"id\":2,\"title\":\"ElasticSearch 小白从入门到精通\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.png\",\"content\":\"### 什么是 ElasticSearch\\n\\nElasticSearch 简称为 ES，网址为：\\n\\n> https://www.elastic.co/\\n\\nES 是一个分布式的开源搜索和分析引擎，适用于文本、数字、地理空间、结构化数据、非结构化数据等数据的搜索。ES 是在 Apache Lucene 的基础上完成开发。由 Elastic 于 2010 年发布。ES 通过其简单的 REST 风格的 API、分布式特性、速度和可扩容闻名世界。是 Elastic Stack 的核心组件。Elastic Stack 是一套用于数据采集、扩充、保存、分析、可视化的开源工具。Elastic Stack 称之为 ELK。目前 ELK 包含一系列丰富的轻量数据采集代理，这些代理被称之为 Beats。\\n\\n#### ES 的用途\\n\\n主要有以下的用途：\\n\\n- 应用程序搜索\\n- 网站搜索\\n- 企业搜索\\n- 日志处理\\n- 基础设施指标和容器监测\\n- 应用程序性能监测\\n- 地理空间数据分析和可视化\\n- 安全分析\\n- 业务分析\\n\\n#### 工作原理\\n\\n从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，在 Kibana 中，用户可以创建数据可视化面板，并对 ELK 进行管理。\\n\\n#### 索引\\n\\nES 索引是指相互关联的文档集合。ES 是会以 JSON 文档的形式保存数据，每个文档都会在一组键值对中建立联系。\\n\\nES 使用的是一种倒排序索引的数据结构。这个结构可以允许十分快速的进行全文本的搜索。\\n\\n在索引的过程中，ES 会保存文档并构建倒排序索引，这样用户就可以实时的对文档数据进行搜索。索引是在添加过程中就启动的。\\n\\n#### Logstash\\n\\nLogstash 是 ELK 的核心菜品，可以对数据进行聚合和处理。并将数据发送到 ES 中。Logstash 是一个开源的服务器端数据处理管道。\\n\\n#### Kibana\\n\\nKibana 是一款 ES 的数据可视化和管理工具，可以提供直方图，线形图，饼状图，地图。Kibana 还包含 Canvas 和 Elastic Maps 等应用程序。Canvas 可以基于用户创建动态信息。Elastic Maps 可以对空间数据进行可视化处理。\\n\\n#### 为什么要使用 ES\\n\\n- **ES 很快**：ES 是在 Lucene 基础上构建，所以全文本搜索相当的出色。ES 还是一个实时搜索平台。文档索引操作到文档变为可搜索之间速度很快。\\n- **ES 具有分布式的特征**：ES 中保存的文档分布在不同的容器中，这些容器为分片，可以对分片进行复制并形成冗余副本。ES 可以扩充到数百台，并处理 PB 级别的数据。\\n- **ES 包含一系列广泛的功能**：ES 拥有大量的内置功能，方便用户管理数据。\\n- **ES 简化了数据采集，可视化报告的过程**：通过与 Beats 和 Logstash 集成，用户可以在 ES 中索引数据并处理数据，\\n\\n### ES 搭建\\n\\n安装镜像：\\n\\n```bash\\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n启动容器：\\n\\n```bash\\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \\\"discovery.type=single-node\\\" docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n修改配置：\\n\\n```bash\\n#进入 docker 容器内部\\n\\ndocker exec -it es /bin/bash\\n\\n#打开配置文件\\n\\nvim config/elasticsearch.yml\\n\\n### 加入跨域配置\\n\\nhttp.cors.enabled: true\\n\\nhttp.cors.allow-origin: \\\"*\\\"\\n```\\n\\n进入容器，安装分', '更新博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 19, '2024-12-18 13:36:50', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (42, 'admin', '/admin/blog', 'PUT', '{\"blog\":{\"id\":2,\"title\":\"ElasticSearch 小白从入门到精通\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.png\",\"content\":\"### 什么是 ElasticSearch\\n\\nElasticSearch 简称为 ES，网址为：\\n\\n> https://www.elastic.co/\\n\\nES 是一个分布式的开源搜索和分析引擎，适用于文本、数字、地理空间、结构化数据、非结构化数据等数据的搜索。ES 是在 Apache Lucene 的基础上完成开发。由 Elastic 于 2010 年发布。ES 通过其简单的 REST 风格的 API、分布式特性、速度和可扩容闻名世界。是 Elastic Stack 的核心组件。Elastic Stack 是一套用于数据采集、扩充、保存、分析、可视化的开源工具。Elastic Stack 称之为 ELK。目前 ELK 包含一系列丰富的轻量数据采集代理，这些代理被称之为 Beats。\\n\\n#### ES 的用途\\n\\n主要有以下的用途：\\n\\n- 应用程序搜索\\n- 网站搜索\\n- 企业搜索\\n- 日志处理\\n- 基础设施指标和容器监测\\n- 应用程序性能监测\\n- 地理空间数据分析和可视化\\n- 安全分析\\n- 业务分析\\n\\n#### 工作原理\\n\\n从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，在 Kibana 中，用户可以创建数据可视化面板，并对 ELK 进行管理。\\n\\n#### 索引\\n\\nES 索引是指相互关联的文档集合。ES 是会以 JSON 文档的形式保存数据，每个文档都会在一组键值对中建立联系。\\n\\nES 使用的是一种倒排序索引的数据结构。这个结构可以允许十分快速的进行全文本的搜索。\\n\\n在索引的过程中，ES 会保存文档并构建倒排序索引，这样用户就可以实时的对文档数据进行搜索。索引是在添加过程中就启动的。\\n\\n#### Logstash\\n\\nLogstash 是 ELK 的核心菜品，可以对数据进行聚合和处理。并将数据发送到 ES 中。Logstash 是一个开源的服务器端数据处理管道。\\n\\n#### Kibana\\n\\nKibana 是一款 ES 的数据可视化和管理工具，可以提供直方图，线形图，饼状图，地图。Kibana 还包含 Canvas 和 Elastic Maps 等应用程序。Canvas 可以基于用户创建动态信息。Elastic Maps 可以对空间数据进行可视化处理。\\n\\n#### 为什么要使用 ES\\n\\n- **ES 很快**：ES 是在 Lucene 基础上构建，所以全文本搜索相当的出色。ES 还是一个实时搜索平台。文档索引操作到文档变为可搜索之间速度很快。\\n- **ES 具有分布式的特征**：ES 中保存的文档分布在不同的容器中，这些容器为分片，可以对分片进行复制并形成冗余副本。ES 可以扩充到数百台，并处理 PB 级别的数据。\\n- **ES 包含一系列广泛的功能**：ES 拥有大量的内置功能，方便用户管理数据。\\n- **ES 简化了数据采集，可视化报告的过程**：通过与 Beats 和 Logstash 集成，用户可以在 ES 中索引数据并处理数据，\\n\\n### ES 搭建\\n\\n安装镜像：\\n\\n```bash\\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n启动容器：\\n\\n```bash\\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \\\"discovery.type=single-node\\\" docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n修改配置：\\n\\n```bash\\n#进入 docker 容器内部\\n\\ndocker exec -it es /bin/bash\\n\\n#打开配置文件\\n\\nvim config/elasticsearch.yml\\n\\n### 加入跨域配置\\n\\nhttp.cors.enabled: true\\n\\nhttp.cors.allow-origin: \\\"*\\\"\\n```\\n\\n进入容器，安装分', '更新博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 23, '2024-12-18 13:37:57', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (43, 'admin', '/admin/blog', 'POST', '{\"blog\":{\"id\":3,\"title\":\"Java中的ThreadLocal\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/20200910083829900.png\",\"content\":\"## 前言\\n\\n面试的时候被问到ThreadLocal的相关知识，没有回答好（奶奶的，现在感觉问啥都能被问倒），所以我决定先解决这几次面试中都遇到的高频问题，把这几个硬骨头都能理解的透彻的说出来了，感觉最起码不能总是一轮游。\\n\\n### ThreadLocal介绍\\n\\nThreadLocal是JDK1.2开始就提供的一个用来存储线程本地变量的类。ThreadLocal中的变量是在每个线程中独立存在的，当多个线程访问ThreadLocal中的变量的时候，其实都是访问的自己当前线程的内存中的变量，从而保证的变量的线程安全。\\n\\n我们一般在使用ThreadLocal的时候都是为了解决线程中存在的变量竞争问题。其实解决这类问题，通常大家也会想到使用synchronized来加锁解决。\\n\\n例如在解决SimpleDateFormat的线程安全的时候。SimpleDateFormat是非线程安全的，它里面无论的是format()方法还是parse()方法，都有使用它自己内部的一个Calendar类的对象，format方法是设置时间，parse()方法里面是先调用Calendar的clear()方法，然后又调用了Calendar的set()方法（赋值），如果一个线程刚调用了set()进行赋值，这个时候又来了一个线程直接调用了clear()方法，那么这个parse()方法执行的结果就会有问题的。\\n**解决办法一**\\n将使用SimpleDateformat的方法加上synchronized，这样虽然保证了线程安全，但却降低了效率，同一时间只有一个线程能使用格式化时间的方法。\\n\\n```\\nprivate static SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\\\"yyyy-MM-dd HH:mm:ss\\\");\\n\\npublic static synchronized String formatDate(Date date){\\n    return simpleDateFormat.format(date);\\n}\\n```\\n\\n**解决办法二**\\n将SimpleDateFormat的对象，放到ThreadLocal里面，这样每个线程中都有一个自己的格式对象的副本了。互不干扰，从而保证了线程安全。\\n\\n```\\nprivate static final ThreadLocal<SimpleDateFormat> simpleDateFormatThreadLocal = ThreadLocal.withInitial(() -> new SimpleDateFormat(\\\"yyyy-MM-dd HH:mm:ss\\\"));\\n\\npublic static String formatDate(Date date){\\n   return simpleDateFormatThreadLocal.get().format(date);\\n}\\n```\\n\\n### ThreadLocal的原理\\n\\n我们先看一下ThreadLocal是怎么使用的。\\n\\n```\\nThreadLocal<Integer> threadLocal99 = new ThreadLocal<Integer>();\\nthreadLocal99.set(3);\\nint num = threadLocal99.get();\\nSystem.out.println(\\\"数字:\\\"+num);\\nthreadLocal99.remove();\\nSystem.out.println(\\\"数字Empty:\\\"+threadLocal99.get());\\n```\\n\\n运行结果：\\n\\n```\\n数字:3\\n数字Empty:null\\n```\\n\\n使用起来很简单，主要是将变量放到ThreadLocal里面，在线程执行过程中就可以取到，当执行完成后在remove掉就可以了，只要没有调用remove()当前线程在执行过程中都是可以拿到变量数据的。\\n因为是放到了当前执行的线程中，所以ThreadLocal中的变量值只能当前线程来使用，从而保证的了线程安全（当前线程的子线程其实也是可以获取到的）。\\n\\n来看一下ThreadLocal的set()方法源码\\n\\n```\\npubl', '发布博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 23, '2024-12-18 13:49:48', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (44, 'admin', '/admin/category', 'PUT', '{\"category\":{\"id\":1,\"name\":\"前端\",\"blogs\":[]}}', '修改分类', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-18 13:55:12', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (45, 'admin', '/admin/category', 'DELETE', '{\"id\":5}', '删除分类', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-18 13:55:17', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (46, 'admin', '/admin/category', 'DELETE', '{\"id\":4}', '删除分类', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-18 13:55:21', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (47, 'admin', '/admin/category', 'DELETE', '{\"id\":3}', '删除分类', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 2, '2024-12-18 13:55:23', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (48, 'admin', '/admin/blog', 'DELETE', '{\"id\":2}', '删除博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 19, '2024-12-18 13:55:36', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (49, 'admin', '/admin/blog', 'DELETE', '{\"id\":3}', '删除博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 16, '2024-12-18 13:55:39', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (50, 'admin', '/admin/category', 'DELETE', '{\"id\":3}', '删除分类', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-18 13:55:47', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (51, 'admin', '/admin/category', 'DELETE', '{\"id\":2}', '删除分类', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-18 13:55:49', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (52, 'admin', '/admin/category', 'POST', '{\"category\":{\"id\":8,\"name\":\"后端\",\"blogs\":[]}}', '添加分类', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-18 13:56:03', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (53, 'admin', '/admin/category', 'POST', '{\"category\":{\"id\":9,\"name\":\"文章\",\"blogs\":[]}}', '添加分类', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 14, '2024-12-18 13:56:16', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (54, 'admin', '/admin/category', 'POST', '{\"category\":{\"id\":10,\"name\":\"专栏\",\"blogs\":[]}}', '添加分类', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 12, '2024-12-18 13:56:28', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (55, 'admin', '/admin/category', 'POST', '{\"category\":{\"id\":11,\"name\":\"其他\",\"blogs\":[]}}', '添加分类', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-18 13:56:38', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (56, 'admin', '/admin/category', 'PUT', '{\"category\":{\"id\":11,\"name\":\"其他\",\"blogs\":[]}}', '修改分类', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-18 13:56:41', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (57, 'admin', '/admin/blog', 'POST', '{\"blog\":{\"id\":4,\"title\":\"Java中的ThreadLocal\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/20200909231451433.png\",\"content\":\"# Java中的ThreadLocal\\n\\n## 前言\\n\\n面试的时候被问到ThreadLocal的相关知识，没有回答好（奶奶的，现在感觉问啥都能被问倒），所以我决定先解决这几次面试中都遇到的高频问题，把这几个硬骨头都能理解的透彻的说出来了，感觉最起码不能总是一轮游。\\n\\n### ThreadLocal介绍\\n\\nThreadLocal是JDK1.2开始就提供的一个用来存储线程本地变量的类。ThreadLocal中的变量是在每个线程中独立存在的，当多个线程访问ThreadLocal中的变量的时候，其实都是访问的自己当前线程的内存中的变量，从而保证的变量的线程安全。\\n\\n我们一般在使用ThreadLocal的时候都是为了解决线程中存在的变量竞争问题。其实解决这类问题，通常大家也会想到使用synchronized来加锁解决。\\n\\n例如在解决SimpleDateFormat的线程安全的时候。SimpleDateFormat是非线程安全的，它里面无论的是format()方法还是parse()方法，都有使用它自己内部的一个Calendar类的对象，format方法是设置时间，parse()方法里面是先调用Calendar的clear()方法，然后又调用了Calendar的set()方法（赋值），如果一个线程刚调用了set()进行赋值，这个时候又来了一个线程直接调用了clear()方法，那么这个parse()方法执行的结果就会有问题的。\\n**解决办法一**\\n将使用SimpleDateformat的方法加上synchronized，这样虽然保证了线程安全，但却降低了效率，同一时间只有一个线程能使用格式化时间的方法。\\n\\n```\\nprivate static SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\\\"yyyy-MM-dd HH:mm:ss\\\");\\n\\npublic static synchronized String formatDate(Date date){\\n    return simpleDateFormat.format(date);\\n}\\n```\\n\\n**解决办法二**\\n将SimpleDateFormat的对象，放到ThreadLocal里面，这样每个线程中都有一个自己的格式对象的副本了。互不干扰，从而保证了线程安全。\\n\\n```\\nprivate static final ThreadLocal<SimpleDateFormat> simpleDateFormatThreadLocal = ThreadLocal.withInitial(() -> new SimpleDateFormat(\\\"yyyy-MM-dd HH:mm:ss\\\"));\\n\\npublic static String formatDate(Date date){\\n   return simpleDateFormatThreadLocal.get().format(date);\\n}\\n```\\n\\n### ThreadLocal的原理\\n\\n我们先看一下ThreadLocal是怎么使用的。\\n\\n```\\nThreadLocal<Integer> threadLocal99 = new ThreadLocal<Integer>();\\nthreadLocal99.set(3);\\nint num = threadLocal99.get();\\nSystem.out.println(\\\"数字:\\\"+num);\\nthreadLocal99.remove();\\nSystem.out.println(\\\"数字Empty:\\\"+threadLocal99.get());\\n```\\n\\n运行结果：\\n\\n```\\n数字:3\\n数字Empty:null\\n```\\n\\n使用起来很简单，主要是将变量放到ThreadLocal里面，在线程执行过程中就可以取到，当执行完成后在remove掉就可以了，只要没有调用remove()当前线程在执行过程中都是可以拿到变量数据的。\\n因为是放到了当前执行的线程中，所以ThreadLocal中的变量值只能当前线程来使用，从而保证的了线程安全（当前线程的子线程其实也是可以获取到的）。\\n\\n来看一下ThreadLocal', '发布博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 18, '2024-12-18 14:09:18', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (58, 'admin', '/admin/blog', 'PUT', '{\"blog\":{\"id\":4,\"title\":\"Java中的ThreadLocal\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/20200909231451433.png\",\"content\":\"# Java中的ThreadLocal\\n\\n## 前言\\n\\n面试的时候被问到ThreadLocal的相关知识，没有回答好（奶奶的，现在感觉问啥都能被问倒），所以我决定先解决这几次面试中都遇到的高频问题，把这几个硬骨头都能理解的透彻的说出来了，感觉最起码不能总是一轮游。\\n\\n### ThreadLocal介绍\\n\\nThreadLocal是JDK1.2开始就提供的一个用来存储线程本地变量的类。ThreadLocal中的变量是在每个线程中独立存在的，当多个线程访问ThreadLocal中的变量的时候，其实都是访问的自己当前线程的内存中的变量，从而保证的变量的线程安全。\\n\\n我们一般在使用ThreadLocal的时候都是为了解决线程中存在的变量竞争问题。其实解决这类问题，通常大家也会想到使用synchronized来加锁解决。\\n\\n例如在解决SimpleDateFormat的线程安全的时候。SimpleDateFormat是非线程安全的，它里面无论的是format()方法还是parse()方法，都有使用它自己内部的一个Calendar类的对象，format方法是设置时间，parse()方法里面是先调用Calendar的clear()方法，然后又调用了Calendar的set()方法（赋值），如果一个线程刚调用了set()进行赋值，这个时候又来了一个线程直接调用了clear()方法，那么这个parse()方法执行的结果就会有问题的。\\n**解决办法一**\\n将使用SimpleDateformat的方法加上synchronized，这样虽然保证了线程安全，但却降低了效率，同一时间只有一个线程能使用格式化时间的方法。\\n\\n```\\nprivate static SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\\\"yyyy-MM-dd HH:mm:ss\\\");\\n\\npublic static synchronized String formatDate(Date date){\\n    return simpleDateFormat.format(date);\\n}\\n```\\n\\n**解决办法二**\\n将SimpleDateFormat的对象，放到ThreadLocal里面，这样每个线程中都有一个自己的格式对象的副本了。互不干扰，从而保证了线程安全。\\n\\n```\\nprivate static final ThreadLocal<SimpleDateFormat> simpleDateFormatThreadLocal = ThreadLocal.withInitial(() -> new SimpleDateFormat(\\\"yyyy-MM-dd HH:mm:ss\\\"));\\n\\npublic static String formatDate(Date date){\\n   return simpleDateFormatThreadLocal.get().format(date);\\n}\\n```\\n\\n### ThreadLocal的原理\\n\\n我们先看一下ThreadLocal是怎么使用的。\\n\\n```\\nThreadLocal<Integer> threadLocal99 = new ThreadLocal<Integer>();\\nthreadLocal99.set(3);\\nint num = threadLocal99.get();\\nSystem.out.println(\\\"数字:\\\"+num);\\nthreadLocal99.remove();\\nSystem.out.println(\\\"数字Empty:\\\"+threadLocal99.get());\\n```\\n\\n运行结果：\\n\\n```\\n数字:3\\n数字Empty:null\\n```\\n\\n使用起来很简单，主要是将变量放到ThreadLocal里面，在线程执行过程中就可以取到，当执行完成后在remove掉就可以了，只要没有调用remove()当前线程在执行过程中都是可以拿到变量数据的。\\n因为是放到了当前执行的线程中，所以ThreadLocal中的变量值只能当前线程来使用，从而保证的了线程安全（当前线程的子线程其实也是可以获取到的）。\\n\\n来看一下ThreadLocal', '更新博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 28, '2024-12-18 14:30:48', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (59, 'admin', '/admin/blog', 'PUT', '{\"blog\":{\"id\":4,\"title\":\"Java中的ThreadLocal\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/20200909231451433.png\",\"content\":\"# Java中的ThreadLocal\\n\\n## 前言\\n\\n面试的时候被问到ThreadLocal的相关知识，没有回答好（奶奶的，现在感觉问啥都能被问倒），所以我决定先解决这几次面试中都遇到的高频问题，把这几个硬骨头都能理解的透彻的说出来了，感觉最起码不能总是一轮游。\\n\\n### ThreadLocal介绍\\n\\nThreadLocal是JDK1.2开始就提供的一个用来存储线程本地变量的类。ThreadLocal中的变量是在每个线程中独立存在的，当多个线程访问ThreadLocal中的变量的时候，其实都是访问的自己当前线程的内存中的变量，从而保证的变量的线程安全。\\n\\n我们一般在使用ThreadLocal的时候都是为了解决线程中存在的变量竞争问题。其实解决这类问题，通常大家也会想到使用synchronized来加锁解决。\\n\\n例如在解决SimpleDateFormat的线程安全的时候。SimpleDateFormat是非线程安全的，它里面无论的是format()方法还是parse()方法，都有使用它自己内部的一个Calendar类的对象，format方法是设置时间，parse()方法里面是先调用Calendar的clear()方法，然后又调用了Calendar的set()方法（赋值），如果一个线程刚调用了set()进行赋值，这个时候又来了一个线程直接调用了clear()方法，那么这个parse()方法执行的结果就会有问题的。\\n**解决办法一**\\n将使用SimpleDateformat的方法加上synchronized，这样虽然保证了线程安全，但却降低了效率，同一时间只有一个线程能使用格式化时间的方法。\\n\\n```\\nprivate static SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\\\"yyyy-MM-dd HH:mm:ss\\\");\\n\\npublic static synchronized String formatDate(Date date){\\n    return simpleDateFormat.format(date);\\n}\\n```\\n\\n**解决办法二**\\n将SimpleDateFormat的对象，放到ThreadLocal里面，这样每个线程中都有一个自己的格式对象的副本了。互不干扰，从而保证了线程安全。\\n\\n```\\nprivate static final ThreadLocal<SimpleDateFormat> simpleDateFormatThreadLocal = ThreadLocal.withInitial(() -> new SimpleDateFormat(\\\"yyyy-MM-dd HH:mm:ss\\\"));\\n\\npublic static String formatDate(Date date){\\n   return simpleDateFormatThreadLocal.get().format(date);\\n}\\n```\\n\\n### ThreadLocal的原理\\n\\n我们先看一下ThreadLocal是怎么使用的。\\n\\n```java\\nThreadLocal<Integer> threadLocal99 = new ThreadLocal<Integer>();\\nthreadLocal99.set(3);\\nint num = threadLocal99.get();\\nSystem.out.println(\\\"数字:\\\"+num);\\nthreadLocal99.remove();\\nSystem.out.println(\\\"数字Empty:\\\"+threadLocal99.get());\\n```\\n\\n运行结果：\\n\\n```\\n数字:3\\n数字Empty:null\\n```\\n\\n使用起来很简单，主要是将变量放到ThreadLocal里面，在线程执行过程中就可以取到，当执行完成后在remove掉就可以了，只要没有调用remove()当前线程在执行过程中都是可以拿到变量数据的。\\n因为是放到了当前执行的线程中，所以ThreadLocal中的变量值只能当前线程来使用，从而保证的了线程安全（当前线程的子线程其实也是可以获取到的）。\\n\\n来看一下ThreadL', '更新博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 22, '2024-12-18 14:49:12', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (60, 'admin', '/admin/blog', 'DELETE', '{\"id\":4}', '删除博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 14, '2024-12-18 14:49:52', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (61, 'admin', '/admin/siteSettings', 'POST', '{\"map\":{\"settings\":[{\"id\":1,\"nameEn\":\"blogName\",\"nameZh\":\"博客名称\",\"value\":\"Youta\'s Blog\",\"type\":1},{\"id\":2,\"nameEn\":\"webTitleSuffix\",\"nameZh\":\"网页标题后缀\",\"value\":\" - Youta\'s Blog\",\"type\":1},{\"id\":3,\"nameEn\":\"footerImgTitle\",\"nameZh\":\"页脚图片标题\",\"value\":\"手机看本站\",\"type\":1},{\"id\":4,\"nameEn\":\"footerImgUrl\",\"nameZh\":\"页脚图片路径\",\"value\":\"/img/qr.png\",\"type\":1},{\"id\":5,\"nameEn\":\"copyright\",\"nameZh\":\"Copyright\",\"value\":\"{\\\"title\\\":\\\"Copyright © 2024 - 2025\\\",\\\"siteName\\\":\\\"YOUTA\'S BLOG\\\"}\",\"type\":1},{\"id\":6,\"nameEn\":\"beian\",\"nameZh\":\"ICP备案号\",\"value\":\"\",\"type\":1},{\"id\":7,\"nameEn\":\"reward\",\"nameZh\":\"赞赏码\",\"value\":\"/img/reward.jpg\",\"type\":1},{\"id\":8,\"nameEn\":\"commentAdminFlag\",\"nameZh\":\"博主评论标识\",\"value\":\"咕咕\",\"type\":1},{\"id\":9,\"nameEn\":\"playlistServer\",\"nameZh\":\"播放器平台\",\"value\":\"netease\",\"type\":1},{\"id\":10,\"nameEn\":\"playlistId\",\"nameZh\":\"播放器歌单\",\"value\":\"3071528549\",\"type\":1},{\"id\":11,\"nameEn\":\"avatar\",\"nameZh\":\"头像\",\"value\":\"/img/avatar.jpg\",\"type\":2},{\"id\":12,\"nameEn\":\"name\",\"nameZh\":\"昵称\",\"value\":\"Youta\",\"type\":2},{\"id\":13,\"nameEn\":\"rollText\",\"nameZh\":\"滚动个签\",\"value\":\"\\\"云鹤当归天，天不迎我妙木仙；\\\",\\\"游龙当归海，海不迎我自来也。\\\"\",\"type\":2},{\"id\":14,\"nameEn\":\"github\",\"nameZh\":\"GitHub\",\"value\":\"https://github.com/\",\"type\":2},{\"id\":15,\"nameEn\":\"telegram\",\"nameZh\":\"Telegram\",\"value\":\"https://t.me/\",\"type\":2},{\"id\":16,\"nameEn\":\"qq\",\"nameZh\":\"QQ\",\"value\":\"http://sighttp.qq.com/authd?IDKEY=\",\"type\":2},{\"id\":17,\"nameEn\":\"bilibili\",\"nameZh\":\"bilibili\",\"value\":\"https://space.bilibili.com/\",\"type\":2},{\"id\":18,\"nameEn\":\"netease\",\"nameZh\":\"网易云音乐\",\"value\":\"https://music.163.com/#/user/home?id=\",\"type\":2},{\"id\":19,\"nameEn\":\"email\",\"nameZh\":\"email\",\"value\":\"mailto:youta@163.com\",\"type\":2}],\"deleteIds\":[20,21,22,30,29,27,26,25,24,23,28]}}', '更新站点配置信息', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 113, '2024-12-20 14:53:23', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (62, 'admin', '/admin/siteSettings', 'POST', '{\"map\":{\"settings\":[{\"id\":1,\"nameEn\":\"blogName\",\"nameZh\":\"博客名称\",\"value\":\"Youta\'s Blog\",\"type\":1},{\"id\":2,\"nameEn\":\"webTitleSuffix\",\"nameZh\":\"网页标题后缀\",\"value\":\" - Youta\'s Blog\",\"type\":1},{\"id\":3,\"nameEn\":\"footerImgTitle\",\"nameZh\":\"页脚图片标题\",\"value\":\"手机看本站\",\"type\":1},{\"id\":4,\"nameEn\":\"footerImgUrl\",\"nameZh\":\"页脚图片路径\",\"value\":\"/img/qr.png\",\"type\":1},{\"id\":5,\"nameEn\":\"copyright\",\"nameZh\":\"Copyright\",\"value\":\"{\\\"title\\\":\\\"Copyright © 2024 - 2025\\\",\\\"siteName\\\":\\\"YOUTA\'S BLOG\\\"}\",\"type\":1},{\"id\":6,\"nameEn\":\"beian\",\"nameZh\":\"ICP备案号\",\"value\":\"\",\"type\":1},{\"id\":7,\"nameEn\":\"reward\",\"nameZh\":\"赞赏码\",\"value\":\"/img/reward.jpg\",\"type\":1},{\"id\":8,\"nameEn\":\"commentAdminFlag\",\"nameZh\":\"博主评论标识\",\"value\":\"咕咕\",\"type\":1},{\"id\":9,\"nameEn\":\"playlistServer\",\"nameZh\":\"播放器平台\",\"value\":\"netease\",\"type\":1},{\"id\":10,\"nameEn\":\"playlistId\",\"nameZh\":\"播放器歌单\",\"value\":\"3071528549\",\"type\":1},{\"id\":11,\"nameEn\":\"avatar\",\"nameZh\":\"头像\",\"value\":\"/img/avatar.jpg\",\"type\":2},{\"id\":12,\"nameEn\":\"name\",\"nameZh\":\"昵称\",\"value\":\"Youta\",\"type\":2},{\"id\":13,\"nameEn\":\"rollText\",\"nameZh\":\"滚动个签\",\"value\":\"\\\"云鹤当归天，天不迎我妙木仙；\\\",\\\"游龙当归海，海不迎我自来也。\\\"\",\"type\":2},{\"id\":14,\"nameEn\":\"github\",\"nameZh\":\"GitHub\",\"value\":\"\",\"type\":2},{\"id\":15,\"nameEn\":\"telegram\",\"nameZh\":\"Telegram\",\"value\":\"\",\"type\":2},{\"id\":16,\"nameEn\":\"qq\",\"nameZh\":\"QQ\",\"value\":\"\",\"type\":2},{\"id\":17,\"nameEn\":\"bilibili\",\"nameZh\":\"bilibili\",\"value\":\"\",\"type\":2},{\"id\":18,\"nameEn\":\"netease\",\"nameZh\":\"网易云音乐\",\"value\":\"https://music.163.com/#/user/home?id=\",\"type\":2},{\"id\":19,\"nameEn\":\"email\",\"nameZh\":\"email\",\"value\":\"mailto:youta@163.com\",\"type\":2}],\"deleteIds\":[]}}', '更新站点配置信息', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 36, '2024-12-20 14:53:58', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (63, 'admin', '/admin/siteSettings', 'POST', '{\"map\":{\"settings\":[{\"id\":1,\"nameEn\":\"blogName\",\"nameZh\":\"博客名称\",\"value\":\"Youta\'s Blog\",\"type\":1},{\"id\":2,\"nameEn\":\"webTitleSuffix\",\"nameZh\":\"网页标题后缀\",\"value\":\" - Youta\'s Blog\",\"type\":1},{\"id\":3,\"nameEn\":\"footerImgTitle\",\"nameZh\":\"页脚图片标题\",\"value\":\"手机看本站\",\"type\":1},{\"id\":4,\"nameEn\":\"footerImgUrl\",\"nameZh\":\"页脚图片路径\",\"value\":\"/img/qr.png\",\"type\":1},{\"id\":5,\"nameEn\":\"copyright\",\"nameZh\":\"Copyright\",\"value\":\"{\\\"title\\\":\\\"Copyright © 2024 - 2025\\\",\\\"siteName\\\":\\\"YOUTA\'S BLOG\\\"}\",\"type\":1},{\"id\":6,\"nameEn\":\"beian\",\"nameZh\":\"ICP备案号\",\"value\":\"\",\"type\":1},{\"id\":7,\"nameEn\":\"reward\",\"nameZh\":\"赞赏码\",\"value\":\"/img/reward.jpg\",\"type\":1},{\"id\":8,\"nameEn\":\"commentAdminFlag\",\"nameZh\":\"博主评论标识\",\"value\":\"咕咕\",\"type\":1},{\"id\":9,\"nameEn\":\"playlistServer\",\"nameZh\":\"播放器平台\",\"value\":\"netease\",\"type\":1},{\"id\":10,\"nameEn\":\"playlistId\",\"nameZh\":\"播放器歌单\",\"value\":\"3071528549\",\"type\":1},{\"id\":11,\"nameEn\":\"avatar\",\"nameZh\":\"头像\",\"value\":\"/img/avatar.jpg\",\"type\":2},{\"id\":12,\"nameEn\":\"name\",\"nameZh\":\"昵称\",\"value\":\"Youta\",\"type\":2},{\"id\":13,\"nameEn\":\"rollText\",\"nameZh\":\"滚动个签\",\"value\":\"\\\"积跬步以至千里，致敬每一个爱学习的你\\\"\",\"type\":2},{\"id\":14,\"nameEn\":\"github\",\"nameZh\":\"GitHub\",\"value\":\"\",\"type\":2},{\"id\":15,\"nameEn\":\"telegram\",\"nameZh\":\"Telegram\",\"value\":\"\",\"type\":2},{\"id\":16,\"nameEn\":\"qq\",\"nameZh\":\"QQ\",\"value\":\"\",\"type\":2},{\"id\":17,\"nameEn\":\"bilibili\",\"nameZh\":\"bilibili\",\"value\":\"\",\"type\":2},{\"id\":18,\"nameEn\":\"netease\",\"nameZh\":\"网易云音乐\",\"value\":\"https://music.163.com/#/user/home?id=\",\"type\":2},{\"id\":19,\"nameEn\":\"email\",\"nameZh\":\"email\",\"value\":\"mailto:youta@163.com\",\"type\":2}],\"deleteIds\":[]}}', '更新站点配置信息', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 32, '2024-12-20 14:55:40', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (64, 'admin', '/admin/siteSettings', 'POST', '{\"map\":{\"settings\":[{\"id\":1,\"nameEn\":\"blogName\",\"nameZh\":\"博客名称\",\"value\":\"Youta\'s Blog\",\"type\":1},{\"id\":2,\"nameEn\":\"webTitleSuffix\",\"nameZh\":\"网页标题后缀\",\"value\":\" - Youta\'s Blog\",\"type\":1},{\"id\":3,\"nameEn\":\"footerImgTitle\",\"nameZh\":\"页脚图片标题\",\"value\":\"手机看本站\",\"type\":1},{\"id\":4,\"nameEn\":\"footerImgUrl\",\"nameZh\":\"页脚图片路径\",\"value\":\"/img/qr.png\",\"type\":1},{\"id\":5,\"nameEn\":\"copyright\",\"nameZh\":\"Copyright\",\"value\":\"{\\\"title\\\":\\\"Copyright © 2024 - 2025\\\",\\\"siteName\\\":\\\"YOUTA\'S BLOG\\\"}\",\"type\":1},{\"id\":6,\"nameEn\":\"beian\",\"nameZh\":\"ICP备案号\",\"value\":\"\",\"type\":1},{\"id\":7,\"nameEn\":\"reward\",\"nameZh\":\"赞赏码\",\"value\":\"/img/reward.jpg\",\"type\":1},{\"id\":8,\"nameEn\":\"commentAdminFlag\",\"nameZh\":\"博主评论标识\",\"value\":\"咕咕\",\"type\":1},{\"id\":9,\"nameEn\":\"playlistServer\",\"nameZh\":\"播放器平台\",\"value\":\"netease\",\"type\":1},{\"id\":10,\"nameEn\":\"playlistId\",\"nameZh\":\"播放器歌单\",\"value\":\"3071528549\",\"type\":1},{\"id\":11,\"nameEn\":\"avatar\",\"nameZh\":\"头像\",\"value\":\"/img/avatar.jpg\",\"type\":2},{\"id\":12,\"nameEn\":\"name\",\"nameZh\":\"昵称\",\"value\":\"Youta\",\"type\":2},{\"id\":13,\"nameEn\":\"rollText\",\"nameZh\":\"滚动个签\",\"value\":\"\\\"积跬步以至千里\\\"，\\\"致敬每一个爱学习的你\\\"\",\"type\":2},{\"id\":14,\"nameEn\":\"github\",\"nameZh\":\"GitHub\",\"value\":\"\",\"type\":2},{\"id\":15,\"nameEn\":\"telegram\",\"nameZh\":\"Telegram\",\"value\":\"\",\"type\":2},{\"id\":16,\"nameEn\":\"qq\",\"nameZh\":\"QQ\",\"value\":\"\",\"type\":2},{\"id\":17,\"nameEn\":\"bilibili\",\"nameZh\":\"bilibili\",\"value\":\"\",\"type\":2},{\"id\":18,\"nameEn\":\"netease\",\"nameZh\":\"网易云音乐\",\"value\":\"https://music.163.com/#/user/home?id=\",\"type\":2},{\"id\":19,\"nameEn\":\"email\",\"nameZh\":\"email\",\"value\":\"mailto:youta@163.com\",\"type\":2}],\"deleteIds\":[]}}', '更新站点配置信息', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 24, '2024-12-20 14:56:14', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (65, 'admin', '/admin/siteSettings', 'POST', '{\"map\":{\"settings\":[{\"id\":1,\"nameEn\":\"blogName\",\"nameZh\":\"博客名称\",\"value\":\"Youta\'s Blog\",\"type\":1},{\"id\":2,\"nameEn\":\"webTitleSuffix\",\"nameZh\":\"网页标题后缀\",\"value\":\" - Youta\'s Blog\",\"type\":1},{\"id\":3,\"nameEn\":\"footerImgTitle\",\"nameZh\":\"页脚图片标题\",\"value\":\"手机看本站\",\"type\":1},{\"id\":4,\"nameEn\":\"footerImgUrl\",\"nameZh\":\"页脚图片路径\",\"value\":\"/img/qr.png\",\"type\":1},{\"id\":5,\"nameEn\":\"copyright\",\"nameZh\":\"Copyright\",\"value\":\"{\\\"title\\\":\\\"Copyright © 2024 - 2025\\\",\\\"siteName\\\":\\\"YOUTA\'S BLOG\\\"}\",\"type\":1},{\"id\":6,\"nameEn\":\"beian\",\"nameZh\":\"ICP备案号\",\"value\":\"\",\"type\":1},{\"id\":7,\"nameEn\":\"reward\",\"nameZh\":\"赞赏码\",\"value\":\"/img/reward.jpg\",\"type\":1},{\"id\":8,\"nameEn\":\"commentAdminFlag\",\"nameZh\":\"博主评论标识\",\"value\":\"咕咕\",\"type\":1},{\"id\":9,\"nameEn\":\"playlistServer\",\"nameZh\":\"播放器平台\",\"value\":\"netease\",\"type\":1},{\"id\":10,\"nameEn\":\"playlistId\",\"nameZh\":\"播放器歌单\",\"value\":\"3071528549\",\"type\":1},{\"id\":11,\"nameEn\":\"avatar\",\"nameZh\":\"头像\",\"value\":\"/img/avatar.jpg\",\"type\":2},{\"id\":12,\"nameEn\":\"name\",\"nameZh\":\"昵称\",\"value\":\"Youta\",\"type\":2},{\"id\":13,\"nameEn\":\"rollText\",\"nameZh\":\"滚动个签\",\"value\":\"\\\"积跬步以至千里\\\"，\\\"致敬每一个爱学习的你\\\"\",\"type\":2},{\"id\":14,\"nameEn\":\"github\",\"nameZh\":\"GitHub\",\"value\":\"\",\"type\":2},{\"id\":15,\"nameEn\":\"telegram\",\"nameZh\":\"Telegram\",\"value\":\"\",\"type\":2},{\"id\":16,\"nameEn\":\"qq\",\"nameZh\":\"QQ\",\"value\":\"\",\"type\":2},{\"id\":17,\"nameEn\":\"bilibili\",\"nameZh\":\"bilibili\",\"value\":\"\",\"type\":2},{\"id\":18,\"nameEn\":\"netease\",\"nameZh\":\"网易云音乐\",\"value\":\"\",\"type\":2},{\"id\":19,\"nameEn\":\"email\",\"nameZh\":\"email\",\"value\":\"\",\"type\":2}],\"deleteIds\":[]}}', '更新站点配置信息', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 25, '2024-12-20 14:59:32', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (66, 'admin', '/admin/siteSettings', 'POST', '{\"map\":{\"settings\":[{\"id\":1,\"nameEn\":\"blogName\",\"nameZh\":\"博客名称\",\"value\":\"Youta\'s Blog\",\"type\":1},{\"id\":2,\"nameEn\":\"webTitleSuffix\",\"nameZh\":\"网页标题后缀\",\"value\":\" - Youta\'s Blog\",\"type\":1},{\"id\":3,\"nameEn\":\"footerImgTitle\",\"nameZh\":\"页脚图片标题\",\"value\":\"欢迎来到本站\",\"type\":1},{\"id\":4,\"nameEn\":\"footerImgUrl\",\"nameZh\":\"页脚图片路径\",\"value\":\"/img/qr.png\",\"type\":1},{\"id\":5,\"nameEn\":\"copyright\",\"nameZh\":\"Copyright\",\"value\":\"{\\\"title\\\":\\\"Copyright © 2024 - 2025\\\",\\\"siteName\\\":\\\"YOUTA\'S BLOG\\\"}\",\"type\":1},{\"id\":6,\"nameEn\":\"beian\",\"nameZh\":\"ICP备案号\",\"value\":\"\",\"type\":1},{\"id\":7,\"nameEn\":\"reward\",\"nameZh\":\"赞赏码\",\"value\":\"/img/reward.jpg\",\"type\":1},{\"id\":8,\"nameEn\":\"commentAdminFlag\",\"nameZh\":\"博主评论标识\",\"value\":\"咕咕\",\"type\":1},{\"id\":9,\"nameEn\":\"playlistServer\",\"nameZh\":\"播放器平台\",\"value\":\"netease\",\"type\":1},{\"id\":10,\"nameEn\":\"playlistId\",\"nameZh\":\"播放器歌单\",\"value\":\"3071528549\",\"type\":1},{\"id\":11,\"nameEn\":\"avatar\",\"nameZh\":\"头像\",\"value\":\"/img/avatar.jpg\",\"type\":2},{\"id\":12,\"nameEn\":\"name\",\"nameZh\":\"昵称\",\"value\":\"Youta\",\"type\":2},{\"id\":13,\"nameEn\":\"rollText\",\"nameZh\":\"滚动个签\",\"value\":\"\\\"积跬步以至千里\\\"，\\\"致敬每一个爱学习的你\\\"\",\"type\":2},{\"id\":14,\"nameEn\":\"github\",\"nameZh\":\"GitHub\",\"value\":\"\",\"type\":2},{\"id\":15,\"nameEn\":\"telegram\",\"nameZh\":\"Telegram\",\"value\":\"\",\"type\":2},{\"id\":16,\"nameEn\":\"qq\",\"nameZh\":\"QQ\",\"value\":\"\",\"type\":2},{\"id\":17,\"nameEn\":\"bilibili\",\"nameZh\":\"bilibili\",\"value\":\"\",\"type\":2},{\"id\":18,\"nameEn\":\"netease\",\"nameZh\":\"网易云音乐\",\"value\":\"\",\"type\":2},{\"id\":19,\"nameEn\":\"email\",\"nameZh\":\"email\",\"value\":\"\",\"type\":2}],\"deleteIds\":[]}}', '更新站点配置信息', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 21, '2024-12-20 15:06:24', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (67, 'admin', '/admin/siteSettings', 'POST', '{\"map\":{\"settings\":[{\"id\":1,\"nameEn\":\"blogName\",\"nameZh\":\"博客名称\",\"value\":\"Youta\'s Blog\",\"type\":1},{\"id\":2,\"nameEn\":\"webTitleSuffix\",\"nameZh\":\"网页标题后缀\",\"value\":\" - Youta\'s Blog\",\"type\":1},{\"id\":3,\"nameEn\":\"footerImgTitle\",\"nameZh\":\"页脚图片标题\",\"value\":\"欢迎来到本站\",\"type\":1},{\"id\":4,\"nameEn\":\"footerImgUrl\",\"nameZh\":\"页脚图片路径\",\"value\":\"/img/logo.png\",\"type\":1},{\"id\":5,\"nameEn\":\"copyright\",\"nameZh\":\"Copyright\",\"value\":\"{\\\"title\\\":\\\"Copyright © 2024 - 2025\\\",\\\"siteName\\\":\\\"YOUTA\'S BLOG\\\"}\",\"type\":1},{\"id\":6,\"nameEn\":\"beian\",\"nameZh\":\"ICP备案号\",\"value\":\"\",\"type\":1},{\"id\":7,\"nameEn\":\"reward\",\"nameZh\":\"赞赏码\",\"value\":\"/img/reward.jpg\",\"type\":1},{\"id\":8,\"nameEn\":\"commentAdminFlag\",\"nameZh\":\"博主评论标识\",\"value\":\"咕咕\",\"type\":1},{\"id\":9,\"nameEn\":\"playlistServer\",\"nameZh\":\"播放器平台\",\"value\":\"netease\",\"type\":1},{\"id\":10,\"nameEn\":\"playlistId\",\"nameZh\":\"播放器歌单\",\"value\":\"3071528549\",\"type\":1},{\"id\":11,\"nameEn\":\"avatar\",\"nameZh\":\"头像\",\"value\":\"/img/avatar.jpg\",\"type\":2},{\"id\":12,\"nameEn\":\"name\",\"nameZh\":\"昵称\",\"value\":\"Youta\",\"type\":2},{\"id\":13,\"nameEn\":\"rollText\",\"nameZh\":\"滚动个签\",\"value\":\"\\\"积跬步以至千里\\\"，\\\"致敬每一个爱学习的你\\\"\",\"type\":2},{\"id\":14,\"nameEn\":\"github\",\"nameZh\":\"GitHub\",\"value\":\"\",\"type\":2},{\"id\":15,\"nameEn\":\"telegram\",\"nameZh\":\"Telegram\",\"value\":\"\",\"type\":2},{\"id\":16,\"nameEn\":\"qq\",\"nameZh\":\"QQ\",\"value\":\"\",\"type\":2},{\"id\":17,\"nameEn\":\"bilibili\",\"nameZh\":\"bilibili\",\"value\":\"\",\"type\":2},{\"id\":18,\"nameEn\":\"netease\",\"nameZh\":\"网易云音乐\",\"value\":\"\",\"type\":2},{\"id\":19,\"nameEn\":\"email\",\"nameZh\":\"email\",\"value\":\"\",\"type\":2}],\"deleteIds\":[]}}', '更新站点配置信息', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 25, '2024-12-20 15:09:49', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (68, 'admin', '/admin/siteSettings', 'POST', '{\"map\":{\"settings\":[{\"id\":1,\"nameEn\":\"blogName\",\"nameZh\":\"博客名称\",\"value\":\"Youta\'s Blog\",\"type\":1},{\"id\":2,\"nameEn\":\"webTitleSuffix\",\"nameZh\":\"网页标题后缀\",\"value\":\" - Youta\'s Blog\",\"type\":1},{\"id\":3,\"nameEn\":\"footerImgTitle\",\"nameZh\":\"页脚图片标题\",\"value\":\"欢迎来到本站\",\"type\":1},{\"id\":4,\"nameEn\":\"footerImgUrl\",\"nameZh\":\"页脚图片路径\",\"value\":\"/img/logo.png\",\"type\":1},{\"id\":5,\"nameEn\":\"copyright\",\"nameZh\":\"Copyright\",\"value\":\"{\\\"title\\\":\\\"Copyright © 2024 - 2025\\\",\\\"siteName\\\":\\\"YOUTA\'S BLOG\\\"}\",\"type\":1},{\"id\":6,\"nameEn\":\"beian\",\"nameZh\":\"ICP备案号\",\"value\":\"\",\"type\":1},{\"id\":7,\"nameEn\":\"reward\",\"nameZh\":\"赞赏码\",\"value\":\"/img/reward.png\",\"type\":1},{\"id\":8,\"nameEn\":\"commentAdminFlag\",\"nameZh\":\"博主评论标识\",\"value\":\"咕咕\",\"type\":1},{\"id\":9,\"nameEn\":\"playlistServer\",\"nameZh\":\"播放器平台\",\"value\":\"netease\",\"type\":1},{\"id\":10,\"nameEn\":\"playlistId\",\"nameZh\":\"播放器歌单\",\"value\":\"3071528549\",\"type\":1},{\"id\":11,\"nameEn\":\"avatar\",\"nameZh\":\"头像\",\"value\":\"/img/avatar.jpg\",\"type\":2},{\"id\":12,\"nameEn\":\"name\",\"nameZh\":\"昵称\",\"value\":\"Youta\",\"type\":2},{\"id\":13,\"nameEn\":\"rollText\",\"nameZh\":\"滚动个签\",\"value\":\"\\\"积跬步以至千里\\\"，\\\"致敬每一个爱学习的你\\\"\",\"type\":2},{\"id\":14,\"nameEn\":\"github\",\"nameZh\":\"GitHub\",\"value\":\"\",\"type\":2},{\"id\":15,\"nameEn\":\"telegram\",\"nameZh\":\"Telegram\",\"value\":\"\",\"type\":2},{\"id\":16,\"nameEn\":\"qq\",\"nameZh\":\"QQ\",\"value\":\"\",\"type\":2},{\"id\":17,\"nameEn\":\"bilibili\",\"nameZh\":\"bilibili\",\"value\":\"\",\"type\":2},{\"id\":18,\"nameEn\":\"netease\",\"nameZh\":\"网易云音乐\",\"value\":\"\",\"type\":2},{\"id\":19,\"nameEn\":\"email\",\"nameZh\":\"email\",\"value\":\"\",\"type\":2}],\"deleteIds\":[]}}', '更新站点配置信息', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 16, '2024-12-20 15:12:58', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (69, 'admin', '/admin/friendInfo/content', 'PUT', '{\"map\":{\"content\":\"\\n\"}}', '修改友链页面信息', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-20 15:16:08', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (70, 'admin', '/admin/siteSettings', 'POST', '{\"map\":{\"settings\":[{\"id\":1,\"nameEn\":\"blogName\",\"nameZh\":\"博客名称\",\"value\":\"Youta\'s Blog\",\"type\":1},{\"id\":2,\"nameEn\":\"webTitleSuffix\",\"nameZh\":\"网页标题后缀\",\"value\":\" - Youta\'s Blog\",\"type\":1},{\"id\":3,\"nameEn\":\"footerImgTitle\",\"nameZh\":\"页脚图片标题\",\"value\":\"欢迎来到本站\",\"type\":1},{\"id\":4,\"nameEn\":\"footerImgUrl\",\"nameZh\":\"页脚图片路径\",\"value\":\"/img/logo.png\",\"type\":1},{\"id\":5,\"nameEn\":\"copyright\",\"nameZh\":\"Copyright\",\"value\":\"{\\\"title\\\":\\\"Copyright © 2024 - 2025\\\",\\\"siteName\\\":\\\"YOUTA\'S BLOG\\\"}\",\"type\":1},{\"id\":6,\"nameEn\":\"beian\",\"nameZh\":\"ICP备案号\",\"value\":\"\",\"type\":1},{\"id\":7,\"nameEn\":\"reward\",\"nameZh\":\"赞赏码\",\"value\":\"/img/reward.png\",\"type\":1},{\"id\":8,\"nameEn\":\"commentAdminFlag\",\"nameZh\":\"博主评论标识\",\"value\":\"咕咕\",\"type\":1},{\"id\":9,\"nameEn\":\"playlistServer\",\"nameZh\":\"播放器平台\",\"value\":\"netease\",\"type\":1},{\"id\":10,\"nameEn\":\"playlistId\",\"nameZh\":\"播放器歌单\",\"value\":\"3071528549\",\"type\":1},{\"id\":11,\"nameEn\":\"avatar\",\"nameZh\":\"头像\",\"value\":\"/img/avatar.jpg\",\"type\":2},{\"id\":12,\"nameEn\":\"name\",\"nameZh\":\"昵称\",\"value\":\"Youta\",\"type\":2},{\"id\":13,\"nameEn\":\"rollText\",\"nameZh\":\"滚动个签\",\"value\":\"\\\"积跬步以至千里\\\"，\\\"致敬每一个爱学习的你\\\"\",\"type\":2},{\"id\":14,\"nameEn\":\"github\",\"nameZh\":\"GitHub\",\"value\":\"\",\"type\":2},{\"id\":15,\"nameEn\":\"telegram\",\"nameZh\":\"Telegram\",\"value\":\"\",\"type\":2},{\"id\":16,\"nameEn\":\"qq\",\"nameZh\":\"QQ\",\"value\":\"\",\"type\":2},{\"id\":17,\"nameEn\":\"bilibili\",\"nameZh\":\"bilibili\",\"value\":\"\",\"type\":2},{\"id\":18,\"nameEn\":\"netease\",\"nameZh\":\"网易云音乐\",\"value\":\"\",\"type\":2},{\"id\":19,\"nameEn\":\"email\",\"nameZh\":\"email\",\"value\":\"\",\"type\":2}],\"deleteIds\":[]}}', '更新站点配置信息', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 11, '2024-12-20 15:16:30', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (71, 'admin', '/admin/blog', 'POST', '{\"blog\":{\"id\":5,\"title\":\"JVM 垃圾收集器\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/713d65b0-96a9-11ea-949b-db7ff35aaabb.png\",\"content\":\"**1.简述 Java 垃圾回收机制**\\n\\n在 java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在 JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。\\n\\n**2. GC 是什么？为什么要 GC**\\n\\nGC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存 回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动 回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。\\n\\n**3. 垃圾回收的优点和原理。并考虑 2 种回收机制**\\n\\nJava 语言最显著的特点就是引入了垃圾回收机制，它使 java 程序员在编写程序时不再考虑内存管理的问题。 由于有这个垃圾回收机制，java 中的对象不再有“作用域”的概念，只有引用的对象才有“作用域”。 垃圾回收机制有效的防止了内存泄露，可以有效的使用可使用的内存。 垃圾回收器通常作为一个单独的低级别的线程运行，在不可预知的情况下对内存堆中已经死亡的或很长时间没有用过的对象进行清除和回收。 程序员不能实时的对某个对象或所有对象调用垃圾回收器进行垃圾回收。 垃圾回收有分代复制垃圾回收、标记垃圾回收、增量垃圾回收。\\n\\n**4. 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？**\\n\\n对于 GC 来说，当程序员创建对象时，GC 就开始监控这个对象的地址、大小以及使用情况。 通常，GC 采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当 GC 确定一些对象为”不可达”时，GC 就有责任回收这些内存空间。 可以。程序员可以手动执行 System.gc()，通知 GC 运行，但是 Java 语言规范并不保证 GC 一定会执行。\\n\\n**5. Java 中都有哪些引用类型？**\\n\\n强引用：发生 gc 的时候不会被回收。 软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。 弱引用：有用但不是必须的对象，在下一次 GC 时会被回收。 虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。\\n\\n**6. 怎么判断对象是否可以被回收？**\\n\\n垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收的，哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收。\\n\\n一般有两种方法来判断： 引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题； 可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。\\n\\n**7. 在 Java 中，对象什么时候可以被垃圾回收?**\\n\\n当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。 垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免 Full GC 是非常重要的原因。\\n\\n**8. JVM 中的永久代中会发生垃圾回收吗?**\\n\\n垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免 Full GC 是非常重要的原因。请参考下 Java8：从永久代到元数据区 (译者注：Java8 中已经移除了永久代，新加了一个叫做元数据区的 native 内存区)\\n\\n**9. 说一下 JVM 有哪些垃圾回收算法？**\\n\\n标记-清除算法：标记无用对象，然后', '发布博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 28, '2024-12-20 15:20:45', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (72, 'admin', '/admin/blog', 'PUT', '{\"blog\":{\"id\":5,\"title\":\"JVM 垃圾收集器\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/713d65b0-96a9-11ea-949b-db7ff35aaabb.png\",\"content\":\"**1.简述 Java 垃圾回收机制**\\n\\n在 java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在 JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。\\n\\n**2. GC 是什么？为什么要 GC**\\n\\nGC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存 回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动 回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。\\n\\n**3. 垃圾回收的优点和原理。并考虑 2 种回收机制**\\n\\nJava 语言最显著的特点就是引入了垃圾回收机制，它使 java 程序员在编写程序时不再考虑内存管理的问题。 由于有这个垃圾回收机制，java 中的对象不再有“作用域”的概念，只有引用的对象才有“作用域”。 垃圾回收机制有效的防止了内存泄露，可以有效的使用可使用的内存。 垃圾回收器通常作为一个单独的低级别的线程运行，在不可预知的情况下对内存堆中已经死亡的或很长时间没有用过的对象进行清除和回收。 程序员不能实时的对某个对象或所有对象调用垃圾回收器进行垃圾回收。 垃圾回收有分代复制垃圾回收、标记垃圾回收、增量垃圾回收。\\n\\n**4. 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？**\\n\\n对于 GC 来说，当程序员创建对象时，GC 就开始监控这个对象的地址、大小以及使用情况。 通常，GC 采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当 GC 确定一些对象为”不可达”时，GC 就有责任回收这些内存空间。 可以。程序员可以手动执行 System.gc()，通知 GC 运行，但是 Java 语言规范并不保证 GC 一定会执行。\\n\\n**5. Java 中都有哪些引用类型？**\\n\\n强引用：发生 gc 的时候不会被回收。 软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。 弱引用：有用但不是必须的对象，在下一次 GC 时会被回收。 虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。\\n\\n**6. 怎么判断对象是否可以被回收？**\\n\\n垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收的，哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收。\\n\\n一般有两种方法来判断： 引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题； 可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。\\n\\n**7. 在 Java 中，对象什么时候可以被垃圾回收?**\\n\\n当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。 垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免 Full GC 是非常重要的原因。\\n\\n**8. JVM 中的永久代中会发生垃圾回收吗?**\\n\\n垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免 Full GC 是非常重要的原因。请参考下 Java8：从永久代到元数据区 (译者注：Java8 中已经移除了永久代，新加了一个叫做元数据区的 native 内存区)\\n\\n**9. 说一下 JVM 有哪些垃圾回收算法？**\\n\\n标记-清除算法：标记无用对象，然后', '更新博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 29, '2024-12-20 16:03:33', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (73, 'admin', '/admin/blog', 'PUT', '{\"blog\":{\"id\":5,\"title\":\"JVM 垃圾收集器\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/713d65b0-96a9-11ea-949b-db7ff35aaabb.png\",\"content\":\"**1.简述 Java 垃圾回收机制**\\n\\n在 java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在 JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。\\n\\n**2. GC 是什么？为什么要 GC**\\n\\nGC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存 回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动 回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。\\n\\n**3. 垃圾回收的优点和原理。并考虑 2 种回收机制**\\n\\nJava 语言最显著的特点就是引入了垃圾回收机制，它使 java 程序员在编写程序时不再考虑内存管理的问题。 由于有这个垃圾回收机制，java 中的对象不再有“作用域”的概念，只有引用的对象才有“作用域”。 垃圾回收机制有效的防止了内存泄露，可以有效的使用可使用的内存。 垃圾回收器通常作为一个单独的低级别的线程运行，在不可预知的情况下对内存堆中已经死亡的或很长时间没有用过的对象进行清除和回收。 程序员不能实时的对某个对象或所有对象调用垃圾回收器进行垃圾回收。 垃圾回收有分代复制垃圾回收、标记垃圾回收、增量垃圾回收。\\n\\n**4. 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？**\\n\\n对于 GC 来说，当程序员创建对象时，GC 就开始监控这个对象的地址、大小以及使用情况。 通常，GC 采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当 GC 确定一些对象为”不可达”时，GC 就有责任回收这些内存空间。 可以。程序员可以手动执行 System.gc()，通知 GC 运行，但是 Java 语言规范并不保证 GC 一定会执行。\\n\\n**5. Java 中都有哪些引用类型？**\\n\\n强引用：发生 gc 的时候不会被回收。 软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。 弱引用：有用但不是必须的对象，在下一次 GC 时会被回收。 虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。\\n\\n**6. 怎么判断对象是否可以被回收？**\\n\\n垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收的，哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收。\\n\\n一般有两种方法来判断： 引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题； 可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。\\n\\n**7. 在 Java 中，对象什么时候可以被垃圾回收?**\\n\\n当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。 垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免 Full GC 是非常重要的原因。\\n\\n**8. JVM 中的永久代中会发生垃圾回收吗?**\\n\\n垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免 Full GC 是非常重要的原因。请参考下 Java8：从永久代到元数据区 (译者注：Java8 中已经移除了永久代，新加了一个叫做元数据区的 native 内存区)\\n\\n**9. 说一下 JVM 有哪些垃圾回收算法？**\\n\\n标记-清除算法：标记无用对象，然后', '更新博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 14, '2024-12-20 16:05:25', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (74, 'admin', '/admin/siteSettings', 'POST', '{\"map\":{\"settings\":[{\"id\":1,\"nameEn\":\"blogName\",\"nameZh\":\"博客名称\",\"value\":\"Youta\'s Blog\",\"type\":1},{\"id\":2,\"nameEn\":\"webTitleSuffix\",\"nameZh\":\"网页标题后缀\",\"value\":\" - Youta\'s Blog\",\"type\":1},{\"id\":3,\"nameEn\":\"footerImgTitle\",\"nameZh\":\"页脚图片标题\",\"value\":\"欢迎来到本站\",\"type\":1},{\"id\":4,\"nameEn\":\"footerImgUrl\",\"nameZh\":\"页脚图片路径\",\"value\":\"/img/panda-waving.png\",\"type\":1},{\"id\":5,\"nameEn\":\"copyright\",\"nameZh\":\"Copyright\",\"value\":\"{\\\"title\\\":\\\"Copyright © 2024 - 2025\\\",\\\"siteName\\\":\\\"YOUTA\'S BLOG\\\"}\",\"type\":1},{\"id\":6,\"nameEn\":\"beian\",\"nameZh\":\"ICP备案号\",\"value\":\"\",\"type\":1},{\"id\":7,\"nameEn\":\"reward\",\"nameZh\":\"赞赏码\",\"value\":\"/img/reward.png\",\"type\":1},{\"id\":8,\"nameEn\":\"commentAdminFlag\",\"nameZh\":\"博主评论标识\",\"value\":\"咕咕\",\"type\":1},{\"id\":9,\"nameEn\":\"playlistServer\",\"nameZh\":\"播放器平台\",\"value\":\"netease\",\"type\":1},{\"id\":10,\"nameEn\":\"playlistId\",\"nameZh\":\"播放器歌单\",\"value\":\"3071528549\",\"type\":1},{\"id\":11,\"nameEn\":\"avatar\",\"nameZh\":\"头像\",\"value\":\"/img/avatar.jpg\",\"type\":2},{\"id\":12,\"nameEn\":\"name\",\"nameZh\":\"昵称\",\"value\":\"Youta\",\"type\":2},{\"id\":13,\"nameEn\":\"rollText\",\"nameZh\":\"滚动个签\",\"value\":\"\\\"积跬步以至千里\\\"，\\\"致敬每一个爱学习的你\\\"\",\"type\":2},{\"id\":14,\"nameEn\":\"github\",\"nameZh\":\"GitHub\",\"value\":\"\",\"type\":2},{\"id\":15,\"nameEn\":\"telegram\",\"nameZh\":\"Telegram\",\"value\":\"\",\"type\":2},{\"id\":16,\"nameEn\":\"qq\",\"nameZh\":\"QQ\",\"value\":\"\",\"type\":2},{\"id\":17,\"nameEn\":\"bilibili\",\"nameZh\":\"bilibili\",\"value\":\"\",\"type\":2},{\"id\":18,\"nameEn\":\"netease\",\"nameZh\":\"网易云音乐\",\"value\":\"\",\"type\":2},{\"id\":19,\"nameEn\":\"email\",\"nameZh\":\"email\",\"value\":\"\",\"type\":2}],\"deleteIds\":[]}}', '更新站点配置信息', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 13, '2024-12-20 16:22:27', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (75, 'admin', '/admin/siteSettings', 'POST', '{\"map\":{\"settings\":[{\"id\":1,\"nameEn\":\"blogName\",\"nameZh\":\"博客名称\",\"value\":\"Youta\'s Blog\",\"type\":1},{\"id\":2,\"nameEn\":\"webTitleSuffix\",\"nameZh\":\"网页标题后缀\",\"value\":\" - Youta\'s Blog\",\"type\":1},{\"id\":3,\"nameEn\":\"footerImgTitle\",\"nameZh\":\"页脚图片标题\",\"value\":\"欢迎来到本站\",\"type\":1},{\"id\":4,\"nameEn\":\"footerImgUrl\",\"nameZh\":\"页脚图片路径\",\"value\":\"/img/panda-waving.png\",\"type\":1},{\"id\":5,\"nameEn\":\"copyright\",\"nameZh\":\"Copyright\",\"value\":\"{\\\"title\\\":\\\"Copyright © 2024 - 2025\\\",\\\"siteName\\\":\\\"YOUTA\'S BLOG\\\"}\",\"type\":1},{\"id\":6,\"nameEn\":\"beian\",\"nameZh\":\"ICP备案号\",\"value\":\"\",\"type\":1},{\"id\":7,\"nameEn\":\"reward\",\"nameZh\":\"赞赏码\",\"value\":\"/img/reward.png\",\"type\":1},{\"id\":8,\"nameEn\":\"commentAdminFlag\",\"nameZh\":\"博主评论标识\",\"value\":\"咕咕\",\"type\":1},{\"id\":9,\"nameEn\":\"playlistServer\",\"nameZh\":\"播放器平台\",\"value\":\"netease\",\"type\":1},{\"id\":10,\"nameEn\":\"playlistId\",\"nameZh\":\"播放器歌单\",\"value\":\"3071528549\",\"type\":1},{\"id\":11,\"nameEn\":\"avatar\",\"nameZh\":\"头像\",\"value\":\"/img/avatar.png\",\"type\":2},{\"id\":12,\"nameEn\":\"name\",\"nameZh\":\"昵称\",\"value\":\"Youta\",\"type\":2},{\"id\":13,\"nameEn\":\"rollText\",\"nameZh\":\"滚动个签\",\"value\":\"\\\"积跬步以至千里\\\"，\\\"致敬每一个爱学习的你\\\"\",\"type\":2},{\"id\":14,\"nameEn\":\"github\",\"nameZh\":\"GitHub\",\"value\":\"\",\"type\":2},{\"id\":15,\"nameEn\":\"telegram\",\"nameZh\":\"Telegram\",\"value\":\"\",\"type\":2},{\"id\":16,\"nameEn\":\"qq\",\"nameZh\":\"QQ\",\"value\":\"\",\"type\":2},{\"id\":17,\"nameEn\":\"bilibili\",\"nameZh\":\"bilibili\",\"value\":\"\",\"type\":2},{\"id\":18,\"nameEn\":\"netease\",\"nameZh\":\"网易云音乐\",\"value\":\"\",\"type\":2},{\"id\":19,\"nameEn\":\"email\",\"nameZh\":\"email\",\"value\":\"\",\"type\":2}],\"deleteIds\":[]}}', '更新站点配置信息', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 11, '2024-12-20 16:22:47', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (76, 'admin', '/admin/blog', 'POST', '{\"blog\":{\"id\":6,\"title\":\"ElasticSearch 小白从入门到精通\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.png\",\"content\":\"### 什么是 ElasticSearch\\n\\nElasticSearch 简称为 ES，网址为：\\n\\n> https://www.elastic.co/\\n\\nES 是一个分布式的开源搜索和分析引擎，适用于文本、数字、地理空间、结构化数据、非结构化数据等数据的搜索。ES 是在 Apache Lucene 的基础上完成开发。由 Elastic 于 2010 年发布。ES 通过其简单的 REST 风格的 API、分布式特性、速度和可扩容闻名世界。是 Elastic Stack 的核心组件。Elastic Stack 是一套用于数据采集、扩充、保存、分析、可视化的开源工具。Elastic Stack 称之为 ELK。目前 ELK 包含一系列丰富的轻量数据采集代理，这些代理被称之为 Beats。\\n\\n#### ES 的用途\\n\\n主要有以下的用途：\\n\\n- 应用程序搜索\\n- 网站搜索\\n- 企业搜索\\n- 日志处理\\n- 基础设施指标和容器监测\\n- 应用程序性能监测\\n- 地理空间数据分析和可视化\\n- 安全分析\\n- 业务分析\\n\\n#### 工作原理\\n\\n从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，在 Kibana 中，用户可以创建数据可视化面板，并对 ELK 进行管理。\\n\\n#### 索引\\n\\nES 索引是指相互关联的文档集合。ES 是会以 JSON 文档的形式保存数据，每个文档都会在一组键值对中建立联系。\\n\\nES 使用的是一种倒排序索引的数据结构。这个结构可以允许十分快速的进行全文本的搜索。\\n\\n在索引的过程中，ES 会保存文档并构建倒排序索引，这样用户就可以实时的对文档数据进行搜索。索引是在添加过程中就启动的。\\n\\n#### Logstash\\n\\nLogstash 是 ELK 的核心菜品，可以对数据进行聚合和处理。并将数据发送到 ES 中。Logstash 是一个开源的服务器端数据处理管道。\\n\\n#### Kibana\\n\\nKibana 是一款 ES 的数据可视化和管理工具，可以提供直方图，线形图，饼状图，地图。Kibana 还包含 Canvas 和 Elastic Maps 等应用程序。Canvas 可以基于用户创建动态信息。Elastic Maps 可以对空间数据进行可视化处理。\\n\\n#### 为什么要使用 ES\\n\\n- **ES 很快**：ES 是在 Lucene 基础上构建，所以全文本搜索相当的出色。ES 还是一个实时搜索平台。文档索引操作到文档变为可搜索之间速度很快。\\n- **ES 具有分布式的特征**：ES 中保存的文档分布在不同的容器中，这些容器为分片，可以对分片进行复制并形成冗余副本。ES 可以扩充到数百台，并处理 PB 级别的数据。\\n- **ES 包含一系列广泛的功能**：ES 拥有大量的内置功能，方便用户管理数据。\\n- **ES 简化了数据采集，可视化报告的过程**：通过与 Beats 和 Logstash 集成，用户可以在 ES 中索引数据并处理数据，\\n\\n### ES 搭建\\n\\n安装镜像：\\n\\n```\\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n启动容器：\\n\\n```\\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \\\"discovery.type=single-node\\\" docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n修改配置：\\n\\n```\\n#进入 docker 容器内部\\n\\ndocker exec -it es /bin/bash\\n\\n#打开配置文件\\n\\nvim config/elasticsearch.yml\\n\\n### 加入跨域配置\\n\\nhttp.cors.enabled: true\\n\\nhttp.cors.allow-origin: \\\"*\\\"\\n```\\n\\n进入容器，安装分词器：\\n\\n```\\n', '发布博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 57, '2024-12-20 16:55:01', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (77, 'admin', '/admin/blog', 'PUT', '{\"blog\":{\"id\":6,\"title\":\"ElasticSearch 小白从入门到精通\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.png\",\"content\":\"### 什么是 ElasticSearch\\n\\nElasticSearch 简称为 ES，网址为：\\n\\n> https://www.elastic.co/\\n\\nES 是一个分布式的开源搜索和分析引擎，适用于文本、数字、地理空间、结构化数据、非结构化数据等数据的搜索。ES 是在 Apache Lucene 的基础上完成开发。由 Elastic 于 2010 年发布。ES 通过其简单的 REST 风格的 API、分布式特性、速度和可扩容闻名世界。是 Elastic Stack 的核心组件。Elastic Stack 是一套用于数据采集、扩充、保存、分析、可视化的开源工具。Elastic Stack 称之为 ELK。目前 ELK 包含一系列丰富的轻量数据采集代理，这些代理被称之为 Beats。\\n\\n#### ES 的用途\\n\\n主要有以下的用途：\\n\\n- 应用程序搜索\\n- 网站搜索\\n- 企业搜索\\n- 日志处理\\n- 基础设施指标和容器监测\\n- 应用程序性能监测\\n- 地理空间数据分析和可视化\\n- 安全分析\\n- 业务分析\\n\\n#### 工作原理\\n\\n从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，在 Kibana 中，用户可以创建数据可视化面板，并对 ELK 进行管理。\\n\\n#### 索引\\n\\nES 索引是指相互关联的文档集合。ES 是会以 JSON 文档的形式保存数据，每个文档都会在一组键值对中建立联系。\\n\\nES 使用的是一种倒排序索引的数据结构。这个结构可以允许十分快速的进行全文本的搜索。\\n\\n在索引的过程中，ES 会保存文档并构建倒排序索引，这样用户就可以实时的对文档数据进行搜索。索引是在添加过程中就启动的。\\n\\n#### Logstash\\n\\nLogstash 是 ELK 的核心菜品，可以对数据进行聚合和处理。并将数据发送到 ES 中。Logstash 是一个开源的服务器端数据处理管道。\\n\\n#### Kibana\\n\\nKibana 是一款 ES 的数据可视化和管理工具，可以提供直方图，线形图，饼状图，地图。Kibana 还包含 Canvas 和 Elastic Maps 等应用程序。Canvas 可以基于用户创建动态信息。Elastic Maps 可以对空间数据进行可视化处理。\\n\\n#### 为什么要使用 ES\\n\\n- **ES 很快**：ES 是在 Lucene 基础上构建，所以全文本搜索相当的出色。ES 还是一个实时搜索平台。文档索引操作到文档变为可搜索之间速度很快。\\n- **ES 具有分布式的特征**：ES 中保存的文档分布在不同的容器中，这些容器为分片，可以对分片进行复制并形成冗余副本。ES 可以扩充到数百台，并处理 PB 级别的数据。\\n- **ES 包含一系列广泛的功能**：ES 拥有大量的内置功能，方便用户管理数据。\\n- **ES 简化了数据采集，可视化报告的过程**：通过与 Beats 和 Logstash 集成，用户可以在 ES 中索引数据并处理数据，\\n\\n### ES 搭建\\n\\n安装镜像：\\n\\n```\\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n启动容器：\\n\\n```\\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \\\"discovery.type=single-node\\\" docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n修改配置：\\n\\n```bash\\n#进入 docker 容器内部\\n\\ndocker exec -it es /bin/bash\\n\\n#打开配置文件\\n\\nvim config/elasticsearch.yml\\n\\n### 加入跨域配置\\n\\nhttp.cors.enabled: true\\n\\nhttp.cors.allow-origin: \\\"*\\\"\\n```\\n\\n进入容器，安装分词器：\\n\\n`', '更新博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 20, '2024-12-20 16:56:08', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (78, 'admin', '/admin/blog', 'PUT', '{\"blog\":{\"id\":6,\"title\":\"ElasticSearch 小白从入门到精通\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.png\",\"content\":\"### 什么是 ElasticSearch\\n\\nElasticSearch 简称为 ES，网址为：\\n\\n> https://www.elastic.co/\\n\\nES 是一个分布式的开源搜索和分析引擎，适用于文本、数字、地理空间、结构化数据、非结构化数据等数据的搜索。ES 是在 Apache Lucene 的基础上完成开发。由 Elastic 于 2010 年发布。ES 通过其简单的 REST 风格的 API、分布式特性、速度和可扩容闻名世界。是 Elastic Stack 的核心组件。Elastic Stack 是一套用于数据采集、扩充、保存、分析、可视化的开源工具。Elastic Stack 称之为 ELK。目前 ELK 包含一系列丰富的轻量数据采集代理，这些代理被称之为 Beats。\\n\\n#### ES 的用途\\n\\n主要有以下的用途：\\n\\n- 应用程序搜索\\n- 网站搜索\\n- 企业搜索\\n- 日志处理\\n- 基础设施指标和容器监测\\n- 应用程序性能监测\\n- 地理空间数据分析和可视化\\n- 安全分析\\n- 业务分析\\n\\n#### 工作原理\\n\\n从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，在 Kibana 中，用户可以创建数据可视化面板，并对 ELK 进行管理。\\n\\n#### 索引\\n\\nES 索引是指相互关联的文档集合。ES 是会以 JSON 文档的形式保存数据，每个文档都会在一组键值对中建立联系。\\n\\nES 使用的是一种倒排序索引的数据结构。这个结构可以允许十分快速的进行全文本的搜索。\\n\\n在索引的过程中，ES 会保存文档并构建倒排序索引，这样用户就可以实时的对文档数据进行搜索。索引是在添加过程中就启动的。\\n\\n#### Logstash\\n\\nLogstash 是 ELK 的核心菜品，可以对数据进行聚合和处理。并将数据发送到 ES 中。Logstash 是一个开源的服务器端数据处理管道。\\n\\n#### Kibana\\n\\nKibana 是一款 ES 的数据可视化和管理工具，可以提供直方图，线形图，饼状图，地图。Kibana 还包含 Canvas 和 Elastic Maps 等应用程序。Canvas 可以基于用户创建动态信息。Elastic Maps 可以对空间数据进行可视化处理。\\n\\n#### 为什么要使用 ES\\n\\n- **ES 很快**：ES 是在 Lucene 基础上构建，所以全文本搜索相当的出色。ES 还是一个实时搜索平台。文档索引操作到文档变为可搜索之间速度很快。\\n- **ES 具有分布式的特征**：ES 中保存的文档分布在不同的容器中，这些容器为分片，可以对分片进行复制并形成冗余副本。ES 可以扩充到数百台，并处理 PB 级别的数据。\\n- **ES 包含一系列广泛的功能**：ES 拥有大量的内置功能，方便用户管理数据。\\n- **ES 简化了数据采集，可视化报告的过程**：通过与 Beats 和 Logstash 集成，用户可以在 ES 中索引数据并处理数据，\\n\\n### ES 搭建\\n\\n安装镜像：\\n\\n```bash\\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n启动容器：\\n\\n```bash\\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \\\"discovery.type=single-node\\\" docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n修改配置：\\n\\n```bash\\n#进入 docker 容器内部\\n\\ndocker exec -it es /bin/bash\\n\\n#打开配置文件\\n\\nvim config/elasticsearch.yml\\n\\n### 加入跨域配置\\n\\nhttp.cors.enabled: true\\n\\nhttp.cors.allow-origin: \\\"*\\\"\\n```\\n\\n进入容器，安装分', '更新博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 21, '2024-12-20 17:06:28', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (79, 'admin', '/admin/blog', 'POST', '{\"blog\":{\"id\":7,\"title\":\"Docker 镜像构建原理及源码分析\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/engine-components-flow.png\",\"content\":\"### Docker 架构\\n\\n这里我们先从宏观上对 `Docker` 有个大概的认识，就像我[之前]提到的它整体上是个 C/S 架构；我们平时使用的 `docker` 命令就是它的 CLI 客户端，而它的服务端是 `dockerd` 在 Linux 系统中，通常我们是使用 `systemd` 进行管理，所以我们可以使用 `systemctl start docker` 来启动服务。（但是请注意，`dockerd` 是否能运行与 `systemd` 并无任何关系，你可以像平时执行一个普通的二进制程序一样，直接通过 `dockerd` 来启动服务，注意需要 root 权限）\\n\\n实际上也就是\\n\\n![Docker 架构](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/engine-components-flow.png)\\n\\n(图片来源：docker overview)\\n\\n`docker` CLI 与 `dockerd` 的交互是通过 rest API 来完成的，当我们执行 `docker version` 的时候过滤 API 可以看到如下输出：\\n\\n```bash\\n# docker version  |grep API\\n API version:       1.40\\n API version:      1.40 (minimum version 1.12)\\n```\\n\\n上面一行是 `docker` CLI 的 API 版本，下面则代表了 `dockerd` 的 API 版本，它的后面还有个括号，是因为 Docker 具备了很良好的兼容性，这里表示它最小可兼容的 API 版本是 1.12 。\\n\\n对于我们进行 C/S 架构的项目开发而言，一般都是 API 先行, 所以我们先来看下 API 的部分。\\n\\n当然，本次 Chat 的主体是构建系统相关的，所以我们就直接来看构建相关的 API 即可。\\n\\n接下来会说 CLI，代码以 v19.03.0-rc2-4-ga63faebc 为准。\\n\\n最后说服务端 Dockerd 。\\n\\n### API\\n\\nDocker 官方在每个版本正式发布之后，都会将 API 文档发布出来，在线地址是  但由于现在 19.03 还未发布，所以 1.40 版本的 API 文档也尚未正式发布。\\n\\n1.39 和 1.40 中，关于镜像构建部分的 API 其实没太大变化，所以直接参考 1.39 版本的 API 文档看也可以。或者我们也可以自行构建 API 文档。\\n\\n首先 clone Docker 的源代码仓库, 进入项目仓库内执行 `make swagger-docs` 即可在启动一个容器同时将端口暴露至本地的 `9000` 端口， 你可以直接通过  访问本地的 API 文档。\\n\\n```bash\\n(MoeLove) ➜  git clone https://github.com/docker/engine.git docker\\n(MoeLove) ➜  cd docker\\n(MoeLove) ➜  docker git:(master) git checkout -b v19.03.0-rc2 v19.03.0-rc2\\n(MoeLove) ➜  docker git:(v19.03.0-rc2) make swagger-docs\\nAPI docs preview will be running at http://localhost:9000\\n```\\n\\n打开  这个地址就可以看到 1.40 版本的构建镜像所需的 API 了。我们对此 API 进行下分析。\\n\\n#### 请求地址和方法\\n\\n接口地址是 `/v1.40/build` 方法是 `POST`\\n\\n我们可以使用一个较新版本的 `curl` 工具来验证下此接口（需要使用 `--unix-socket` 连接 Docker 监听的 UNIX Domain Socket ）\\n\\n`/var/run/docker.sock` 这是默认情况下 `dockerd` 所监听的地址，当然你也可以给 `dockerd` 传递 `--host` 参数用于监听 HTTP 端口或者其他路径的 unix so', '发布博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 49, '2024-12-20 17:16:20', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (80, 'admin', '/admin/blog', 'PUT', '{\"blog\":{\"id\":7,\"title\":\"Docker 镜像构建原理及源码分析\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/engine-components-flow.png\",\"content\":\"### Docker 架构\\n\\n这里我们先从宏观上对 `Docker` 有个大概的认识，就像我[之前]提到的它整体上是个 C/S 架构；我们平时使用的 `docker` 命令就是它的 CLI 客户端，而它的服务端是 `dockerd` 在 Linux 系统中，通常我们是使用 `systemd` 进行管理，所以我们可以使用 `systemctl start docker` 来启动服务。（但是请注意，`dockerd` 是否能运行与 `systemd` 并无任何关系，你可以像平时执行一个普通的二进制程序一样，直接通过 `dockerd` 来启动服务，注意需要 root 权限）\\n\\n实际上也就是\\n\\n![Docker 架构](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/engine-components-flow.png)\\n\\n(图片来源：docker overview)\\n\\n`docker` CLI 与 `dockerd` 的交互是通过 rest API 来完成的，当我们执行 `docker version` 的时候过滤 API 可以看到如下输出：\\n\\n```yaml\\n# docker version  |grep API\\n API version:       1.40\\n API version:      1.40 (minimum version 1.12)\\n```\\n\\n上面一行是 `docker` CLI 的 API 版本，下面则代表了 `dockerd` 的 API 版本，它的后面还有个括号，是因为 Docker 具备了很良好的兼容性，这里表示它最小可兼容的 API 版本是 1.12 。\\n\\n对于我们进行 C/S 架构的项目开发而言，一般都是 API 先行, 所以我们先来看下 API 的部分。\\n\\n当然，本次 Chat 的主体是构建系统相关的，所以我们就直接来看构建相关的 API 即可。\\n\\n接下来会说 CLI，代码以 v19.03.0-rc2-4-ga63faebc 为准。\\n\\n最后说服务端 Dockerd 。\\n\\n### API\\n\\nDocker 官方在每个版本正式发布之后，都会将 API 文档发布出来，在线地址是  但由于现在 19.03 还未发布，所以 1.40 版本的 API 文档也尚未正式发布。\\n\\n1.39 和 1.40 中，关于镜像构建部分的 API 其实没太大变化，所以直接参考 1.39 版本的 API 文档看也可以。或者我们也可以自行构建 API 文档。\\n\\n首先 clone Docker 的源代码仓库, 进入项目仓库内执行 `make swagger-docs` 即可在启动一个容器同时将端口暴露至本地的 `9000` 端口， 你可以直接通过  访问本地的 API 文档。\\n\\n```bash\\n(MoeLove) ➜  git clone https://github.com/docker/engine.git docker\\n(MoeLove) ➜  cd docker\\n(MoeLove) ➜  docker git:(master) git checkout -b v19.03.0-rc2 v19.03.0-rc2\\n(MoeLove) ➜  docker git:(v19.03.0-rc2) make swagger-docs\\nAPI docs preview will be running at http://localhost:9000\\n```\\n\\n打开  这个地址就可以看到 1.40 版本的构建镜像所需的 API 了。我们对此 API 进行下分析。\\n\\n#### 请求地址和方法\\n\\n接口地址是 `/v1.40/build` 方法是 `POST`\\n\\n我们可以使用一个较新版本的 `curl` 工具来验证下此接口（需要使用 `--unix-socket` 连接 Docker 监听的 UNIX Domain Socket ）\\n\\n`/var/run/docker.sock` 这是默认情况下 `dockerd` 所监听的地址，当然你也可以给 `dockerd` 传递 `--host` 参数用于监听 HTTP 端口或者其他路径的 unix so', '更新博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 119, '2024-12-23 09:30:29', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (81, 'admin', '/admin/blog', 'PUT', '{\"blog\":{\"id\":6,\"title\":\"ElasticSearch 小白从入门到精通\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/199ad3c0-cee2-11eb-bfdf-b9d6bba95aa3.png\",\"content\":\"### 什么是 ElasticSearch\\n\\nElasticSearch 简称为 ES，网址为：\\n\\n> https://www.elastic.co/\\n\\nES 是一个分布式的开源搜索和分析引擎，适用于文本、数字、地理空间、结构化数据、非结构化数据等数据的搜索。ES 是在 Apache Lucene 的基础上完成开发。由 Elastic 于 2010 年发布。ES 通过其简单的 REST 风格的 API、分布式特性、速度和可扩容闻名世界。是 Elastic Stack 的核心组件。Elastic Stack 是一套用于数据采集、扩充、保存、分析、可视化的开源工具。Elastic Stack 称之为 ELK。目前 ELK 包含一系列丰富的轻量数据采集代理，这些代理被称之为 Beats。\\n\\n#### ES 的用途\\n\\n主要有以下的用途：\\n\\n- 应用程序搜索\\n- 网站搜索\\n- 企业搜索\\n- 日志处理\\n- 基础设施指标和容器监测\\n- 应用程序性能监测\\n- 地理空间数据分析和可视化\\n- 安全分析\\n- 业务分析\\n\\n#### 工作原理\\n\\n从多个来源输入到 ES 中，数据在 ES 中进行索引和解析，标准化并充实这些数据。这些数据在 ES 中索引完成之后，用户就可以针对他们的数据进行复杂的查询，并使用聚合来检索这些数据，在 Kibana 中，用户可以创建数据可视化面板，并对 ELK 进行管理。\\n\\n#### 索引\\n\\nES 索引是指相互关联的文档集合。ES 是会以 JSON 文档的形式保存数据，每个文档都会在一组键值对中建立联系。\\n\\nES 使用的是一种倒排序索引的数据结构。这个结构可以允许十分快速的进行全文本的搜索。\\n\\n在索引的过程中，ES 会保存文档并构建倒排序索引，这样用户就可以实时的对文档数据进行搜索。索引是在添加过程中就启动的。\\n\\n#### Logstash\\n\\nLogstash 是 ELK 的核心菜品，可以对数据进行聚合和处理。并将数据发送到 ES 中。Logstash 是一个开源的服务器端数据处理管道。\\n\\n#### Kibana\\n\\nKibana 是一款 ES 的数据可视化和管理工具，可以提供直方图，线形图，饼状图，地图。Kibana 还包含 Canvas 和 Elastic Maps 等应用程序。Canvas 可以基于用户创建动态信息。Elastic Maps 可以对空间数据进行可视化处理。\\n\\n#### 为什么要使用 ES\\n\\n- **ES 很快**：ES 是在 Lucene 基础上构建，所以全文本搜索相当的出色。ES 还是一个实时搜索平台。文档索引操作到文档变为可搜索之间速度很快。\\n- **ES 具有分布式的特征**：ES 中保存的文档分布在不同的容器中，这些容器为分片，可以对分片进行复制并形成冗余副本。ES 可以扩充到数百台，并处理 PB 级别的数据。\\n- **ES 包含一系列广泛的功能**：ES 拥有大量的内置功能，方便用户管理数据。\\n- **ES 简化了数据采集，可视化报告的过程**：通过与 Beats 和 Logstash 集成，用户可以在 ES 中索引数据并处理数据，\\n\\n### ES 搭建\\n\\n安装镜像：\\n\\n```bash\\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n启动容器：\\n\\n```bash\\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \\\"discovery.type=single-node\\\" docker.elastic.co/elasticsearch/elasticsearch:7.3.2\\n```\\n\\n修改配置：\\n\\n```bash\\n#进入 docker 容器内部\\n\\ndocker exec -it es /bin/bash\\n\\n#打开配置文件\\n\\nvim config/elasticsearch.yml\\n\\n### 加入跨域配置\\n\\nhttp.cors.enabled: true\\n\\nhttp.cors.allow-origin: \\\"*\\\"\\n```\\n\\n进入容器，安装分', '更新博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 27, '2024-12-23 10:04:43', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (82, 'admin', '/admin/blog', 'PUT', '{\"blog\":{\"id\":5,\"title\":\"JVM 垃圾收集器\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/713d65b0-96a9-11ea-949b-db7ff35aaabb.png\",\"content\":\"**1.简述 Java 垃圾回收机制**\\n\\n在 java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在 JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。\\n\\n**2. GC 是什么？为什么要 GC**\\n\\nGC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存 回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动 回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。\\n\\n**3. 垃圾回收的优点和原理。并考虑 2 种回收机制**\\n\\nJava 语言最显著的特点就是引入了垃圾回收机制，它使 java 程序员在编写程序时不再考虑内存管理的问题。 由于有这个垃圾回收机制，java 中的对象不再有“作用域”的概念，只有引用的对象才有“作用域”。 垃圾回收机制有效的防止了内存泄露，可以有效的使用可使用的内存。 垃圾回收器通常作为一个单独的低级别的线程运行，在不可预知的情况下对内存堆中已经死亡的或很长时间没有用过的对象进行清除和回收。 程序员不能实时的对某个对象或所有对象调用垃圾回收器进行垃圾回收。 垃圾回收有分代复制垃圾回收、标记垃圾回收、增量垃圾回收。\\n\\n**4. 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？**\\n\\n对于 GC 来说，当程序员创建对象时，GC 就开始监控这个对象的地址、大小以及使用情况。 通常，GC 采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当 GC 确定一些对象为”不可达”时，GC 就有责任回收这些内存空间。 可以。程序员可以手动执行 System.gc()，通知 GC 运行，但是 Java 语言规范并不保证 GC 一定会执行。\\n\\n**5. Java 中都有哪些引用类型？**\\n\\n强引用：发生 gc 的时候不会被回收。 软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。 弱引用：有用但不是必须的对象，在下一次 GC 时会被回收。 虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。\\n\\n**6. 怎么判断对象是否可以被回收？**\\n\\n垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收的，哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收。\\n\\n一般有两种方法来判断： 引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题； 可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。\\n\\n**7. 在 Java 中，对象什么时候可以被垃圾回收?**\\n\\n当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。 垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免 Full GC 是非常重要的原因。\\n\\n**8. JVM 中的永久代中会发生垃圾回收吗?**\\n\\n垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免 Full GC 是非常重要的原因。请参考下 Java8：从永久代到元数据区 (译者注：Java8 中已经移除了永久代，新加了一个叫做元数据区的 native 内存区)\\n\\n**9. 说一下 JVM 有哪些垃圾回收算法？**\\n\\n标记-清除算法：标记无用对象，然后', '更新博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 17, '2024-12-23 10:05:33', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (83, 'admin', '/admin/blog', 'POST', '{\"blog\":{\"id\":8,\"title\":\"JVM 面试的 30 个知识点\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/c5238280-5a00-11ea-aae6-17c0629b6dc0.jpg\",\"content\":\"# 1.什么是 Java 虚拟机？为什么 Java 被称作是“平台无关的编程语言”？\\n\\nJava 虚拟机是一个可以执行 Java 字节码的虚拟机进程。Java 源文件被编译成能被 Java 虚拟机执行的字节码文件。Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。\\n\\n# 2.Java 内存结构？\\n\\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/c5238280-5a00-11ea-aae6-17c0629b6dc0.png)\\n\\n方法区和对是所有线程共享的内存区域；而 java 栈、本地方法栈和程序员计数器是运行是线程私有的内存区域。\\n\\n# 3.内存模型以及分区，需要详细到每个区放什么？\\n\\nJVM 分为堆区和栈区，还有方法区，初始化的对象放在堆里面，引用放在栈里面，class 类信息常量池（static 常量和 static 变量）等放在方法区。 new:\\n\\n- 方法区：主要是存储类信息，常量池（static 常量和 static 变量），编译后的代码（字节码）等数据\\n- 堆：初始化的对象，成员变量 （那种非 static 的变量），所有的对象实例和数组都要在堆上分配\\n- 栈：栈的结构是栈帧组成的，调用一个方法就压入一帧，帧上面存储局部变量表，操作数栈，方法出口等信息，局部变量表存放的是 8 大基础类型加上一个应用类型，所以还是一个指向地址的指针\\n- 本地方法栈：主要为 Native 方法服务\\n- 程序计数器：记录当前线程执行的行号\\n\\n# 4.堆里面的分区：Eden，survival （from+ to），老年代，各自的特点？\\n\\n堆里面分为新生代和老生代（java8 取消了永久代，采用了 Metaspace），新生代包含 Eden+Survivor 区，survivor 区里面分为 from 和 to 区，内存回收时，如果用的是复制算法，从 from 复制到 to，当经过一次或者多次 GC 之后，存活下来的对象会被移动到老年区，当 JVM 内存不够用的时候，会触发 Full GC，清理 JVM 老年区当新生区满了之后会触发 YGC,先把存活的对象放到其中一个 Survice 区，然后进行垃圾清理。\\n\\n因为如果仅仅清理需要删除的对象，这样会导致内存碎片，因此一般会把 Eden 进行完全的清理，然后整理内存。\\n\\n那么下次 GC 的时候，就会使用下一个 Survive，这样循环使用。\\n\\n如果有特别大的对象，新生代放不下，就会使用老年代的担保，直接放到老年代里面。\\n因为 JVM 认为，一般大对象的存活时间一般比较久远。\\n\\n# 5 .解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法\\n\\n通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用 JVM 中的栈空间；而通过 new 关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为 Eden、Survivor（又可分为 From Survivor 和 To Survivor）、Tenured；方法区和堆都是各个线程共享的内存区域，用于存储已经被 JVM 加载的类信息、常量、静态变量、JIT 编译器编译后的代码等数据；程序中的字面量（literal）如直接书写的 100、”hello”和常量都是放在常量池中，常量池是方法区的一部分，。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过 JVM 的启动参数来进行调整，栈空间用光了会引发 StackOverflowError，而堆和常量池空间不足则会引发 OutOfMemoryError。\\n\\n```java\\nString str = new String(\\\"hello\\\");\\n```\\n\\n上面的语句中变量 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而”hello”这个字面量是放在', '发布博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 32, '2024-12-23 10:45:12', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (84, 'admin', '/admin/blog', 'POST', '{\"blog\":{\"id\":9,\"title\":\"Java IO 体系、线程模型大总结\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/8e7d3c50-93c3-11eb-987a-1fa99aac0083.png\",\"content\":\"Java 中的 I/O 按照其发展历程，可以划分为传统 IO（阻塞式 I/O）和新 IO（非阻塞式 I/O）。\\n\\n### 传统 I/O\\n\\n传统 IO 也称为 BIO（Blocking IO），是面向字节流或字符流编程的 I/O 方式。\\n\\n一个典型的基于 BIO 的文件复制程序，字节流方式：\\n\\n```java\\npublic class FileCopy01 {\\n    public static void main(String[] args) {\\n        //使用 jdk7 引入的自动关闭资源的 try 语句（该资源类要实现 AutoCloseable 或 Closeable 接口）\\n        try (FileInputStream fis = new FileInputStream(\\\"D:\\\\\\\\file01.txt\\\");\\n             FileOutputStream fos = new FileOutputStream(\\\"D:\\\\\\\\file01_copy.txt\\\")) {\\n            byte[] buf = new byte[126];\\n            int hasRead = 0;\\n            while ((hasRead = fis.read(buf)) > 0) {\\n                //每次读取多少就写多少\\n                fos.write(buf, 0, hasRead);\\n            }\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n    }\\n}\\n```\\n\\n字符流方式：\\n\\n```java\\npublic class FileCopy02 {\\n    public static void main(String[] args) {\\n        //使用 jdk7 引入的自动关闭资源的 try 语句\\n        try (FileReader fr = new FileReader(\\\"D:\\\\\\\\file01.txt\\\");\\n             FileWriter fw = new FileWriter(\\\"D:\\\\\\\\file01_copy2.txt\\\")) {\\n            char[] buf = new char[2];\\n            int hasRead = 0;\\n            while ((hasRead = fr.read(buf)) > 0) {\\n                //每次读取多少就写多少\\n                fw.write(buf, 0, hasRead);\\n            }\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n    }\\n}\\n```\\n\\n字符缓冲，按行读取：\\n\\n```java\\npublic class FileCopy02_2 {\\n    public static void main(String[] args) {\\n        //使用普通的 Reader 不方便整行读取,可以使用 BufferReader 包装,资源变量要定义在 try()中,否则不会自动关闭\\n        try (FileReader fr = new FileReader(\\\"D:\\\\\\\\file01.txt\\\");\\n             FileWriter fw = new FileWriter(\\\"D:\\\\\\\\file01_copy2_2.txt\\\");\\n             BufferedReader bufferedReader = new BufferedReader(fr);\\n             BufferedWriter bufferedWriter = new BufferedWriter(fw)', '发布博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 65, '2024-12-23 10:51:53', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (85, 'admin', '/admin/blog', 'PUT', '{\"blog\":{\"id\":9,\"title\":\"Java IO 体系、线程模型大总结\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/8e7d3c50-93c3-11eb-987a-1fa99aac0083.png\",\"content\":\"Java 中的 I/O 按照其发展历程，可以划分为传统 IO（阻塞式 I/O）和新 IO（非阻塞式 I/O）。\\n\\n### 传统 I/O\\n\\n传统 IO 也称为 BIO（Blocking IO），是面向字节流或字符流编程的 I/O 方式。\\n\\n一个典型的基于 BIO 的文件复制程序，字节流方式：\\n\\n```java\\npublic class FileCopy01 {\\n    public static void main(String[] args) {\\n        //使用 jdk7 引入的自动关闭资源的 try 语句（该资源类要实现 AutoCloseable 或 Closeable 接口）\\n        try (FileInputStream fis = new FileInputStream(\\\"D:\\\\\\\\file01.txt\\\");\\n             FileOutputStream fos = new FileOutputStream(\\\"D:\\\\\\\\file01_copy.txt\\\")) {\\n            byte[] buf = new byte[126];\\n            int hasRead = 0;\\n            while ((hasRead = fis.read(buf)) > 0) {\\n                //每次读取多少就写多少\\n                fos.write(buf, 0, hasRead);\\n            }\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n    }\\n}\\n```\\n\\n字符流方式：\\n\\n```java\\npublic class FileCopy02 {\\n    public static void main(String[] args) {\\n        //使用 jdk7 引入的自动关闭资源的 try 语句\\n        try (FileReader fr = new FileReader(\\\"D:\\\\\\\\file01.txt\\\");\\n             FileWriter fw = new FileWriter(\\\"D:\\\\\\\\file01_copy2.txt\\\")) {\\n            char[] buf = new char[2];\\n            int hasRead = 0;\\n            while ((hasRead = fr.read(buf)) > 0) {\\n                //每次读取多少就写多少\\n                fw.write(buf, 0, hasRead);\\n            }\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n    }\\n}\\n```\\n\\n字符缓冲，按行读取：\\n\\n```java\\npublic class FileCopy02_2 {\\n    public static void main(String[] args) {\\n        //使用普通的 Reader 不方便整行读取,可以使用 BufferReader 包装,资源变量要定义在 try()中,否则不会自动关闭\\n        try (FileReader fr = new FileReader(\\\"D:\\\\\\\\file01.txt\\\");\\n             FileWriter fw = new FileWriter(\\\"D:\\\\\\\\file01_copy2_2.txt\\\");\\n             BufferedReader bufferedReader = new BufferedReader(fr);\\n             BufferedWriter bufferedWriter = new BufferedWriter(fw)', '更新博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 35, '2024-12-23 10:54:40', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (86, 'admin', '/admin/blog', 'PUT', '{\"blog\":{\"id\":7,\"title\":\"Docker 镜像构建原理及源码分析\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/engine-components-flow.png\",\"content\":\"### Docker 架构\\n\\n这里我们先从宏观上对 `Docker` 有个大概的认识，就像我[之前]提到的它整体上是个 C/S 架构；我们平时使用的 `docker` 命令就是它的 CLI 客户端，而它的服务端是 `dockerd` 在 Linux 系统中，通常我们是使用 `systemd` 进行管理，所以我们可以使用 `systemctl start docker` 来启动服务。（但是请注意，`dockerd` 是否能运行与 `systemd` 并无任何关系，你可以像平时执行一个普通的二进制程序一样，直接通过 `dockerd` 来启动服务，注意需要 root 权限）\\n\\n实际上也就是\\n\\n![Docker 架构](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/engine-components-flow.png)\\n\\n(图片来源：docker overview)\\n\\n`docker` CLI 与 `dockerd` 的交互是通过 rest API 来完成的，当我们执行 `docker version` 的时候过滤 API 可以看到如下输出：\\n\\n```yaml\\n# docker version  |grep API\\n API version:       1.40\\n API version:      1.40 (minimum version 1.12)\\n```\\n\\n上面一行是 `docker` CLI 的 API 版本，下面则代表了 `dockerd` 的 API 版本，它的后面还有个括号，是因为 Docker 具备了很良好的兼容性，这里表示它最小可兼容的 API 版本是 1.12 。\\n\\n对于我们进行 C/S 架构的项目开发而言，一般都是 API 先行, 所以我们先来看下 API 的部分。\\n\\n当然，本次 Chat 的主体是构建系统相关的，所以我们就直接来看构建相关的 API 即可。\\n\\n接下来会说 CLI，代码以 v19.03.0-rc2-4-ga63faebc 为准。\\n\\n最后说服务端 Dockerd 。\\n\\n### API\\n\\nDocker 官方在每个版本正式发布之后，都会将 API 文档发布出来，在线地址是  但由于现在 19.03 还未发布，所以 1.40 版本的 API 文档也尚未正式发布。\\n\\n1.39 和 1.40 中，关于镜像构建部分的 API 其实没太大变化，所以直接参考 1.39 版本的 API 文档看也可以。或者我们也可以自行构建 API 文档。\\n\\n首先 clone Docker 的源代码仓库, 进入项目仓库内执行 `make swagger-docs` 即可在启动一个容器同时将端口暴露至本地的 `9000` 端口， 你可以直接通过  访问本地的 API 文档。\\n\\n```bash\\n(MoeLove) ➜  git clone https://github.com/docker/engine.git docker\\n(MoeLove) ➜  cd docker\\n(MoeLove) ➜  docker git:(master) git checkout -b v19.03.0-rc2 v19.03.0-rc2\\n(MoeLove) ➜  docker git:(v19.03.0-rc2) make swagger-docs\\nAPI docs preview will be running at http://localhost:9000\\n```\\n\\n打开  这个地址就可以看到 1.40 版本的构建镜像所需的 API 了。我们对此 API 进行下分析。\\n\\n#### 请求地址和方法\\n\\n接口地址是 `/v1.40/build` 方法是 `POST`\\n\\n我们可以使用一个较新版本的 `curl` 工具来验证下此接口（需要使用 `--unix-socket` 连接 Docker 监听的 UNIX Domain Socket ）\\n\\n`/var/run/docker.sock` 这是默认情况下 `dockerd` 所监听的地址，当然你也可以给 `dockerd` 传递 `--host` 参数用于监听 HTTP 端口或者其他路径的 unix so', '更新博客', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 26, '2024-12-23 10:56:40', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (87, 'admin', '/admin/siteSettings', 'POST', '{\"map\":{\"settings\":[{\"id\":1,\"nameEn\":\"blogName\",\"nameZh\":\"博客名称\",\"value\":\"Youta\'s Blog\",\"type\":1},{\"id\":2,\"nameEn\":\"webTitleSuffix\",\"nameZh\":\"网页标题后缀\",\"value\":\" - Youta\'s Blog\",\"type\":1},{\"id\":3,\"nameEn\":\"footerImgTitle\",\"nameZh\":\"页脚图片标题\",\"value\":\"欢迎来到本站\",\"type\":1},{\"id\":4,\"nameEn\":\"footerImgUrl\",\"nameZh\":\"页脚图片路径\",\"value\":\"/img/panda-waving.png\",\"type\":1},{\"id\":5,\"nameEn\":\"copyright\",\"nameZh\":\"Copyright\",\"value\":\"{\\\"title\\\":\\\"Copyright © 2024 - 2025\\\",\\\"siteName\\\":\\\"YOUTA\'S BLOG\\\"}\",\"type\":1},{\"id\":6,\"nameEn\":\"beian\",\"nameZh\":\"ICP备案号\",\"value\":\"\",\"type\":1},{\"id\":7,\"nameEn\":\"reward\",\"nameZh\":\"赞赏码\",\"value\":\"/img/reward.png\",\"type\":1},{\"id\":8,\"nameEn\":\"commentAdminFlag\",\"nameZh\":\"博主评论标识\",\"value\":\"咕咕\",\"type\":1},{\"id\":9,\"nameEn\":\"playlistServer\",\"nameZh\":\"播放器平台\",\"value\":\"netease\",\"type\":1},{\"id\":10,\"nameEn\":\"playlistId\",\"nameZh\":\"播放器歌单\",\"value\":\"3071528549\",\"type\":1},{\"id\":11,\"nameEn\":\"avatar\",\"nameZh\":\"头像\",\"value\":\"/img/avatar.png\",\"type\":2},{\"id\":12,\"nameEn\":\"name\",\"nameZh\":\"昵称\",\"value\":\"Youta\",\"type\":2},{\"id\":13,\"nameEn\":\"rollText\",\"nameZh\":\"滚动个签\",\"value\":\"\\\"积跬步以至千里\\\"，\\\"致敬每一个爱学习的你\\\"\",\"type\":2},{\"id\":14,\"nameEn\":\"github\",\"nameZh\":\"GitHub\",\"value\":\"\",\"type\":2},{\"id\":15,\"nameEn\":\"telegram\",\"nameZh\":\"Telegram\",\"value\":\"\",\"type\":2},{\"id\":16,\"nameEn\":\"qq\",\"nameZh\":\"QQ\",\"value\":\"\",\"type\":2},{\"id\":17,\"nameEn\":\"bilibili\",\"nameZh\":\"bilibili\",\"value\":\"\",\"type\":2},{\"id\":18,\"nameEn\":\"netease\",\"nameZh\":\"网易云音乐\",\"value\":\"https://music.163.com/#/user/home?id=429146781\",\"type\":2},{\"id\":19,\"nameEn\":\"email\",\"nameZh\":\"email\",\"value\":\"mailto:i@youtatu.us.kg\",\"type\":2}],\"deleteIds\":[]}}', '更新站点配置信息', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 30, '2024-12-23 11:00:34', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (88, 'admin', '/admin/siteSettings', 'POST', '{\"map\":{\"settings\":[{\"id\":1,\"nameEn\":\"blogName\",\"nameZh\":\"博客名称\",\"value\":\"Youta\'s Blog\",\"type\":1},{\"id\":2,\"nameEn\":\"webTitleSuffix\",\"nameZh\":\"网页标题后缀\",\"value\":\" - Youta\'s Blog\",\"type\":1},{\"id\":3,\"nameEn\":\"footerImgTitle\",\"nameZh\":\"页脚图片标题\",\"value\":\"欢迎来到本站\",\"type\":1},{\"id\":4,\"nameEn\":\"footerImgUrl\",\"nameZh\":\"页脚图片路径\",\"value\":\"/img/panda-waving.png\",\"type\":1},{\"id\":5,\"nameEn\":\"copyright\",\"nameZh\":\"Copyright\",\"value\":\"{\\\"title\\\":\\\"Copyright © 2024 - 2025\\\",\\\"siteName\\\":\\\"YOUTA\'S BLOG\\\"}\",\"type\":1},{\"id\":6,\"nameEn\":\"beian\",\"nameZh\":\"ICP备案号\",\"value\":\"\",\"type\":1},{\"id\":7,\"nameEn\":\"reward\",\"nameZh\":\"赞赏码\",\"value\":\"/img/reward.png\",\"type\":1},{\"id\":8,\"nameEn\":\"commentAdminFlag\",\"nameZh\":\"博主评论标识\",\"value\":\"youta\",\"type\":1},{\"id\":9,\"nameEn\":\"playlistServer\",\"nameZh\":\"播放器平台\",\"value\":\"netease\",\"type\":1},{\"id\":10,\"nameEn\":\"playlistId\",\"nameZh\":\"播放器歌单\",\"value\":\"3071528549\",\"type\":1},{\"id\":11,\"nameEn\":\"avatar\",\"nameZh\":\"头像\",\"value\":\"/img/avatar.png\",\"type\":2},{\"id\":12,\"nameEn\":\"name\",\"nameZh\":\"昵称\",\"value\":\"Youta\",\"type\":2},{\"id\":13,\"nameEn\":\"rollText\",\"nameZh\":\"滚动个签\",\"value\":\"\\\"积跬步以至千里\\\"，\\\"致敬每一个爱学习的你\\\"\",\"type\":2},{\"id\":14,\"nameEn\":\"github\",\"nameZh\":\"GitHub\",\"value\":\"\",\"type\":2},{\"id\":15,\"nameEn\":\"telegram\",\"nameZh\":\"Telegram\",\"value\":\"\",\"type\":2},{\"id\":16,\"nameEn\":\"qq\",\"nameZh\":\"QQ\",\"value\":\"\",\"type\":2},{\"id\":17,\"nameEn\":\"bilibili\",\"nameZh\":\"bilibili\",\"value\":\"\",\"type\":2},{\"id\":18,\"nameEn\":\"netease\",\"nameZh\":\"网易云音乐\",\"value\":\"https://music.163.com/#/user/home?id=429146781\",\"type\":2},{\"id\":19,\"nameEn\":\"email\",\"nameZh\":\"email\",\"value\":\"mailto:i@youtatu.us.kg\",\"type\":2}],\"deleteIds\":[]}}', '更新站点配置信息', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 15, '2024-12-23 11:32:30', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (89, 'admin', '/admin/tag', 'PUT', '{\"tag\":{\"id\":5,\"name\":\"Docker\",\"color\":\"blue\",\"blogs\":[]}}', '修改标签', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-23 11:32:45', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (90, 'admin', '/admin/tag', 'PUT', '{\"tag\":{\"id\":6,\"name\":\"Go\",\"color\":\"teal\",\"blogs\":[]}}', '修改标签', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 13, '2024-12-23 11:32:50', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (91, 'admin', '/admin/category', 'DELETE', '{\"id\":1}', '删除分类', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 11, '2024-12-23 11:33:25', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (92, 'admin', '/admin/category', 'DELETE', '{\"id\":8}', '删除分类', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-23 11:33:27', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (93, 'admin', '/admin/category', 'DELETE', '{\"id\":9}', '删除分类', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-23 11:33:28', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (94, 'admin', '/admin/category', 'DELETE', '{\"id\":10}', '删除分类', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 2, '2024-12-23 11:33:29', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (95, 'admin', '/admin/category', 'DELETE', '{\"id\":11}', '删除分类', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-23 11:34:10', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (96, 'admin', '/admin/category', 'POST', '{\"category\":{\"id\":12,\"name\":\"其他\",\"blogs\":[]}}', '添加分类', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-23 11:34:55', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (97, 'admin', '/admin/category', 'POST', '{\"category\":{\"id\":13,\"name\":\"文章\",\"blogs\":[]}}', '添加分类', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-23 11:35:02', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (98, 'admin', '/admin/category', 'POST', '{\"category\":{\"id\":14,\"name\":\"后端\",\"blogs\":[]}}', '添加分类', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-23 11:35:07', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (99, 'admin', '/admin/category', 'POST', '{\"category\":{\"id\":15,\"name\":\"前端\",\"blogs\":[]}}', '添加分类', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-23 11:35:12', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (100, 'admin', '/admin/blog/recommend', 'PUT', '{\"id\":9,\"recommend\":false}', '更新博客推荐状态', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 26, '2024-12-24 14:14:13', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (101, 'admin', '/admin/blog/recommend', 'PUT', '{\"id\":9,\"recommend\":true}', '更新博客推荐状态', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-24 14:14:14', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (102, 'admin', '/admin/blog', 'POST', '{\"blog\":{\"id\":10,\"title\":\"Java NIO浅析\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-f47206d5b5e64448744b85eaf568f92d_1440w.png\",\"content\":\"NIO（Non-blocking I/O，在Java领域，也称为New I/O），是一种同步非阻塞的I/O模型，也是I/O多路复用的基础，已经被越来越多地应用到大型应用服务器，成为解决高并发与大量连接、I/O处理问题的有效方式。\\n\\n那么NIO的本质是什么样的呢？它是怎样与事件模型结合来解放线程、提高系统吞吐的呢？\\n\\n本文会从传统的阻塞I/O和线程池模型面临的问题讲起，然后对比几种常见I/O模型，一步步分析NIO怎么利用事件模型处理I/O，解决线程池瓶颈处理海量连接，包括利用面向事件的方式编写服务端/客户端程序。最后延展到一些高级主题，如Reactor与Proactor模型的对比、Selector的唤醒、Buffer的选择等。\\n\\n注：本文的代码都是伪代码，主要是为了示意，不可用于生产环境。\\n\\n# 传统BIO模型分析\\n\\n让我们先回忆一下传统的服务器端同步阻塞I/O处理（也就是BIO，Blocking I/O）的经典编程模型：\\n\\n```java\\n{\\n ExecutorService executor = Excutors.newFixedThreadPollExecutor(100);//线程池\\n\\n ServerSocket serverSocket = new ServerSocket();\\n serverSocket.bind(8088);\\n while(!Thread.currentThread.isInturrupted()){//主线程死循环等待新连接到来\\n Socket socket = serverSocket.accept();\\n executor.submit(new ConnectIOnHandler(socket));//为新的连接创建新的线程\\n}\\n\\nclass ConnectIOnHandler extends Thread{\\n    private Socket socket;\\n    public ConnectIOnHandler(Socket socket){\\n       this.socket = socket;\\n    }\\n    public void run(){\\n      while(!Thread.currentThread.isInturrupted()&&!socket.isClosed()){死循环处理读写事件\\n          String someThing = socket.read()....//读取数据\\n          if(someThing!=null){\\n             ......//处理数据\\n             socket.write()....//写数据\\n          }\\n\\n      }\\n    }\\n}\\n```\\n\\n这是一个经典的每连接每线程的模型，之所以使用多线程，主要原因在于socket.accept()、socket.read()、socket.write()三个主要函数都是同步阻塞的，当一个连接在处理I/O的时候，系统是阻塞的，如果是单线程的话必然就挂死在那里；但CPU是被释放出来的，开启多线程，就可以让CPU去处理更多的事情。其实这也是所有使用多线程的本质：\\n\\n1. 利用多核。\\n2. 当I/O阻塞系统，但CPU空闲的时候，可以利用多线程使用CPU资源。\\n\\n现在的多线程一般都使用线程池，可以让线程的创建和回收成本相对较低。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的I/O并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。\\n\\n不过，这个模型最本质的问题在于，严重依赖于线程。但线程是很”贵”的资源，主要表现在：\\n\\n1. 线程的创建和销毁成本很高，在Linux这样的操作系统中，线程本质上就是一个进程。创建和销毁都是重量级的系统函数。\\n2. 线程本身占用较大内存，像Java的线程栈，一般至少分配512K～1M的空间，如果系统中的线程数过千，恐怕整个JVM的内存都会被吃掉一半。\\n3. 线程的切换成本是很高的。操作系统发生线程切换的时候，需要保留线程的上下文', '发布博客', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 29, '2024-12-24 14:18:25', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (103, 'admin', '/admin/blog', 'POST', '{\"blog\":{\"id\":11,\"title\":\"Java-直接内存 DirectMemory 详解\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/1634111413579.png\",\"content\":\"# Java 直接内存\\n\\n## 1. 设计逻辑\\n\\n下面是 《深入理解 Java 虚拟机 第三版》2.2.7 小节 关于 Java 直接内存的描述。\\n\\n> 直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现，所以我们放到这里一起讲解。   在 JDK 1.4 中新加入了 NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里面的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。   显然，本机直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置 -Xmx 等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 OutOfMemoryError 异常。\\n\\n如果整理周志明对其描述的要的，那便是如下：\\n\\n- Direct Memory 并不是虚拟机运行时数据区的一部分；\\n- 由于在 JDK 1.4 中引入了 NIO 机制，为此实现了一种通过 native 函数直接分配对外内存的，而这一切是通过以下两个概念实现的：\\n- 通过存储在 Java 堆里面的 DirectByteBuffer**对象**对这块内存的引用进行操作；\\n- 因避免了 Java 堆和 Native 堆（native heap）中来回复制数据，所以在一些场景中显著提高了性能；\\n- 直接内存出现 OutOfMemoryError 异常的原因是物理机器的内存是受限的，但是我们通常会忘记需要为直接内存在物理机中预留相关内存空间；\\n\\n- 通道（Channel）;\\n- 缓冲区（Buffer）;\\n\\n上述变化可以通过下面一图来表示：\\n\\n![1634111413579](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/1634111413579.png)\\n\\n- 关于上述的内存：可以这么粗浅地认为：栈用于方法的层层调用、返回、顺序执行，堆负责存储对象。\\n- 关于内存空间的称呼变化：JDK 1.4 之前的称呼 native heap 转为现在的称呼 directory memory 。之所以 heap 前加 native 来修饰，是因为要让其和虚拟机规范中的内存 heap，而现在称呼 directory memory 是因为我们能够直接通过引用访问对象，消除了拷贝操作。\\n\\n实际上，栈中访问一个对象还是要借助堆，stack 寻求一个对象还是和以前一样，会问：”堆，请把对象xxx给我“，而不会向 native 堆索要。所以这个直接性是不彻底的。真正的实现是这样的，Java 程序仍然需要使用在 Java heap 中的一个对象（实际上规定为 DirectByteBuffer 类型对象来操作），但是这个对象（buffer）所持有的数据实际上存储于 native memory 中，而 Java 堆只仅仅拥有着对 native heap 的一个引用。\\n\\n## 2. 垃圾回收\\n\\n先的回答是不是的问题：直接内存也是会被 JVM 虚拟机管理进行完全不被引用的对象回收处理。\\n\\n但是直接内存中的对象并不是如普通对象样被 GC 管理，这方面细节会在下一小节中提到。\\n\\n## 3. 为什么需要 DirectByteBuffer\\n\\n即使不清楚 Java 设计者们会提出一个新的内存概念，不过也不难推断出其原因：由于 JVM 规范中的 heap 不满足某些领域的使用要求。\\n\\n首先，回答为什么需要 Buffer 。\\n\\n我们知道 GC 会管理内存，大致上可以这么认为，其主要做两件事：\\n\\n- 回收不被引用的', '发布博客', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 17, '2024-12-24 14:33:56', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (104, 'admin', '/admin/blog', 'POST', '{\"blog\":{\"id\":12,\"title\":\"Java中9种常见的CMS GC问题分析与解决（上）\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-60d737e7e61afcf601d9e2d4506c92f9_1440w.png\",\"content\":\"> 目前，互联网上 Java 的 GC 资料要么是主要讲解理论，要么就是针对单一场景的 GC 问题进行了剖析，对整个体系总结的资料少之又少。前车之鉴，后事之师，美团的几位工程师历时一年多的时间，搜集了内部各种 GC 问题的分析文章，并结合个人的理解做了一些总结，希望能起到“抛砖引玉”的作用。\\n\\n# 1. 写在前面\\n\\n**|**本文主要针对 Hotspot VM 中“CMS + ParNew”组合的一些使用场景进行总结。重点通过部分源码对根因进行分析以及对排查方法进行总结，排查过程会省略较多。另外，本文专业术语较多，有一定的阅读门槛，如未介绍清楚，还请自行查阅相关材料。\\n\\n**|**本文总字数 2 万左右（不包含代码片段），整体阅读时间约 30min ，文章较长，可以选择你感兴趣的场景进行研究。\\n\\n本篇系第一部分。\\n\\n**1.1 引言**\\n\\n自 Sun 发布 Java 语言以来，开始使用 GC 技术来进行内存自动管理，避免了手动管理带来的悬挂指针（Dangling Pointer）问题，很大程度上提升了开发效率，从此 GC 技术也一举成名。GC 有着非常悠久的历史，1960 年有着“Lisp 之父”和“人工智能之父”之称的 John McCarthy 就在论文中发布了 GC 算法，60 年以来， GC 技术的发展也突飞猛进，但不管是多么前沿的收集器也都是基于三种基本算法的组合或应用，也就是说 GC 要解决的根本问题这么多年一直都没有变过。笔者认为，在不太远的将来， GC 技术依然不会过时，比起日新月异的新技术，GC 这门古典技术更值得我们学习。\\n\\n那么，GC 问题处理能力能不能系统性掌握？一些影响因素都是**互为因果**的问题该怎么分析？比如一个服务 RT 突然上涨，有 GC 耗时增大、线程 Block 增多、慢查询增多、CPU 负载高四个表象，到底哪个是诱因？如何判断 GC 有没有问题？使用 CMS 有哪些常见问题？如何判断根因是什么？如何解决或避免这些问题？阅读完本文，相信你将会对 CMS GC 的问题处理有一个系统性的认知，更能游刃有余地解决这些问题，下面就让我们开始吧！文中若有错误之处，还请大家不吝指正。\\n\\n**1.2 概览**\\n\\n想要系统性地掌握 GC 问题处理，笔者这里给出一个学习路径，整体文章的框架也是按照这个结构展开，主要分四大步。\\n\\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-60d737e7e61afcf601d9e2d4506c92f9_1440w.png)\\n\\n- **建立知识体系：**从 JVM 的内存结构到垃圾收集的算法和收集器，学习 GC 的基础知识，掌握一些常用的 GC 问题分析工具。\\n- **确定评价指标：**了解基本 GC 的评价方法，摸清如何设定独立系统的指标，以及在业务场景中判断 GC 是否存在问题的手段。\\n- **场景调优实践：**运用掌握的知识和系统评价指标，分析与解决九种 CMS 中常见 GC 问题场景。\\n- **总结优化经验：**对整体过程做总结并提出笔者的几点建议，同时将总结到的经验完善到知识体系之中。\\n\\n# 2. GC 基础\\n\\n在正式开始前，先做些简要铺垫，介绍下 JVM 内存划分、收集算法、收集器等常用概念介绍，基础比较好的同学可以直接跳过这部分。\\n\\n## 2.1 基础概念\\n\\n- **GC：**GC 本身有三种语义，下文需要根据具体场景带入不同的语义：\\n- \\n- **Mutator：**生产垃圾的角色，也就是我们的应用程序，垃圾制造者，通过 Allocator 进行 allocate 和 free。\\n- **TLAB：**Thread Local Allocation Buffer 的简写，基于 CAS 的独享线程（Mutator Threads）可以优先将对象分配在 Eden 中的一块内存，因为是 Java 线程独享的内存区没有锁竞争，所以分配速度更快，每个 TLAB 都是一个线程独享的。\\n- **Card Table：**中文翻译为卡表，主要是用来标记卡页的状态，每个卡表项对应一个卡页。当卡页中一个对象引用有写操作时，写屏障将', '发布博客', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 29, '2024-12-24 14:42:51', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (105, 'admin', '/admin/blog', 'POST', '{\"blog\":{\"id\":13,\"title\":\"Java中9种常见的CMS GC问题分析与解决（下）\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-4053612fa65cc0e94680cb8038dc68f2_1440w.png\",\"content\":\"目前，互联网上 Java 的 GC 资料要么是主要讲解理论，要么就是针对单一场景的 GC 问题进行了剖析，对整个体系总结的资料少之又少。前车之鉴，后事之师，美团的几位工程师历时一年多的时间，搜集了内部各种 GC 问题的分析文章，并结合个人的理解做了一些总结，希望能起到“抛砖引玉”的作用。\\n\\n## 1. 写在前面\\n\\n**|**本文主要针对 Hotspot VM 中“CMS + ParNew”组合的一些使用场景进行总结。重点通过部分源码对根因进行分析以及对排查方法进行总结，排查过程会省略较多。另外，本文专业术语较多，有一定的阅读门槛，如未介绍清楚，还请自行查阅相关材料。\\n\\n**|**本文总字数 2 万左右（不包含代码片段），整体阅读时间约 30min ，文章较长，可以选择你感兴趣的场景进行研究。\\n\\n本篇系第二部分。\\n\\n**4.6 场景六：单次 CMS Old GC 耗时长**\\n\\n**4.6.1 现象**\\n\\nCMS GC 单次 STW 最大超过 1000ms，不会频繁发生，如下图所示最长达到了 8000ms。某些场景下会引起“雪崩效应”，这种场景非常危险，我们应该尽量避免出现。\\n\\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/v2-4053612fa65cc0e94680cb8038dc68f2_1440w.png)\\n\\n**4.6.2 原因**\\n\\nCMS 在回收的过程中，STW 的阶段主要是 Init Mark 和 Final Remark 这两个阶段，也是导致 CMS Old GC 最多的原因，另外有些情况就是在 STW 前等待 Mutator 的线程到达 SafePoint 也会导致时间过长，但这种情况较少，我们在此处主要讨论前者。发生收集器退化或者碎片压缩的场景请看场景七。\\n\\n想要知道这两个阶段为什么会耗时，我们需要先看一下这两个阶段都会干什么。\\n\\n核心代码都在 /src/hotspot/share/gc/cms/concurrentMarkSweepGeneration.cpp 中，内部有个线程 ConcurrentMarkSweepThread 轮询来校验，Old 区的垃圾回收相关细节被完全封装在 CMSCollector 中，调用入口就是 ConcurrentMarkSweepThread 调用的 CMSCollector::collect_in_background 和 ConcurrentMarkSweepGeneration 调用的 CMSCollector::collect 方法，此处我们讨论大多数场景的 collect_in_background。整个过程中会 STW 的主要是 initial Mark 和 Final Remark，核心代码在 VM_CMS_Initial_Mark / VM_CMS_Final_Remark 中，执行时需要将执行权交由 VMThread 来执行。\\n\\n- CMS Init Mark执行步骤，实现在 CMSCollector::checkpointRootsInitialWork() 和 CMSParInitialMarkTask::work 中，整体步骤和代码如下：\\n\\nCMSCollector::checkpointRootsInitialWork()\\n\\n```cpp\\nvoid CMSCollector::checkpointRootsInitialWork() {\\n  assert(SafepointSynchronize::is_at_safepoint(), \\\"world should be stopped\\\");\\n  assert(_collectorState == InitialMarking, \\\"just checking\\\");\\n\\n  // Already have locks.\\n  assert_lock_strong(bitMapLock());\\n  assert(_markBitMap.isAllClear(), \\\"was reset at end of previous cycle\\\");\\n\\n  // S', '发布博客', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 23, '2024-12-24 14:45:52', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (106, 'admin', '/admin/blog', 'POST', '{\"blog\":{\"id\":14,\"title\":\"Java中的SPI\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/20201206231416917.png\",\"content\":\"## 前言\\n\\n最近在面试的时候被问到SPI了，没回答上来，主要也是自己的原因，把自己给带沟里去了，因为讲到了类加载器的双亲委派模型，后面就被问到了有哪些是破坏了双亲委派模型的场景，然后我就说到了SPI，JNDI，以及JDK9的模块化都破坏了双亲委派。\\n然后就被问，那你说说对Java中的SPI的理解吧。然后我就一脸懵逼了，之前只是知道它会破坏双亲委派，也知道是个怎么回事，但是并没有深入了解，那么这次我就好好的来总结一下这个知识吧。\\n\\n## 什么是SPI\\n\\nSPI全称Service Provider Interface，字面意思是提供服务的接口，再解释详细一下就是**Java提供的一套用来被第三方实现或扩展的接口，实现了接口的动态扩展，让第三方的实现类能像插件一样嵌入到系统中。**\\n\\n咦。。。\\n这个解释感觉还是有点绕口。\\n那就说一下它的本质。\\n\\n> 将接口的实现类的全限定名配置在文件中（文件名是接口的全限定名），由服务加载器读取配置文件，加载实现类。实现了运行时动态为接口替换实现类。\\n\\n## SPI示例\\n\\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/20201206231416917.png)\\n\\n```java\\n/**\\n * @author jimoer\\n **/\\npublic interface SpiInterfaceService {\\n\\n    /**\\n     * 打印参数\\n     * @param parameter 参数\\n     */\\n    void printParameter(String parameter);\\n}\\n```\\n\\n再定义一个module，名字叫spi-service-one，pom.xml中依赖spi-interface。\\n在spi-service-one中定义一个实现类，实现SpiInterfaceService 接口。\\n\\n```java\\npackage com.jimoer.spi.service.one;\\nimport com.jimoer.spi.app.SpiInterfaceService;\\n\\n/**\\n * @author jimoer\\n **/\\npublic class SpiOneService implements SpiInterfaceService {\\n    /**\\n     * 打印参数\\n     *\\n     * @param parameter 参数\\n     */\\n    @Override\\n    public void printParameter(String parameter) {\\n        System.out.println(\\\"我是SpiOneService:\\\"+parameter);\\n    }\\n}\\n```\\n\\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/20201206230909117.png)\\n\\n```java\\npackage com.jimoer.spi.service.two;\\nimport com.jimoer.spi.app.SpiInterfaceService;\\n/**\\n * @author jimoer\\n **/\\npublic class SpiTwoService implements SpiInterfaceService {\\n    /**\\n     * 打印参数\\n     *\\n     * @param parameter 参数\\n     */\\n    @Override\\n    public void printParameter(String parameter) {\\n        System.out.println(\\\"我是SpiTwoService:\\\"+parameter);\\n    }\\n}\\n```\\n\\n![在这里插入图片描述](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/a', '发布博客', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 15, '2024-12-24 14:49:32', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (107, 'admin', '/admin/blog', 'POST', '{\"blog\":{\"id\":15,\"title\":\"Java中的ThreadLocal\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/20200909231451433.png\",\"content\":\"## 前言\\n\\n面试的时候被问到ThreadLocal的相关知识，没有回答好（奶奶的，现在感觉问啥都能被问倒），所以我决定先解决这几次面试中都遇到的高频问题，把这几个硬骨头都能理解的透彻的说出来了，感觉最起码不能总是一轮游。\\n\\n### ThreadLocal介绍\\n\\nThreadLocal是JDK1.2开始就提供的一个用来存储线程本地变量的类。ThreadLocal中的变量是在每个线程中独立存在的，当多个线程访问ThreadLocal中的变量的时候，其实都是访问的自己当前线程的内存中的变量，从而保证的变量的线程安全。\\n\\n我们一般在使用ThreadLocal的时候都是为了解决线程中存在的变量竞争问题。其实解决这类问题，通常大家也会想到使用synchronized来加锁解决。\\n\\n例如在解决SimpleDateFormat的线程安全的时候。SimpleDateFormat是非线程安全的，它里面无论的是format()方法还是parse()方法，都有使用它自己内部的一个Calendar类的对象，format方法是设置时间，parse()方法里面是先调用Calendar的clear()方法，然后又调用了Calendar的set()方法（赋值），如果一个线程刚调用了set()进行赋值，这个时候又来了一个线程直接调用了clear()方法，那么这个parse()方法执行的结果就会有问题的。\\n**解决办法一**\\n将使用SimpleDateformat的方法加上synchronized，这样虽然保证了线程安全，但却降低了效率，同一时间只有一个线程能使用格式化时间的方法。\\n\\n```java\\nprivate static SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\\\"yyyy-MM-dd HH:mm:ss\\\");\\n\\npublic static synchronized String formatDate(Date date){\\n    return simpleDateFormat.format(date);\\n}\\n```\\n\\n**解决办法二**\\n将SimpleDateFormat的对象，放到ThreadLocal里面，这样每个线程中都有一个自己的格式对象的副本了。互不干扰，从而保证了线程安全。\\n\\n```java\\nprivate static final ThreadLocal<SimpleDateFormat> simpleDateFormatThreadLocal = ThreadLocal.withInitial(() -> new SimpleDateFormat(\\\"yyyy-MM-dd HH:mm:ss\\\"));\\n\\npublic static String formatDate(Date date){\\n   return simpleDateFormatThreadLocal.get().format(date);\\n}\\n```\\n\\n### ThreadLocal的原理\\n\\n我们先看一下ThreadLocal是怎么使用的。\\n\\n```java\\nThreadLocal<Integer> threadLocal99 = new ThreadLocal<Integer>();\\nthreadLocal99.set(3);\\nint num = threadLocal99.get();\\nSystem.out.println(\\\"数字:\\\"+num);\\nthreadLocal99.remove();\\nSystem.out.println(\\\"数字Empty:\\\"+threadLocal99.get());\\n```\\n\\n运行结果：\\n\\n```log\\n数字:3\\n数字Empty:null\\n```\\n\\n使用起来很简单，主要是将变量放到ThreadLocal里面，在线程执行过程中就可以取到，当执行完成后在remove掉就可以了，只要没有调用remove()当前线程在执行过程中都是可以拿到变量数据的。\\n因为是放到了当前执行的线程中，所以ThreadLocal中的变量值只能当前线程来使用，从而保证的了线程安全（当前线程的子线程其实也是可以获取到的）。\\n\\n来看一下ThreadLocal的set()方', '发布博客', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 15, '2024-12-24 14:51:39', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (108, 'admin', '/admin/blog', 'POST', '{\"blog\":{\"id\":16,\"title\":\"Java线程池实现原理及其在美团业务中的实践\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/912883e51327e0c7a9d753d11896326511272.png\",\"content\":\"随着计算机行业的飞速发展，摩尔定律逐渐失效，多核CPU成为主流。使用多线程并行计算逐渐成为开发人员提升服务器性能的基本武器。J.U.C提供的线程池：ThreadPoolExecutor类，帮助开发人员管理线程并方便地执行并行任务。了解并合理使用线程池，是一个开发人员必修的基本功。\\n\\n本文开篇简述线程池概念和用途，接着结合线程池的源码，帮助读者领略线程池的设计思路，最后回归实践，通过案例讲述使用线程池遇到的问题，并给出了一种动态化线程池解决方案。\\n\\n## 一、写在前面\\n\\n### 1.1 线程池是什么\\n\\n线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如MySQL。\\n\\n线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。\\n\\n而本文描述线程池是JDK中提供的ThreadPoolExecutor类。\\n\\n当然，使用线程池可以带来一系列好处：\\n\\n- **降低资源消耗**：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。\\n- **提高响应速度**：任务到达时，无需等待线程创建即可立即执行。\\n- **提高线程的可管理性**：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。\\n- **提供更多更强大的功能**：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。\\n\\n### 1.2 线程池解决的问题是什么\\n\\n线程池解决的核心问题就是资源管理问题。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题：\\n\\n1. 频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。\\n2. 对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。\\n3. 系统无法合理管理内部的资源分布，会降低系统的稳定性。\\n\\n为解决资源分配这个问题，线程池采用了“池化”（Pooling）思想。池化，顾名思义，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。\\n\\nPooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finance, computing and equipment management.——wikipedia\\n\\n“池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。\\n\\n在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括：\\n\\n1. 内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。\\n2. 连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。\\n3. 实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。\\n\\n在了解完“是什么”和“为什么”之后，下面我们来一起深入一下线程池的内部实现原理。\\n\\n## 二、线程池核心设计与实现\\n\\n在前文中，我们了解到：线程池是一种通过“池化”思想，帮助我们管理线程而获取并发性的工具，在Java中的体现是ThreadPoolExecutor类。那么它的的详细设计与实现是什么样的呢？我们会在本章进行详细介绍。\\n\\n### 2.1 总体设计\\n\\nJava中', '发布博客', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 21, '2024-12-24 14:53:56', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `operation_log` VALUES (109, 'admin', '/admin/blog', 'POST', '{\"blog\":{\"id\":17,\"title\":\"Java魔法类：Unsafe应用解析\",\"firstPicture\":\"https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/f182555953e29cec76497ebaec526fd1297846.png\",\"content\":\"## 前言\\n\\nUnsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此对Unsafe的使用一定要慎重。\\n\\n注：本文对sun.misc.Unsafe公共API功能及相关应用场景进行介绍。\\n\\n## 基本介绍\\n\\n如下Unsafe源码所示，Unsafe类为一单例实现，提供静态方法getUnsafe获取Unsafe实例，当且仅当调用getUnsafe方法的类为引导类加载器所加载时才合法，否则抛出SecurityException异常。\\n\\n```java\\npublic final class Unsafe {\\n  // 单例对象\\n  private static final Unsafe theUnsafe;\\n\\n  private Unsafe() {\\n  }\\n  @CallerSensitive\\n  public static Unsafe getUnsafe() {\\n    Class var0 = Reflection.getCallerClass();\\n    // 仅在引导类加载器`BootstrapClassLoader`加载时才合法\\n    if(!VM.isSystemDomainLoader(var0.getClassLoader())) {    \\n      throw new SecurityException(\\\"Unsafe\\\");\\n    } else {\\n      return theUnsafe;\\n    }\\n  }\\n}\\n```\\n\\n那如若想使用这个类，该如何获取其实例？有如下两个可行方案。\\n\\n其一，从`getUnsafe`方法的使用限制条件出发，通过Java命令行命令`-Xbootclasspath/a`把调用Unsafe相关方法的类A所在jar包路径追加到默认的bootstrap路径中，使得A被引导类加载器加载，从而通过`Unsafe.getUnsafe`方法安全的获取Unsafe实例。\\n\\n```bash\\njava -Xbootclasspath/a: ${path}   // 其中path为调用Unsafe相关方法的类所在jar包路径\\n```\\n\\n其二，通过反射获取单例对象theUnsafe。\\n\\n```java\\nprivate static Unsafe reflectGetUnsafe() {\\n    try {\\n      Field field = Unsafe.class.getDeclaredField(\\\"theUnsafe\\\");\\n      field.setAccessible(true);\\n      return (Unsafe) field.get(null);\\n    } catch (Exception e) {\\n      log.error(e.getMessage(), e);\\n      return null;\\n    }\\n}\\n```\\n\\n## 功能介绍\\n\\n![img](https://fastly.jsdelivr.net/gh/youtatu-hub/photo/column/assets/f182555953e29cec76497ebaec526fd1297846.png)\\n\\n如上图所示，Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障、数组操作等几类，下面将对其相关方法和应用场景进行详细介绍。\\n\\n### 内存操作\\n\\n这部分主要包含堆外内存的分配、拷贝、释放、给定地址值操作等方法。\\n\\n```java\\n//分配内存, 相当于C++的malloc函数\\npublic native long allocateMemory(long b', '发布博客', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 20, '2024-12-24 14:57:53', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');

-- ----------------------------
-- Table structure for schedule_job
-- ----------------------------
DROP TABLE IF EXISTS `schedule_job`;
CREATE TABLE `schedule_job`  (
  `job_id` bigint NOT NULL AUTO_INCREMENT COMMENT '任务id',
  `bean_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'spring bean名称',
  `method_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '方法名',
  `params` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '参数',
  `cron` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'cron表达式',
  `status` tinyint NULL DEFAULT NULL COMMENT '任务状态',
  `remark` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '备注',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`job_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of schedule_job
-- ----------------------------
INSERT INTO `schedule_job` VALUES (1, 'redisSyncScheduleTask', 'syncBlogViewsToDatabase', '', '0 0 1 * * ?', 1, '每天凌晨一点，从Redis将博客浏览量同步到数据库', '2020-11-17 23:45:42');
INSERT INTO `schedule_job` VALUES (2, 'visitorSyncScheduleTask', 'syncVisitInfoToDatabase', '', '0 0 0 * * ?', 1, '清空当天Redis访客标识，记录当天的PV和UV，更新当天所有访客的PV和最后访问时间，更新城市新增访客UV数', '2021-02-05 08:14:28');

-- ----------------------------
-- Table structure for schedule_job_log
-- ----------------------------
DROP TABLE IF EXISTS `schedule_job_log`;
CREATE TABLE `schedule_job_log`  (
  `log_id` bigint NOT NULL AUTO_INCREMENT COMMENT '任务日志id',
  `job_id` bigint NOT NULL COMMENT '任务id',
  `bean_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'spring bean名称',
  `method_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '方法名',
  `params` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '参数',
  `status` tinyint NOT NULL COMMENT '任务执行结果',
  `error` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '异常信息',
  `times` int NOT NULL COMMENT '耗时（单位：毫秒）',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`log_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of schedule_job_log
-- ----------------------------

-- ----------------------------
-- Table structure for site_setting
-- ----------------------------
DROP TABLE IF EXISTS `site_setting`;
CREATE TABLE `site_setting`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name_en` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `name_zh` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `value` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `type` int NULL DEFAULT NULL COMMENT '1基础设置，2页脚徽标，3资料卡，4友链信息',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 33 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of site_setting
-- ----------------------------
INSERT INTO `site_setting` VALUES (1, 'blogName', '博客名称', 'Youta\'s Blog', 1);
INSERT INTO `site_setting` VALUES (2, 'webTitleSuffix', '网页标题后缀', ' - Youta\'s Blog', 1);
INSERT INTO `site_setting` VALUES (3, 'footerImgTitle', '页脚图片标题', '欢迎来到本站', 1);
INSERT INTO `site_setting` VALUES (4, 'footerImgUrl', '页脚图片路径', '/img/panda-waving.png', 1);
INSERT INTO `site_setting` VALUES (5, 'copyright', 'Copyright', '{\"title\":\"Copyright © 2024 - 2025\",\"siteName\":\"YOUTA\'S BLOG\"}', 1);
INSERT INTO `site_setting` VALUES (6, 'beian', 'ICP备案号', '', 1);
INSERT INTO `site_setting` VALUES (7, 'reward', '赞赏码', '/img/reward.png', 1);
INSERT INTO `site_setting` VALUES (8, 'commentAdminFlag', '博主评论标识', 'youta', 1);
INSERT INTO `site_setting` VALUES (9, 'playlistServer', '播放器平台', 'netease', 1);
INSERT INTO `site_setting` VALUES (10, 'playlistId', '播放器歌单', '3071528549', 1);
INSERT INTO `site_setting` VALUES (11, 'avatar', '头像', '/img/avatar.png', 2);
INSERT INTO `site_setting` VALUES (12, 'name', '昵称', 'Youta', 2);
INSERT INTO `site_setting` VALUES (13, 'rollText', '滚动个签', '\"积跬步以至千里\"，\"致敬每一个爱学习的你\"', 2);
INSERT INTO `site_setting` VALUES (14, 'github', 'GitHub', '', 2);
INSERT INTO `site_setting` VALUES (15, 'telegram', 'Telegram', '', 2);
INSERT INTO `site_setting` VALUES (16, 'qq', 'QQ', '', 2);
INSERT INTO `site_setting` VALUES (17, 'bilibili', 'bilibili', '', 2);
INSERT INTO `site_setting` VALUES (18, 'netease', '网易云音乐', 'https://music.163.com/#/user/home?id=429146781', 2);
INSERT INTO `site_setting` VALUES (19, 'email', 'email', 'mailto:i@youtatu.us.kg', 2);
INSERT INTO `site_setting` VALUES (31, 'friendContent', '友链页面信息', '\n', 4);
INSERT INTO `site_setting` VALUES (32, 'friendCommentEnabled', '友链页面评论开关', '1', 4);

-- ----------------------------
-- Table structure for tag
-- ----------------------------
DROP TABLE IF EXISTS `tag`;
CREATE TABLE `tag`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `tag_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `color` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '标签颜色(可选)',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 7 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tag
-- ----------------------------
INSERT INTO `tag` VALUES (1, 'ElasticSearch', 'teal');
INSERT INTO `tag` VALUES (2, 'Java', 'red');
INSERT INTO `tag` VALUES (3, 'Python', 'blue');
INSERT INTO `tag` VALUES (4, 'mysql', 'purple');
INSERT INTO `tag` VALUES (5, 'Docker', 'blue');
INSERT INTO `tag` VALUES (6, 'Go', 'teal');

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `username` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '用户名',
  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '密码',
  `nickname` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '昵称',
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '头像地址',
  `email` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '邮箱',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NOT NULL COMMENT '更新时间',
  `role` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '角色访问权限',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (1, 'admin', '$2a$10$KnTyH/RvTg6iWoACPvd72.yjLIx6dQtsa.NRSh9wK8s/Cbkv4URCi', 'Admin', '/img/avatar.jpg', 'admin@naccl.top', '2020-09-21 16:47:18', '2024-12-17 15:32:26', 'ROLE_admin');

-- ----------------------------
-- Table structure for visit_log
-- ----------------------------
DROP TABLE IF EXISTS `visit_log`;
CREATE TABLE `visit_log`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `uuid` varchar(36) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '访客标识码',
  `uri` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '请求接口',
  `method` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '请求方式',
  `param` varchar(2000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '请求参数',
  `behavior` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '访问行为',
  `content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '访问内容',
  `remark` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '备注',
  `ip` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'ip',
  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'ip来源',
  `os` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '操作系统',
  `browser` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '浏览器',
  `times` int NOT NULL COMMENT '请求耗时（毫秒）',
  `create_time` datetime NOT NULL COMMENT '访问时间',
  `user_agent` varchar(2000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'user-agent用户代理',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 533 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of visit_log
-- ----------------------------
INSERT INTO `visit_log` VALUES (1, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 100, '2024-12-17 13:49:15', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (2, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/archives', 'GET', '{}', '访问页面', '归档', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-17 13:49:42', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (3, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/moments', 'GET', '{\"pageNum\":1}', '访问页面', '动态', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-17 13:49:44', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (4, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/friends', 'GET', '{}', '访问页面', '友链', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 54, '2024-12-17 13:49:45', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (5, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/about', 'GET', '{}', '访问页面', '关于我', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 21, '2024-12-17 13:52:50', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (6, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 15, '2024-12-17 13:52:57', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (7, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 2, '2024-12-17 13:54:01', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (8, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 86, '2024-12-17 13:54:20', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (9, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/archives', 'GET', '{}', '访问页面', '归档', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-17 13:55:58', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (10, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/moments', 'GET', '{\"pageNum\":1}', '访问页面', '动态', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 38, '2024-12-17 13:56:26', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (11, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/friends', 'GET', '{}', '访问页面', '友链', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-17 13:56:27', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (12, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/about', 'GET', '{}', '访问页面', '关于我', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-17 13:56:45', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (13, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-17 13:56:50', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (14, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 82, '2024-12-17 14:06:34', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (15, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 2, '2024-12-17 14:06:57', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (16, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 66, '2024-12-17 14:10:40', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (17, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 1, '2024-12-17 14:11:08', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (18, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-17 14:11:18', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (19, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 2, '2024-12-17 14:12:45', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (20, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 65, '2024-12-17 14:14:07', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (21, '819bde45-a7e7-308e-863d-efe461f830dc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-17 14:14:22', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (22, '819bde45-a7e7-308e-863d-efe461f830dc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-17 14:14:25', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (23, '819bde45-a7e7-308e-863d-efe461f830dc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 2, '2024-12-17 14:14:34', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (24, '819bde45-a7e7-308e-863d-efe461f830dc', '/friends', 'GET', '{}', '访问页面', '友链', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-17 14:14:48', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (25, '819bde45-a7e7-308e-863d-efe461f830dc', '/moments', 'GET', '{\"pageNum\":1}', '访问页面', '动态', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 13, '2024-12-17 14:14:58', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (26, '819bde45-a7e7-308e-863d-efe461f830dc', '/friends', 'GET', '{}', '访问页面', '友链', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-17 14:14:59', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (27, '819bde45-a7e7-308e-863d-efe461f830dc', '/archives', 'GET', '{}', '访问页面', '归档', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-17 14:14:59', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (28, '819bde45-a7e7-308e-863d-efe461f830dc', '/friends', 'GET', '{}', '访问页面', '友链', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-17 14:15:00', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (29, '819bde45-a7e7-308e-863d-efe461f830dc', '/moments', 'GET', '{\"pageNum\":1}', '访问页面', '动态', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-17 14:25:27', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (30, '819bde45-a7e7-308e-863d-efe461f830dc', '/archives', 'GET', '{}', '访问页面', '归档', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 1, '2024-12-17 14:25:29', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (31, '819bde45-a7e7-308e-863d-efe461f830dc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 1, '2024-12-17 14:25:32', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (32, '819bde45-a7e7-308e-863d-efe461f830dc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 49, '2024-12-17 14:29:14', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (33, '819bde45-a7e7-308e-863d-efe461f830dc', '/archives', 'GET', '{}', '访问页面', '归档', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-17 14:29:21', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (34, '819bde45-a7e7-308e-863d-efe461f830dc', '/moments', 'GET', '{\"pageNum\":1}', '访问页面', '动态', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 28, '2024-12-17 14:29:23', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (35, '819bde45-a7e7-308e-863d-efe461f830dc', '/friends', 'GET', '{}', '访问页面', '友链', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-17 14:29:24', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (36, '819bde45-a7e7-308e-863d-efe461f830dc', '/about', 'GET', '{}', '访问页面', '关于我', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-17 14:29:25', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (37, '819bde45-a7e7-308e-863d-efe461f830dc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-17 14:29:29', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (38, '819bde45-a7e7-308e-863d-efe461f830dc', '/archives', 'GET', '{}', '访问页面', '归档', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 0, '2024-12-17 14:31:11', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (39, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 96, '2024-12-17 14:50:27', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (40, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/archives', 'GET', '{}', '访问页面', '归档', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-17 14:50:46', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (41, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-17 14:50:57', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (42, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/about', 'GET', '{}', '访问页面', '关于我', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-17 14:51:03', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (43, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-17 14:59:54', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (44, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 13, '2024-12-17 15:05:45', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (45, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 2, '2024-12-17 15:05:54', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (46, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 14, '2024-12-17 15:27:09', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (47, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/archives', 'GET', '{}', '访问页面', '归档', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 14, '2024-12-17 15:27:30', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (48, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/moments', 'GET', '{\"pageNum\":1}', '访问页面', '动态', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-17 15:27:41', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (49, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/friends', 'GET', '{}', '访问页面', '友链', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 17, '2024-12-17 15:27:42', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (50, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-17 15:30:53', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (51, '819bde45-a7e7-308e-863d-efe461f830dc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-17 16:41:07', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (52, '819bde45-a7e7-308e-863d-efe461f830dc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-17 16:42:20', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (53, '819bde45-a7e7-308e-863d-efe461f830dc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 14, '2024-12-17 16:42:44', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (54, '819bde45-a7e7-308e-863d-efe461f830dc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-17 16:42:51', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (55, '819bde45-a7e7-308e-863d-efe461f830dc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-17 16:43:43', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (56, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 235, '2024-12-17 17:03:21', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (57, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":1}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 39, '2024-12-17 17:03:30', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (58, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/about', 'GET', '{}', '访问页面', '关于我', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-17 17:08:13', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (59, '3477bede-caf8-313e-8e06-7436d9142767', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 171, '2024-12-18 08:35:55', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (60, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":1}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 40, '2024-12-18 08:36:04', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (61, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":1}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-18 08:46:08', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (62, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":1}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 12, '2024-12-18 08:47:34', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (63, '3477bede-caf8-313e-8e06-7436d9142767', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-18 08:50:49', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (64, '3477bede-caf8-313e-8e06-7436d9142767', '/category', 'GET', '{\"categoryName\":\"技术文章\",\"pageNum\":1}', '查看分类', '技术文章', '分类名称：技术文章，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-18 08:50:59', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (65, '3477bede-caf8-313e-8e06-7436d9142767', '/category', 'GET', '{\"categoryName\":\"技术文章\",\"pageNum\":1}', '查看分类', '技术文章', '分类名称：技术文章，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-18 09:37:24', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (66, '3477bede-caf8-313e-8e06-7436d9142767', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 13, '2024-12-18 09:37:27', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (67, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-18 09:37:36', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (68, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-18 09:39:36', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (69, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-18 09:40:51', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (70, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-18 09:41:10', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (71, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-18 09:41:11', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (72, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-18 09:43:05', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (73, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-18 09:44:35', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (74, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-18 09:44:48', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (75, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-18 09:46:02', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (76, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-18 09:46:13', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (77, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-18 09:48:19', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (78, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 27, '2024-12-18 10:11:37', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (79, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 10, '2024-12-18 10:11:41', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (80, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 18, '2024-12-18 10:12:30', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (81, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-18 10:14:44', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (82, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-18 10:20:31', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (83, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 218, '2024-12-18 10:30:23', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (84, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 24, '2024-12-18 10:30:30', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (85, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 15, '2024-12-18 10:37:16', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (86, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 16, '2024-12-18 10:48:42', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (87, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 12, '2024-12-18 10:48:42', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (88, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 12, '2024-12-18 10:48:43', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (89, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 11, '2024-12-18 10:48:49', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (90, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-18 10:49:07', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (91, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-18 10:49:11', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (92, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 10, '2024-12-18 10:54:48', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (93, '5711e243-58a1-3074-a387-35ae992974d0', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-18 11:00:37', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (94, '5711e243-58a1-3074-a387-35ae992974d0', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 14, '2024-12-18 11:00:41', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (95, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-18 11:02:23', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (96, '819bde45-a7e7-308e-863d-efe461f830dc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-18 11:14:47', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (97, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-18 11:14:50', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (98, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-18 11:15:58', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (99, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-18 11:19:18', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (100, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-18 11:19:20', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (101, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-18 11:19:21', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (102, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 10, '2024-12-18 11:20:22', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (103, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-18 11:20:25', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (104, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 15, '2024-12-18 11:23:25', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (105, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 25, '2024-12-18 11:23:27', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (106, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 10, '2024-12-18 11:26:39', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (107, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 10, '2024-12-18 11:26:39', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (108, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"Python\",\"pageNum\":1}', '查看标签', 'Python', '标签名称：Python，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 26, '2024-12-18 11:29:24', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (109, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"Python\",\"pageNum\":1}', '查看标签', 'Python', '标签名称：Python，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 36, '2024-12-18 11:30:06', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (110, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"mysql\",\"pageNum\":1}', '查看标签', 'mysql', '标签名称：mysql，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-18 11:30:18', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (111, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"Python\",\"pageNum\":1}', '查看标签', 'Python', '标签名称：Python，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-18 11:30:19', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (112, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"Java\",\"pageNum\":1}', '查看标签', 'Java', '标签名称：Java，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 14, '2024-12-18 11:30:19', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (113, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"ElasticSearch\",\"pageNum\":1}', '查看标签', 'ElasticSearch', '标签名称：ElasticSearch，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 74, '2024-12-18 11:30:20', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (114, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 20, '2024-12-18 11:30:23', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (115, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 79, '2024-12-18 11:34:11', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (116, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 87, '2024-12-18 11:34:16', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (117, '3477bede-caf8-313e-8e06-7436d9142767', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 36, '2024-12-18 13:35:41', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (118, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 79, '2024-12-18 13:35:45', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (119, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 21, '2024-12-18 13:35:52', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (120, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 14, '2024-12-18 13:36:10', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (121, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 15, '2024-12-18 13:36:54', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (122, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-18 13:38:01', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (123, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":2}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 10, '2024-12-18 13:49:54', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (124, '3477bede-caf8-313e-8e06-7436d9142767', '/tag', 'GET', '{\"tagName\":\"Java\",\"pageNum\":1}', '查看标签', 'Java', '标签名称：Java，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 32, '2024-12-18 13:53:43', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (125, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":3}', '查看博客', 'Java中的ThreadLocal', '文章标题：Java中的ThreadLocal', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 12, '2024-12-18 13:53:48', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (126, '3477bede-caf8-313e-8e06-7436d9142767', '/archives', 'GET', '{}', '访问页面', '归档', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 11, '2024-12-18 13:58:43', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (127, '3477bede-caf8-313e-8e06-7436d9142767', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 10, '2024-12-18 13:58:45', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (128, '3477bede-caf8-313e-8e06-7436d9142767', '/archives', 'GET', '{}', '访问页面', '归档', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 1, '2024-12-18 13:58:46', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (129, '3477bede-caf8-313e-8e06-7436d9142767', '/category', 'GET', '{\"categoryName\":\"其他\",\"pageNum\":1}', '查看分类', '其他', '分类名称：其他，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-18 13:58:49', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (130, '3477bede-caf8-313e-8e06-7436d9142767', '/category', 'GET', '{\"categoryName\":\"文章\",\"pageNum\":1}', '查看分类', '文章', '分类名称：文章，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 2, '2024-12-18 13:58:51', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (131, '3477bede-caf8-313e-8e06-7436d9142767', '/category', 'GET', '{\"categoryName\":\"文章\",\"pageNum\":1}', '查看分类', '文章', '分类名称：文章，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-18 14:09:24', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (132, '3477bede-caf8-313e-8e06-7436d9142767', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-18 14:09:26', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (133, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":4}', '查看博客', 'Java中的ThreadLocal', '文章标题：Java中的ThreadLocal', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-18 14:09:30', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (134, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":4}', '查看博客', 'Java中的ThreadLocal', '文章标题：Java中的ThreadLocal', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-18 14:13:16', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (135, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":4}', '查看博客', 'Java中的ThreadLocal', '文章标题：Java中的ThreadLocal', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-18 14:14:17', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (136, '819bde45-a7e7-308e-863d-efe461f830dc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 21, '2024-12-18 14:14:23', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (137, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":4}', '查看博客', 'Java中的ThreadLocal', '文章标题：Java中的ThreadLocal', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-18 14:14:26', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (138, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":4}', '查看博客', 'Java中的ThreadLocal', '文章标题：Java中的ThreadLocal', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-18 14:22:27', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (139, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":4}', '查看博客', 'Java中的ThreadLocal', '文章标题：Java中的ThreadLocal', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-18 14:22:27', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (140, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":4}', '查看博客', 'Java中的ThreadLocal', '文章标题：Java中的ThreadLocal', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-18 14:22:34', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (141, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":4}', '查看博客', 'Java中的ThreadLocal', '文章标题：Java中的ThreadLocal', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-18 14:29:30', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (142, '819bde45-a7e7-308e-863d-efe461f830dc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-18 14:29:40', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (143, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":4}', '查看博客', 'Java中的ThreadLocal', '文章标题：Java中的ThreadLocal', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 20, '2024-12-18 14:29:43', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (144, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":4}', '查看博客', 'Java中的ThreadLocal', '文章标题：Java中的ThreadLocal', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-18 14:30:52', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (145, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":4}', '查看博客', 'Java中的ThreadLocal', '文章标题：Java中的ThreadLocal', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 11, '2024-12-18 14:38:00', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (146, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":4}', '查看博客', 'Java中的ThreadLocal', '文章标题：Java中的ThreadLocal', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-18 14:38:00', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (147, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":4}', '查看博客', 'Java中的ThreadLocal', '文章标题：Java中的ThreadLocal', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-18 14:41:33', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (148, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":4}', '查看博客', 'Java中的ThreadLocal', '文章标题：Java中的ThreadLocal', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-18 14:41:33', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (149, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":4}', '查看博客', 'Java中的ThreadLocal', '文章标题：Java中的ThreadLocal', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 10, '2024-12-18 14:42:16', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (150, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":4}', '查看博客', 'Java中的ThreadLocal', '文章标题：Java中的ThreadLocal', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-18 14:42:16', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (151, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":4}', '查看博客', 'Java中的ThreadLocal', '文章标题：Java中的ThreadLocal', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-18 14:42:21', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (152, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":4}', '查看博客', 'Java中的ThreadLocal', '文章标题：Java中的ThreadLocal', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-18 14:44:30', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (153, '3477bede-caf8-313e-8e06-7436d9142767', '/blog', 'GET', '{\"id\":4}', '查看博客', 'Java中的ThreadLocal', '文章标题：Java中的ThreadLocal', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 2, '2024-12-18 14:44:31', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (154, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":4}', '查看博客', 'Java中的ThreadLocal', '文章标题：Java中的ThreadLocal', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-18 14:49:16', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (155, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 36, '2024-12-20 14:50:47', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (156, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-20 14:51:17', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (157, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/archives', 'GET', '{}', '访问页面', '归档', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 13, '2024-12-20 14:51:20', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (158, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/moments', 'GET', '{\"pageNum\":1}', '访问页面', '动态', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 10, '2024-12-20 14:51:22', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (159, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/friends', 'GET', '{}', '访问页面', '友链', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 31, '2024-12-20 14:51:23', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (160, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-20 14:53:27', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (161, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-20 14:54:02', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (162, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 2, '2024-12-20 14:55:48', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (163, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-20 14:56:18', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (164, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 2, '2024-12-20 14:58:52', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (165, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-20 14:59:36', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (166, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/about', 'GET', '{}', '访问页面', '关于我', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-20 15:01:05', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (167, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"其他\",\"pageNum\":1}', '查看分类', '其他', '分类名称：其他，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-20 15:02:33', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (168, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/about', 'GET', '{}', '访问页面', '关于我', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-20 15:02:34', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (169, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/about', 'GET', '{}', '访问页面', '关于我', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 1, '2024-12-20 15:02:43', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (170, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/about', 'GET', '{}', '访问页面', '关于我', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 2, '2024-12-20 15:04:58', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (171, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-20 15:06:30', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (172, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 2, '2024-12-20 15:09:36', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (173, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-20 15:09:53', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (174, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 1, '2024-12-20 15:16:34', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (175, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 112, '2024-12-20 15:20:51', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (176, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":5}', '查看博客', 'JVM 垃圾收集器', '文章标题：JVM 垃圾收集器', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 17, '2024-12-20 15:20:56', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (177, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/about', 'GET', '{}', '访问页面', '关于我', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 1, '2024-12-20 15:21:44', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (178, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 2, '2024-12-20 15:21:58', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (179, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":5}', '查看博客', 'JVM 垃圾收集器', '文章标题：JVM 垃圾收集器', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-20 15:22:02', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (180, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 2, '2024-12-20 15:30:54', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (181, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":5}', '查看博客', 'JVM 垃圾收集器', '文章标题：JVM 垃圾收集器', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-20 15:30:56', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (182, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":5}', '查看博客', 'JVM 垃圾收集器', '文章标题：JVM 垃圾收集器', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 15, '2024-12-20 15:34:28', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (183, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-20 15:41:44', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (184, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":5}', '查看博客', 'JVM 垃圾收集器', '文章标题：JVM 垃圾收集器', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-20 15:44:56', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (185, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":5}', '查看博客', 'JVM 垃圾收集器', '文章标题：JVM 垃圾收集器', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 15, '2024-12-20 16:03:38', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (186, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 13, '2024-12-20 16:16:25', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (187, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":5}', '查看博客', 'JVM 垃圾收集器', '文章标题：JVM 垃圾收集器', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-20 16:16:28', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (188, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":5}', '查看博客', 'JVM 垃圾收集器', '文章标题：JVM 垃圾收集器', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-20 16:22:34', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (189, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":5}', '查看博客', 'JVM 垃圾收集器', '文章标题：JVM 垃圾收集器', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-20 16:22:50', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (190, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/about', 'GET', '{}', '访问页面', '关于我', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 2, '2024-12-20 16:23:43', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (191, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/friends', 'GET', '{}', '访问页面', '友链', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 16, '2024-12-20 16:23:46', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (192, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/moments', 'GET', '{\"pageNum\":1}', '访问页面', '动态', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-20 16:23:50', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (193, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/archives', 'GET', '{}', '访问页面', '归档', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 15, '2024-12-20 16:23:51', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (194, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 14, '2024-12-20 16:24:11', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (195, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":5}', '查看博客', 'JVM 垃圾收集器', '文章标题：JVM 垃圾收集器', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-20 16:24:13', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (196, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":5}', '查看博客', 'JVM 垃圾收集器', '文章标题：JVM 垃圾收集器', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-20 16:28:37', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (197, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":5}', '查看博客', 'JVM 垃圾收集器', '文章标题：JVM 垃圾收集器', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-20 16:28:53', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (198, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":5}', '查看博客', 'JVM 垃圾收集器', '文章标题：JVM 垃圾收集器', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-20 16:29:50', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (199, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":5}', '查看博客', 'JVM 垃圾收集器', '文章标题：JVM 垃圾收集器', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-20 16:30:22', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (200, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":5}', '查看博客', 'JVM 垃圾收集器', '文章标题：JVM 垃圾收集器', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-20 16:37:10', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (201, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":5}', '查看博客', 'JVM 垃圾收集器', '文章标题：JVM 垃圾收集器', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-20 16:37:42', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (202, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":5}', '查看博客', 'JVM 垃圾收集器', '文章标题：JVM 垃圾收集器', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-20 16:38:17', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (203, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":5}', '查看博客', 'JVM 垃圾收集器', '文章标题：JVM 垃圾收集器', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-20 16:39:27', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (204, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":5}', '查看博客', 'JVM 垃圾收集器', '文章标题：JVM 垃圾收集器', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-20 16:39:52', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (205, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":5}', '查看博客', 'JVM 垃圾收集器', '文章标题：JVM 垃圾收集器', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-20 16:40:06', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (206, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":5}', '查看博客', 'JVM 垃圾收集器', '文章标题：JVM 垃圾收集器', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-20 16:41:45', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (207, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":5}', '查看博客', 'JVM 垃圾收集器', '文章标题：JVM 垃圾收集器', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-20 16:42:51', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (208, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-20 16:47:27', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (209, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 25, '2024-12-20 16:55:07', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (210, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":6}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 29, '2024-12-20 16:55:15', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (211, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":6}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-20 16:56:11', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (212, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":6}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-20 16:57:51', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (213, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":6}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-20 17:01:27', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (214, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":6}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-20 17:01:53', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (215, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":6}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-20 17:02:13', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (216, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":6}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 13, '2024-12-20 17:06:32', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (217, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":6}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-20 17:16:25', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (218, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 23, '2024-12-20 17:16:32', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (219, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 13, '2024-12-20 17:16:37', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (220, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 12, '2024-12-20 17:22:01', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (221, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 12, '2024-12-20 17:22:35', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (222, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 64, '2024-12-23 08:49:49', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (223, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-23 08:51:22', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (224, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/searchBlog', 'GET', '{\"query\":\"es\"}', '搜索博客', 'es', '搜索内容：es', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 33, '2024-12-23 08:51:57', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (225, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/searchBlog', 'GET', '{\"query\":\"es\"}', '搜索博客', 'es', '搜索内容：es', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-23 08:52:04', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (226, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-23 09:11:06', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (227, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 49, '2024-12-23 09:30:37', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (228, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 12, '2024-12-23 09:31:14', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (229, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 48, '2024-12-23 09:54:02', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (230, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 11, '2024-12-23 09:55:55', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (231, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 14, '2024-12-23 09:56:46', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (232, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-23 09:57:36', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (233, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 19, '2024-12-23 10:05:37', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (234, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 48, '2024-12-23 10:06:04', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (235, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 15, '2024-12-23 10:06:09', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (236, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":5}', '查看博客', 'JVM 垃圾收集器', '文章标题：JVM 垃圾收集器', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-23 10:06:16', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (237, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 16, '2024-12-23 10:06:42', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (238, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":6}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-23 10:06:54', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (239, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 12, '2024-12-23 10:07:40', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (240, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 13, '2024-12-23 10:08:02', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (241, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/archives', 'GET', '{}', '访问页面', '归档', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 11, '2024-12-23 10:08:30', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (242, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/moments', 'GET', '{\"pageNum\":1}', '访问页面', '动态', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 18, '2024-12-23 10:08:42', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (243, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-23 10:08:44', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (244, '819bde45-a7e7-308e-863d-efe461f830dc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 122, '2024-12-23 10:52:06', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (245, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":9}', '查看博客', 'Java IO 体系、线程模型大总结', '文章标题：Java IO 体系、线程模型大总结', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 35, '2024-12-23 10:52:21', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (246, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":9}', '查看博客', 'Java IO 体系、线程模型大总结', '文章标题：Java IO 体系、线程模型大总结', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-23 10:54:44', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (247, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 24, '2024-12-23 10:57:10', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (248, '819bde45-a7e7-308e-863d-efe461f830dc', '/archives', 'GET', '{}', '访问页面', '归档', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 15, '2024-12-23 10:57:42', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (249, '819bde45-a7e7-308e-863d-efe461f830dc', '/moments', 'GET', '{\"pageNum\":1}', '访问页面', '动态', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 14, '2024-12-23 10:57:46', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (250, '819bde45-a7e7-308e-863d-efe461f830dc', '/archives', 'GET', '{}', '访问页面', '归档', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 1, '2024-12-23 10:57:47', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (251, '819bde45-a7e7-308e-863d-efe461f830dc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 37, '2024-12-23 10:57:49', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (252, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 16, '2024-12-23 10:57:55', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (253, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 17, '2024-12-23 11:00:38', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (254, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 11, '2024-12-23 11:01:11', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (255, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 15, '2024-12-23 11:03:16', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (256, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"文章\",\"pageNum\":1}', '查看分类', '文章', '分类名称：文章，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-23 11:04:19', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (257, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 28, '2024-12-23 11:04:22', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (258, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 31, '2024-12-23 11:09:55', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (259, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 12, '2024-12-23 11:10:38', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (260, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 14, '2024-12-23 11:10:44', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (261, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 11, '2024-12-23 11:10:45', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (262, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 11, '2024-12-23 11:10:46', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (263, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 11, '2024-12-23 11:10:47', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (264, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 14, '2024-12-23 11:11:26', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (265, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 12, '2024-12-23 11:11:26', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (266, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 15, '2024-12-23 11:11:27', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (267, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 11, '2024-12-23 11:13:23', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (268, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 12, '2024-12-23 11:13:36', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (269, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 14, '2024-12-23 11:14:47', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (270, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 24, '2024-12-23 11:15:55', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (271, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 11, '2024-12-23 11:16:03', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (272, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 15, '2024-12-23 11:19:25', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (273, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"文章\",\"pageNum\":1}', '查看分类', '文章', '分类名称：文章，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-23 11:25:23', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (274, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"后端\",\"pageNum\":1}', '查看分类', '后端', '分类名称：后端，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 2, '2024-12-23 11:25:29', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (275, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"前端\",\"pageNum\":1}', '查看分类', '前端', '分类名称：前端，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 2, '2024-12-23 11:25:32', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (276, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 13, '2024-12-23 11:25:34', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (277, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 18, '2024-12-23 11:29:28', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (278, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 11, '2024-12-23 11:29:40', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (279, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 15, '2024-12-23 11:29:41', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (280, '819bde45-a7e7-308e-863d-efe461f830dc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 17, '2024-12-23 11:29:50', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (281, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 10, '2024-12-23 11:29:56', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (282, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":5}', '查看博客', 'JVM 垃圾收集器', '文章标题：JVM 垃圾收集器', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 10, '2024-12-23 11:30:00', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (283, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":5}', '查看博客', 'JVM 垃圾收集器', '文章标题：JVM 垃圾收集器', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-23 11:35:21', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (284, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 14, '2024-12-23 11:35:25', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (285, '819bde45-a7e7-308e-863d-efe461f830dc', '/archives', 'GET', '{}', '访问页面', '归档', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 1, '2024-12-23 11:35:35', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (286, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":6}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-23 11:35:37', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (287, '819bde45-a7e7-308e-863d-efe461f830dc', '/archives', 'GET', '{}', '访问页面', '归档', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 1, '2024-12-23 11:35:39', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (288, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":9}', '查看博客', 'Java IO 体系、线程模型大总结', '文章标题：Java IO 体系、线程模型大总结', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 10, '2024-12-23 11:35:40', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (289, '819bde45-a7e7-308e-863d-efe461f830dc', '/moments', 'GET', '{\"pageNum\":1}', '访问页面', '动态', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-23 11:35:43', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (290, '819bde45-a7e7-308e-863d-efe461f830dc', '/archives', 'GET', '{}', '访问页面', '归档', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 1, '2024-12-23 11:35:44', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (291, '819bde45-a7e7-308e-863d-efe461f830dc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 22, '2024-12-23 11:35:45', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (292, '819bde45-a7e7-308e-863d-efe461f830dc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 22, '2024-12-23 13:20:09', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (293, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":8}', '查看博客', 'JVM 面试的 30 个知识点', '文章标题：JVM 面试的 30 个知识点', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 27, '2024-12-23 13:20:19', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (294, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":9}', '查看博客', 'Java IO 体系、线程模型大总结', '文章标题：Java IO 体系、线程模型大总结', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 10, '2024-12-23 13:28:58', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (295, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"后端\",\"pageNum\":1}', '查看分类', '后端', '分类名称：后端，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-23 13:32:28', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (296, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 16, '2024-12-23 13:37:47', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (297, '819bde45-a7e7-308e-863d-efe461f830dc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-23 13:38:43', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (298, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 10, '2024-12-23 13:39:19', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (299, '819bde45-a7e7-308e-863d-efe461f830dc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-23 14:04:49', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (300, '819bde45-a7e7-308e-863d-efe461f830dc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-23 14:06:34', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (301, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 22, '2024-12-23 14:06:43', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (302, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-23 14:06:52', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (303, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 13, '2024-12-23 14:08:44', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (304, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-23 14:11:35', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (305, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 12, '2024-12-23 14:11:44', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (306, '819bde45-a7e7-308e-863d-efe461f830dc', '/archives', 'GET', '{}', '访问页面', '归档', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 1, '2024-12-23 14:13:23', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (307, '819bde45-a7e7-308e-863d-efe461f830dc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 2, '2024-12-23 14:13:28', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (308, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":8}', '查看博客', 'JVM 面试的 30 个知识点', '文章标题：JVM 面试的 30 个知识点', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-23 14:16:36', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (309, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":8}', '查看博客', 'JVM 面试的 30 个知识点', '文章标题：JVM 面试的 30 个知识点', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 26, '2024-12-23 14:16:50', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (310, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":8}', '查看博客', 'JVM 面试的 30 个知识点', '文章标题：JVM 面试的 30 个知识点', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 16, '2024-12-23 14:16:53', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (311, '819bde45-a7e7-308e-863d-efe461f830dc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 15, '2024-12-23 14:17:19', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (312, '819bde45-a7e7-308e-863d-efe461f830dc', '/blog', 'GET', '{\"id\":9}', '查看博客', 'Java IO 体系、线程模型大总结', '文章标题：Java IO 体系、线程模型大总结', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 10, '2024-12-23 14:17:23', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (313, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 33, '2024-12-24 09:54:41', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (314, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 86, '2024-12-24 09:55:12', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (315, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"后端\",\"pageNum\":1}', '查看分类', '后端', '分类名称：后端，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-24 09:56:13', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (316, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 25, '2024-12-24 09:56:16', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (317, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 20, '2024-12-24 10:00:13', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (318, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 10, '2024-12-24 10:16:00', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (319, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-24 10:17:03', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (320, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-24 10:17:23', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (321, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 11, '2024-12-24 10:18:36', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (322, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-24 10:19:20', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (323, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 14, '2024-12-24 11:00:55', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (324, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 10, '2024-12-24 11:01:07', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (325, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/archives', 'GET', '{}', '访问页面', '归档', '', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-24 11:01:26', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (326, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/moments', 'GET', '{\"pageNum\":1}', '访问页面', '动态', '第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-24 11:01:28', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (327, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-24 11:01:31', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (328, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/about', 'GET', '{}', '访问页面', '关于我', '', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-24 11:01:32', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (329, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-24 11:01:38', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (330, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 18, '2024-12-24 11:01:58', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (331, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 15, '2024-12-24 11:04:26', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (332, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"文章\",\"pageNum\":1}', '查看分类', '文章', '分类名称：文章，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-24 11:07:21', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (333, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"前端\",\"pageNum\":1}', '查看分类', '前端', '分类名称：前端，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-24 11:07:24', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (334, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 13, '2024-12-24 11:07:26', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (335, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 11, '2024-12-24 11:08:04', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (336, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 15, '2024-12-24 11:08:07', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (337, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 11, '2024-12-24 11:10:44', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (338, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-24 11:12:10', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (339, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 28, '2024-12-24 11:12:33', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (340, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"前端\",\"pageNum\":1}', '查看分类', '前端', '分类名称：前端，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 2, '2024-12-24 11:12:55', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (341, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"前端\",\"pageNum\":1}', '查看分类', '前端', '分类名称：前端，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-24 11:13:03', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (342, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 14, '2024-12-24 11:13:06', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (343, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-24 11:13:26', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (344, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-24 11:14:23', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (345, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 10, '2024-12-24 11:14:39', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (346, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-24 11:15:11', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (347, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 11, '2024-12-24 11:15:24', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (348, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":5}', '查看博客', 'JVM 垃圾收集器', '文章标题：JVM 垃圾收集器', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-24 11:15:34', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (349, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 15, '2024-12-24 11:15:57', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (350, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 15, '2024-12-24 11:16:33', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (351, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-24 11:16:43', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (352, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 12, '2024-12-24 11:16:57', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (353, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"文章\",\"pageNum\":1}', '查看分类', '文章', '分类名称：文章，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-24 11:17:13', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (354, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"其他\",\"pageNum\":1}', '查看分类', '其他', '分类名称：其他，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-24 11:17:15', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (355, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 17, '2024-12-24 11:17:17', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (356, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 13, '2024-12-24 11:17:34', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (357, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 21, '2024-12-24 11:17:57', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (358, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 27, '2024-12-24 11:19:14', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (359, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"Java\",\"pageNum\":1}', '查看标签', 'Java', '标签名称：Java，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 13, '2024-12-24 11:19:37', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (360, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-24 11:20:05', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (361, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"Docker\",\"pageNum\":1}', '查看标签', 'Docker', '标签名称：Docker，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-24 11:20:19', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (362, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-24 11:20:29', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (363, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"Docker\",\"pageNum\":1}', '查看标签', 'Docker', '标签名称：Docker，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 13, '2024-12-24 11:20:37', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (364, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 11, '2024-12-24 11:20:38', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (365, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-24 11:20:44', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (366, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-24 11:20:56', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (367, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-24 11:21:32', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (368, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-24 11:21:40', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (369, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 18, '2024-12-24 11:21:44', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (370, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 21, '2024-12-24 11:21:53', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (371, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-24 11:22:17', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (372, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 14, '2024-12-24 11:22:38', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (373, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 18, '2024-12-24 11:23:34', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (374, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 13, '2024-12-24 11:23:46', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (375, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-24 11:24:08', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (376, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"后端\",\"pageNum\":1}', '查看分类', '后端', '分类名称：后端，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 2, '2024-12-24 11:24:17', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (377, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 14, '2024-12-24 11:24:20', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (378, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 13, '2024-12-24 11:24:54', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (379, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-24 11:25:24', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (380, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 11, '2024-12-24 11:25:36', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (381, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-24 11:25:59', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (382, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-24 11:26:02', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (383, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-24 11:26:10', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (384, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 12, '2024-12-24 11:27:02', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (385, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 13, '2024-12-24 11:27:17', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (386, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 11, '2024-12-24 11:28:01', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (387, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 15, '2024-12-24 11:28:10', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (388, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 10, '2024-12-24 11:28:17', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (389, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 12, '2024-12-24 11:28:34', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (390, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 11, '2024-12-24 11:30:06', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (391, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 14, '2024-12-24 11:30:35', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (392, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 11, '2024-12-24 11:30:56', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (393, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 12, '2024-12-24 11:31:17', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (394, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-24 11:31:36', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (395, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 14, '2024-12-24 11:32:10', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (396, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-24 11:32:35', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (397, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-24 11:33:39', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (398, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-24 11:33:51', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (399, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-24 11:34:22', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (400, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-24 11:39:15', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (401, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 2, '2024-12-24 11:39:32', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (402, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-24 11:40:13', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (403, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 11, '2024-12-24 11:41:06', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (404, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-24 11:41:34', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (405, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-24 11:41:40', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (406, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 2, '2024-12-24 11:42:30', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (407, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-24 11:42:58', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (408, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-24 11:43:54', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (409, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-24 11:44:42', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (410, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 12, '2024-12-24 11:45:24', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (411, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"Docker\",\"pageNum\":1}', '查看标签', 'Docker', '标签名称：Docker，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-24 11:47:05', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (412, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"Docker\",\"pageNum\":1}', '查看标签', 'Docker', '标签名称：Docker，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-24 11:47:07', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (413, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"Docker\",\"pageNum\":1}', '查看标签', 'Docker', '标签名称：Docker，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-24 11:48:24', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (414, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"Docker\",\"pageNum\":1}', '查看标签', 'Docker', '标签名称：Docker，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-24 11:49:09', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (415, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"Docker\",\"pageNum\":1}', '查看标签', 'Docker', '标签名称：Docker，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-24 11:49:40', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (416, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"Docker\",\"pageNum\":1}', '查看标签', 'Docker', '标签名称：Docker，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-24 11:49:56', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (417, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"Docker\",\"pageNum\":1}', '查看标签', 'Docker', '标签名称：Docker，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-24 11:50:26', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (418, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"Docker\",\"pageNum\":1}', '查看标签', 'Docker', '标签名称：Docker，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-24 11:50:39', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (419, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"Docker\",\"pageNum\":1}', '查看标签', 'Docker', '标签名称：Docker，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-24 11:50:47', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (420, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 10, '2024-12-24 11:50:55', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (421, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"Docker\",\"pageNum\":1}', '查看标签', 'Docker', '标签名称：Docker，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-24 11:51:02', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (422, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"ElasticSearch\",\"pageNum\":1}', '查看标签', 'ElasticSearch', '标签名称：ElasticSearch，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 12, '2024-12-24 11:52:54', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (423, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"ElasticSearch\",\"pageNum\":1}', '查看标签', 'ElasticSearch', '标签名称：ElasticSearch，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-24 11:53:04', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (424, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"ElasticSearch\",\"pageNum\":1}', '查看标签', 'ElasticSearch', '标签名称：ElasticSearch，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-24 11:53:12', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (425, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"Java\",\"pageNum\":1}', '查看标签', 'Java', '标签名称：Java，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-24 11:53:15', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (426, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"mysql\",\"pageNum\":1}', '查看标签', 'mysql', '标签名称：mysql，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 1, '2024-12-24 11:53:24', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (427, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-24 13:17:00', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (428, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-24 13:17:15', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (429, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"Docker\",\"pageNum\":1}', '查看标签', 'Docker', '标签名称：Docker，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-24 13:17:40', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (430, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"前端\",\"pageNum\":1}', '查看分类', '前端', '分类名称：前端，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 2, '2024-12-24 13:18:52', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (431, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-24 13:18:55', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (432, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"其他\",\"pageNum\":1}', '查看分类', '其他', '分类名称：其他，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 1, '2024-12-24 13:18:58', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (433, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"文章\",\"pageNum\":1}', '查看分类', '文章', '分类名称：文章，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 2, '2024-12-24 13:19:00', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (434, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 15, '2024-12-24 13:19:02', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (435, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"后端\",\"pageNum\":1}', '查看分类', '后端', '分类名称：后端，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 2, '2024-12-24 13:19:04', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (436, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-24 13:19:10', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (437, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/archives', 'GET', '{}', '访问页面', '归档', '', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 1, '2024-12-24 13:19:19', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (438, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 14, '2024-12-24 13:19:22', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (439, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"Go\",\"pageNum\":1}', '查看标签', 'Go', '标签名称：Go，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-24 13:19:25', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (440, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"ElasticSearch\",\"pageNum\":1}', '查看标签', 'ElasticSearch', '标签名称：ElasticSearch，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-24 13:19:28', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (441, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":6}', '查看博客', 'ElasticSearch 小白从入门到精通', '文章标题：ElasticSearch 小白从入门到精通', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 12, '2024-12-24 13:24:11', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (442, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-24 13:25:34', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (443, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-24 13:29:10', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (444, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-24 13:29:45', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (445, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 2, '2024-12-24 13:29:57', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (446, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-24 13:35:28', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (447, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-24 13:35:37', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (448, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"前端\",\"pageNum\":1}', '查看分类', '前端', '分类名称：前端，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-24 13:35:47', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (449, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 14, '2024-12-24 13:35:50', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (450, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 12, '2024-12-24 13:36:05', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (451, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"文章\",\"pageNum\":1}', '查看分类', '文章', '分类名称：文章，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 2, '2024-12-24 13:36:15', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (452, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 10, '2024-12-24 13:36:17', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (453, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-24 13:36:18', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (454, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-24 13:36:23', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (455, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-24 13:36:24', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (456, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-24 13:36:47', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (457, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 10, '2024-12-24 13:45:30', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (458, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 11, '2024-12-24 13:45:54', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (459, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-24 13:46:02', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (460, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-24 13:46:08', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (461, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-24 13:47:23', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (462, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-24 13:47:44', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (463, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-24 13:47:49', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (464, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-24 13:47:51', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (465, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-24 13:49:40', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (466, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 11, '2024-12-24 13:50:34', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (467, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"后端\",\"pageNum\":1}', '查看分类', '后端', '分类名称：后端，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-24 13:51:01', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (468, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"其他\",\"pageNum\":1}', '查看分类', '其他', '分类名称：其他，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-24 13:51:06', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (469, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-24 13:51:10', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (470, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"Docker\",\"pageNum\":1}', '查看标签', 'Docker', '标签名称：Docker，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-24 13:51:20', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (471, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 16, '2024-12-24 13:51:36', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (472, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-24 13:52:27', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (473, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"Go\",\"pageNum\":1}', '查看标签', 'Go', '标签名称：Go，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-24 13:52:31', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (474, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"Go\",\"pageNum\":1}', '查看标签', 'Go', '标签名称：Go，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-24 14:00:18', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (475, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"Go\",\"pageNum\":1}', '查看标签', 'Go', '标签名称：Go，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-24 14:00:33', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (476, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"Go\",\"pageNum\":1}', '查看标签', 'Go', '标签名称：Go，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-24 14:00:49', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (477, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"Go\",\"pageNum\":1}', '查看标签', 'Go', '标签名称：Go，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-24 14:01:04', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (478, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"Go\",\"pageNum\":1}', '查看标签', 'Go', '标签名称：Go，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 10, '2024-12-24 14:01:20', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (479, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"Go\",\"pageNum\":1}', '查看标签', 'Go', '标签名称：Go，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-24 14:01:30', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (480, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"Go\",\"pageNum\":1}', '查看标签', 'Go', '标签名称：Go，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 10, '2024-12-24 14:01:49', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (481, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"Go\",\"pageNum\":1}', '查看标签', 'Go', '标签名称：Go，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-24 14:02:40', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (482, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/tag', 'GET', '{\"tagName\":\"Go\",\"pageNum\":1}', '查看标签', 'Go', '标签名称：Go，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-24 14:02:43', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (483, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-24 14:06:37', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (484, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-24 14:06:44', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (485, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-24 14:06:55', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (486, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 2, '2024-12-24 14:06:57', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (487, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 10, '2024-12-24 14:07:05', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (488, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 11, '2024-12-24 14:08:41', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (489, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-24 14:08:48', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (490, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-24 14:08:50', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (491, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-24 14:08:52', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (492, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 10, '2024-12-24 14:09:02', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (493, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-24 14:09:10', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (494, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 8, '2024-12-24 14:09:11', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (495, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-24 14:09:26', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (496, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 111, '2024-12-24 14:18:30', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (497, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":10}', '查看博客', 'Java NIO浅析', '文章标题：Java NIO浅析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 25, '2024-12-24 14:18:36', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (498, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":10}', '查看博客', 'Java NIO浅析', '文章标题：Java NIO浅析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 11, '2024-12-24 14:23:22', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (499, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":10}', '查看博客', 'Java NIO浅析', '文章标题：Java NIO浅析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-24 14:24:18', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (500, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":10}', '查看博客', 'Java NIO浅析', '文章标题：Java NIO浅析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-24 14:24:55', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (501, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":10}', '查看博客', 'Java NIO浅析', '文章标题：Java NIO浅析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 9, '2024-12-24 14:25:10', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (502, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":10}', '查看博客', 'Java NIO浅析', '文章标题：Java NIO浅析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-24 14:25:20', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (503, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":10}', '查看博客', 'Java NIO浅析', '文章标题：Java NIO浅析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 3, '2024-12-24 14:25:43', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (504, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":10}', '查看博客', 'Java NIO浅析', '文章标题：Java NIO浅析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-24 14:26:27', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (505, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":10}', '查看博客', 'Java NIO浅析', '文章标题：Java NIO浅析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 4, '2024-12-24 14:26:38', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (506, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":10}', '查看博客', 'Java NIO浅析', '文章标题：Java NIO浅析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 6, '2024-12-24 14:26:48', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (507, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":10}', '查看博客', 'Java NIO浅析', '文章标题：Java NIO浅析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-24 14:27:36', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (508, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":10}', '查看博客', 'Java NIO浅析', '文章标题：Java NIO浅析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-24 14:28:23', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (509, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 24, '2024-12-24 14:31:19', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (510, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 12, '2024-12-24 14:31:21', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (511, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 11, '2024-12-24 14:34:00', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (512, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 18, '2024-12-24 14:34:03', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (513, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":2}', '查看分类', '专栏', '分类名称：专栏，第2页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 16, '2024-12-24 14:34:08', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (514, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 16, '2024-12-24 14:34:21', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (515, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":11}', '查看博客', 'Java-直接内存 DirectMemory 详解', '文章标题：Java-直接内存 DirectMemory 详解', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-24 14:34:37', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (516, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 29, '2024-12-24 14:35:01', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (517, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 25, '2024-12-24 14:42:56', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (518, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":12}', '查看博客', 'Java中9种常见的CMS GC问题分析与解决（上）', '文章标题：Java中9种常见的CMS GC问题分析与解决（上）', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 16, '2024-12-24 14:43:05', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (519, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":12}', '查看博客', 'Java中9种常见的CMS GC问题分析与解决（上）', '文章标题：Java中9种常见的CMS GC问题分析与解决（上）', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 13, '2024-12-24 14:45:58', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (520, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 21, '2024-12-24 14:46:00', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (521, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":13}', '查看博客', 'Java中9种常见的CMS GC问题分析与解决（下）', '文章标题：Java中9种常见的CMS GC问题分析与解决（下）', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 7, '2024-12-24 14:46:10', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (522, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 15, '2024-12-24 14:47:06', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (523, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":2}', '查看分类', '专栏', '分类名称：专栏，第2页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 15, '2024-12-24 14:54:12', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (524, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":3}', '查看分类', '专栏', '分类名称：专栏，第3页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 12, '2024-12-24 14:54:18', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (525, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/category', 'GET', '{\"categoryName\":\"专栏\",\"pageNum\":1}', '查看分类', '专栏', '分类名称：专栏，第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 12, '2024-12-24 14:57:58', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (526, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":16}', '查看博客', 'Java线程池实现原理及其在美团业务中的实践', '文章标题：Java线程池实现原理及其在美团业务中的实践', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 5, '2024-12-24 14:58:08', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (527, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 36, '2024-12-24 15:03:24', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (528, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.3.131', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', 10, '2024-12-24 15:03:31', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (529, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 134', 30, '2025-03-20 15:09:08', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (530, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/about', 'GET', '{}', '访问页面', '关于我', '', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 134', 5, '2025-03-20 15:09:16', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (531, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blogs', 'GET', '{\"pageNum\":1}', '访问页面', '首页', '第1页', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 134', 8, '2025-03-20 15:09:22', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36');
INSERT INTO `visit_log` VALUES (532, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '/blog', 'GET', '{\"id\":7}', '查看博客', 'Docker 镜像构建原理及源码分析', '文章标题：Docker 镜像构建原理及源码分析', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 134', 106, '2025-03-20 15:09:31', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36');

-- ----------------------------
-- Table structure for visit_record
-- ----------------------------
DROP TABLE IF EXISTS `visit_record`;
CREATE TABLE `visit_record`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `pv` int NOT NULL COMMENT '访问量',
  `uv` int NOT NULL COMMENT '独立用户',
  `date` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '日期\"02-23\"',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of visit_record
-- ----------------------------

-- ----------------------------
-- Table structure for visitor
-- ----------------------------
DROP TABLE IF EXISTS `visitor`;
CREATE TABLE `visitor`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `uuid` varchar(36) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '访客标识码',
  `ip` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'ip',
  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'ip来源',
  `os` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '操作系统',
  `browser` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '浏览器',
  `create_time` datetime NOT NULL COMMENT '首次访问时间',
  `last_time` datetime NOT NULL COMMENT '最后访问时间',
  `pv` int NULL DEFAULT NULL COMMENT '访问页数统计',
  `user_agent` varchar(2000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'user-agent用户代理',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `idx_uuid`(`uuid` ASC) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of visitor
-- ----------------------------
INSERT INTO `visitor` VALUES (1, '6324f52e-8f62-30c6-b4d3-aa5cf70782cc', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', '2024-12-17 13:49:15', '2024-12-17 13:49:15', 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visitor` VALUES (2, '819bde45-a7e7-308e-863d-efe461f830dc', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', '2024-12-17 14:14:22', '2024-12-17 14:14:22', 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visitor` VALUES (3, '3477bede-caf8-313e-8e06-7436d9142767', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', '2024-12-18 08:35:55', '2024-12-18 08:35:55', 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
INSERT INTO `visitor` VALUES (4, '5711e243-58a1-3074-a387-35ae992974d0', '192.168.0.13', '内网IP|内网IP', 'Windows NT ??', 'Chrome 131', '2024-12-18 11:00:37', '2024-12-18 11:00:37', 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');

SET FOREIGN_KEY_CHECKS = 1;
